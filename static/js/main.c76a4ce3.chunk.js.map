{"version":3,"sources":["constants/globalState.ts","pages/Continents.tsx","pages/Countries.tsx","components/StatCard/StatCard.tsx","graphql/generated.tsx","utils/dates.ts","pages/World.tsx","constants/routes.tsx","layout/Base.tsx","pages/NoMatch.tsx","locales/config/i18n.ts","utils/api.ts","layout/Root.tsx","reportWebVitals.ts","index.tsx"],"names":["useGlobalState","createGlobalState","dateRangeType","Continents","range","Countries","getColor","kind","window","getComputedStyle","document","documentElement","getPropertyValue","styled","AlgorandArgumentsMeasureable","AlgorandBlocksMeasureable","AlgorandBlocksUniq","AlgorandCallsMeasureable","AlgorandNetwork","AlgorandTransactionsMeasureable","AlgorandTransactionsUniq","AlgorandTransferType","AlgorandTransfersMeasureable","AlgorandTxSubType","AlgorandTxType","AmountAggregateFunction","BaseCurrencyEnum","BinanceBlockUniq","BinanceBlocksMeasureable","BinanceOrderSide","BinanceOrderStatus","BinanceOrderTimeInForce","BinanceOrderType","BinanceOrdersMeasureable","BinanceOrdersUniq","BinanceTradesMeasureable","BinanceTradesUniq","BinanceTransactionType","BinanceTransactionsMeasureable","BinanceTransactionsUniq","BinanceTransferType","BinanceTransfersMeasureable","BitcoinBlockUniq","BitcoinBlocksMeasureable","BitcoinCoinpathMethod","BitcoinInputScriptType","BitcoinInputUniq","BitcoinInputsMeasureable","BitcoinNetwork","BitcoinOmniTransactionsMeasureablse","BitcoinOmniTransactionsUniq","BitcoinOmniTransfersMeasureablse","BitcoinOmniTransfersUniq","BitcoinOutputDirection","BitcoinOutputScriptType","BitcoinOutputUniq","BitcoinOutputsMeasureable","BitcoinTransactionUniq","BitcoinTransactionsMeasureable","CardanoBlockUniq","CardanoBlocksMeasureable","CardanoCoinpathMethod","CardanoInputSource","CardanoInputUniq","CardanoInputsMeasureable","CardanoMintUniq","CardanoMintsMeasureable","CardanoNetwork","CardanoOutputDirection","CardanoOutputUniq","CardanoOutputsMeasureable","CardanoTransactionUniq","CardanoTransactionsMeasureable","CoinpathMeasureable","ConfluxBlocksMeasureable","ConfluxNetwork","ConfluxTransactionsMeasureable","Continent","CountryCode","DateInterval","DiemNetwork","ElrondArgumentUniq","ElrondArgumentsMeasureable","ElrondBlockUniq","ElrondBlockValidatorUniq","ElrondBlockValidatorsMeasureable","ElrondBlocksMeasureable","ElrondCallResultUniq","ElrondCallResultsMeasureable","ElrondCallsMeasureable","ElrondCallsUni","ElrondCoinpathMeasureable","ElrondMiniblockUniq","ElrondMiniblocksMeasureable","ElrondNetwork","ElrondNotarizedBlockUniq","ElrondNotarizedBlocksMeasureable","ElrondTransactionUniq","ElrondTransactionsMeasureable","ElrondTransferUniq","ElrondTransfersMeasureable","EntityTypeEnum","EosBlocksMeasureable","EosBlocksUniq","EosCallsMeasureable","EosNetwork","EosTransactionsMeasureable","EosTransactionsUniq","EosTransfersMeasureable","Ethereum2AttestationsMeasureable","Ethereum2AttestationsUniq","Ethereum2AttesterSlashingMeasureable","Ethereum2AttesterSlashingsUniq","Ethereum2BlocksMeasureable","Ethereum2BlocksUniq","Ethereum2DepositsMeasureable","Ethereum2DepositsUniq","Ethereum2Network","Ethereum2ProposerSlashingMeasureable","Ethereum2ProposerSlashingsUniq","Ethereum2VoluntaryExitsMeasureable","Ethereum2VoluntaryExitsUniq","EthereumArgumentsConvertable","EthereumArgumentsMeasureable","EthereumBlocksMeasureable","EthereumBlocksUniq","EthereumCallsMeasureable","EthereumDexTradesMeasureable","EthereumDexTradesUniq","EthereumEventsMeasureable","EthereumNetwork","EthereumTransactionsMeasureable","EthereumTransactionsUniq","EthereumTransfersMeasureable","FilecoinBlockUniq","FilecoinBlocksMeasureable","FilecoinCallsMeasureable","FilecoinMessagesMeasureable","FilecoinMessagesUniq","FilecoinNetwork","FilecoinTransferType","FilecoinTransfersMeasureable","FlowDirection","HarmonyArgumentsMeasureable","HarmonyArgumentsUniq","HarmonyBlocksMeasureable","HarmonyBlocksUniq","HarmonyEventsMeasureable","HarmonyNetwork","HarmonySmartContractCallsMeasureable","HarmonySmartContractCallsUniq","HarmonyStakingTransactionsMeasureable","HarmonyStakingTransactionsUniq","HarmonyTransactionsMeasureable","HarmonyTransactionsUniq","HarmonyTransfersMeasureable","HarmonyTransfersUniq","HederaArgumentsMeasureable","HederaArgumentsUniq","HederaCallsMeasureable","HederaCallsUniq","HederaInputMeasureable","HederaInputsUniq","HederaMessageMeasureable","HederaMessagesUniq","HederaNetwork","HederaOutputMeasureable","HederaOutputUniq","HederaTransactionMeasureable","HederaTransactionsUniq","LibraBlockUniq","LibraBlocksMeasureable","LibraCoinpathMeasureable","LibraMintsMeasureable","LibraMintsUniq","LibraTransactionsMeasureable","LibraTransactionsUniq","LibraTransfersMeasureable","Network","PriceAggregateFunction","Protocol","RippleAccountRootsUniq","RippleBalancesMeasureable","RippleBalancesUniq","RippleBlocksMeasureable","RippleBlocksUniq","RippleChecksMeasureable","RippleChecksUniq","RippleEscrowsMeasureable","RippleEscrowsUniq","RippleNetwork","RippleOffersMeasureable","RippleOffersUniq","RipplePaymentsMeasureable","RipplePaymentsUniq","RippleRippleStatesMeasureable","RippleRippleStatesUniq","RippleTransactionsMeasureable","RippleTransactionsUniq","RippleTransfersMeasureable","RippleTransfersUniq","RippleccountRootsMeasureable","ScriptTypeSelectorSelector","SignatureTypeSelector","SmartContractArgumentsUniq","SmartContractCallsUniq","SmartContractEventsUniq","SmartContractType","SolanaBlockMeasureable","SolanaBlockRewardMeasureable","SolanaBlockRewardUniq","SolanaBlockUniq","SolanaInstructionAccountMeasureable","SolanaInstructionAccountUniq","SolanaInstructionMeasureable","SolanaInstructionUniq","SolanaNetwork","SolanaRewardType","SolanaTransactionMeasureable","SolanaTransactionUniq","SolanaTransferMeasureable","SolanaTransferType","SolanaTransferUniq","StakingTransactionsTypeEnum","StellarNetwork","StellarTransfersMeasureable","StellarTransfersUniq","TradeSide","TransactionTypeEnum","TransferReasonEnum","TransfersUniq","TronBlocksMeasureable","TronBlocksUniq","TronCallsMeasureable","TronContractType","TronContractsMeasureable","TronDexTradesMeasureable","TronDexTradesUniq","TronEventsMeasureable","TronNetwork","TronTradesMeasureable","TronTradesUniq","TronTransactionsMeasureable","TronTransactionsUniq","TronTransfersMeasureable","value","className","loading","children","props","spinning","size","type","isUndefined","Text","defaultOptions","gql","GetFactsDocument","GetFactsPerDatesDocument","getRangeOptions","dateFormat","label","format","startOfWeek","Date","endOfWeek","startOfMonth","endOfMonth","subMonths","startOfYear","endOfYear","World","t","useTranslation","baseOptions","options","Apollo","useGetFactsLazyQuery","getFacts","factsLoading","factsData","data","useGetFactsPerDatesLazyQuery","getFactsPerDates","factsPerDatesLoading","factsPerDatesData","rangeType","calculateChartData","useMemo","flatMap","offchain","covid","facts","fact","year","date","confirmed","category","deaths","recovered","useEffect","find","variables","from","till","gutter","xs","lg","title","height","xField","yField","seriesField","xAxis","color","prefix","routes","WORLD","path","component","settings","icon","PieChartOutlined","name","COUNTRIES","DesktopOutlined","CONTINENTS","UserOutlined","Content","Layout","Sider","Header","Title","Typography","Base","location","useLocation","setRange","console","log","collapsible","theme","selectedKeys","pathname","mode","map","Item","to","justify","level","onChange","style","overflowY","NoMatch","status","subTitle","extra","resources","enGB","translation","translationENGB","i18n","use","initReactI18next","init","interpolation","escapeValue","lng","keySeparator","fallbackLng","authToken","client","process","ApolloClient","link","HttpLink","uri","headers","cache","InMemoryCache","App","ApolloProvider","element","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","Root","getElementById"],"mappings":"6XAEeA,EAAmBC,YAAkB,CAChDC,cAAe,IADJF,e,QCMAG,MANf,WACI,MAAgBH,EAAe,iBAAxBI,EAAP,oBAEA,OAAO,8BAAMA,KCDFC,MAJf,WACI,OAAO,kD,2GCQLC,EAAW,SAACC,GACd,OAAKA,EAESC,OACTC,iBAAiBC,SAASC,iBAC1BC,iBAFS,YAEaL,EAFb,WAFI,MAyBPM,I,MC8VHC,EAuKAC,EAiBAC,EAOAC,EAoFAC,EAkVAC,EAeAC,EA0BAC,EAyKAC,EA2BAC,EAmBAC,EAiBAC,EA0HAC,EAkTAC,EASAC,EAmGAC,EAOAC,EAmBAC,GAOAC,GA6MAC,GA6BAC,GA8NAC,GA+BAC,GAoCAC,GAwOAC,GAuBAC,GAwBAC,GA6OAC,GAiUAC,GAKAC,GAmEAC,GAiDAC,GAqBAC,GAWAC,GAmBAC,GAgCAC,GAaAC,GAkZAC,GAaAC,GASAC,GA8CAC,GAiCAC,GAWAC,GA41BAC,GAOAC,GAubAC,GAaAC,GAmEAC,GAiEAC,GAOAC,GAaAC,GA6BAC,GAWAC,GAeAC,GAKAC,GA8CAC,GAaAC,GAmiCAC,GAOAC,GA8CAC,GAshBAC,GAiBAC,GAiPAC,GAqBAC,GA6BAC,GAmqBAC,GAsFAC,GA4gBAC,GAaAC,GA0UAC,GAwGAC,GAWAC,GAmCAC,GA2iBAC,GAWAC,GAuDAC,GAqDAC,GAiEAC,GAuIAC,GASAC,GAuBAC,GAkGAC,GAWAC,GA4VAC,GAkBAC,GAgTAC,GAWAC,GAkFAC,GA0OAC,GAaAC,GAOAC,GA8FAC,GAmVAC,GAeAC,GAuMAC,GA8aAC,GAiBAC,GAuHAC,GAeAC,GAyOAC,GAaAC,GA+GAC,GAeAC,GA8BAC,GAuGAC,GAeAC,GA0IAC,GAeAC,GAqUAC,GAOAC,GA+SAC,GAeAC,GAOAC,GAsgBAC,GA+BAC,GA6BAC,GAmBAC,GAqnBAC,GAqBAC,GAwMAC,GAuVAC,GAWAC,GA6LAC,GAiXAC,GAmBAC,GAsBAC,GAkBAC,GAwKAC,GA2CAC,GAmQAC,GAuBAC,GA2KAC,GAeAC,GAuBAC,GAuBAC,GAuOAC,GAyBAC,GAkQAC,GAqBAC,GA6JAC,GAuBAC,GAsKAC,GAqBAC,GAkTAC,GAiBAC,GAyMAC,GAiBAC,GA8QAC,GAmBAC,GAoMAC,GAiBAC,GAmBAC,GAkMAC,GAmBAC,GAoLAC,GAiBAC,GA8UAC,GAOAC,GAmEAC,GA0KAC,GAmBAC,GA8NAC,GAmBAC,GAgQAC,GAwHAC,GAqLAC,GA0BAC,GAykBAC,GAkKAC,GAeAC,GAyGAC,GAeAC,GA2LAC,GAeAC,GAiMAC,GAeAC,GAaAC,GAwJAC,GAqBAC,GAoOAC,GA+BAC,GAiKAC,GAmBAC,GAyKAC,GAaAC,GA6IAC,GA2BAC,GAeAC,GAWAC,GAkBAC,GAoBAC,GAqBAC,GAmBAC,GA6BAC,GA4UAC,GAyIAC,GAqBAC,GAaAC,GAyPAC,GAeAC,GAsCAC,GAiBAC,GAWAC,GAKAC,GAqNAC,GAqBAC,GA8JAC,GAqBAC,GAuCAC,GAeAC,GAuCAC,GA+HAC,GAaAC,GA8HAC,GAyJAC,GAqDAC,GAmCAC,GAmVAC,GAeAC,GAOAC,GAwFAC,GAyEAC,GAkmBAC,GA+BAC,GA2BAC,GAuBAC,GAkyBAC,GA2CAC,GA8SAC,GAqBAC,GA+QAC,GDjg2BGvO,gBAhBf,YAA6E,IAAzDwO,EAAwD,EAAxDA,MAAOC,EAAiD,EAAjDA,UAAWC,EAAsC,EAAtCA,QAASC,EAA6B,EAA7BA,SAAaC,EAAgB,iBACxE,OACI,cAAC,IAAD,CAAMC,WAAYH,EAASI,KAAK,QAAhC,SACI,cAAC,IAAD,yBAAMC,KAAK,SAAYH,GAAvB,IAA8BH,UAAWA,EAAzC,SACKO,sBAAYR,GACTG,EAEA,cAAC,IAAWM,KAAZ,CAAiBR,UAAU,iCAA3B,SACKD,YAQzB,+DAAexO,CAAf,yCACoB,gBAAGN,EAAH,EAAGA,KAAH,OAAcD,EAASC,MAG1B,gBAAGA,EAAH,EAAGA,KAAH,OAAcD,EAASC,M,2DChClCwP,GAAkB,I,SA0XZjP,K,gCAAAA,E,gCAAAA,E,cAAAA,E,YAAAA,E,gCAAAA,E,YAAAA,E,kBAAAA,E,sBAAAA,E,mBAAAA,M,cAuKAC,K,cAAAA,E,wBAAAA,E,4BAAAA,E,YAAAA,E,kDAAAA,E,oBAAAA,E,aAAAA,M,cAiBAC,K,cAAAA,E,uBAAAA,M,cAOAC,K,cAAAA,E,YAAAA,E,gCAAAA,E,YAAAA,E,kBAAAA,E,sBAAAA,E,mBAAAA,M,cAoFAC,K,oBAAAA,E,oCAAAA,E,qCAAAA,M,cAkVAC,K,cAAAA,E,YAAAA,E,UAAAA,E,YAAAA,E,kBAAAA,E,uBAAAA,M,cAeAC,K,gBAAAA,E,wBAAAA,E,cAAAA,E,mBAAAA,M,cA0BAC,K,cAAAA,E,gBAAAA,E,gBAAAA,E,kBAAAA,E,gBAAAA,E,YAAAA,E,qBAAAA,M,cAyKAC,K,gBAAAA,E,oBAAAA,E,cAAAA,E,kCAAAA,E,YAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,8BAAAA,E,kBAAAA,E,sBAAAA,E,mBAAAA,M,cA2BAC,K,cAAAA,E,sBAAAA,E,gBAAAA,E,gBAAAA,E,gBAAAA,E,YAAAA,E,YAAAA,E,qBAAAA,M,cAmBAC,K,YAAAA,E,YAAAA,E,YAAAA,E,cAAAA,E,kBAAAA,E,gBAAAA,E,WAAAA,M,cAiBAC,K,UAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,gBAAAA,E,kBAAAA,E,UAAAA,E,gBAAAA,E,2BAAAA,M,cA0HAC,K,UAAAA,E,UAAAA,E,UAAAA,E,aAAAA,M,cAkTAC,K,cAAAA,E,kDAAAA,E,6DAAAA,M,cASAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,YAAAA,E,uCAAAA,M,cAmGAC,K,UAAAA,E,aAAAA,M,cAOAC,K,UAAAA,E,oBAAAA,E,kBAAAA,E,gCAAAA,E,sBAAAA,E,sBAAAA,E,sBAAAA,E,2BAAAA,M,cAmBAC,K,UAAAA,E,WAAAA,Q,cAOAC,K,yBAAAA,Q,cA6MAC,K,0BAAAA,E,8BAAAA,E,cAAAA,E,YAAAA,E,oBAAAA,E,0BAAAA,E,wBAAAA,E,4BAAAA,E,cAAAA,E,4BAAAA,E,gCAAAA,E,YAAAA,E,mBAAAA,Q,cA6BAC,K,kCAAAA,E,gBAAAA,E,cAAAA,E,gBAAAA,E,gBAAAA,E,oCAAAA,E,WAAAA,Q,cA8NAC,K,0BAAAA,E,8BAAAA,E,cAAAA,E,4BAAAA,E,cAAAA,E,YAAAA,E,cAAAA,E,4BAAAA,E,gCAAAA,E,8BAAAA,E,gBAAAA,E,YAAAA,E,oBAAAA,E,mBAAAA,Q,cA+BAC,K,kCAAAA,E,gBAAAA,E,wBAAAA,E,gBAAAA,E,cAAAA,E,oCAAAA,E,0BAAAA,E,kBAAAA,E,gBAAAA,E,WAAAA,Q,cAoCAC,K,YAAAA,E,0CAAAA,E,YAAAA,E,4BAAAA,E,cAAAA,E,sBAAAA,E,wDAAAA,E,kBAAAA,E,0BAAAA,E,oDAAAA,E,4BAAAA,E,4BAAAA,E,cAAAA,E,kBAAAA,E,oCAAAA,E,kCAAAA,E,wCAAAA,E,YAAAA,E,sBAAAA,E,wBAAAA,E,wCAAAA,E,4CAAAA,E,oCAAAA,E,oCAAAA,E,4BAAAA,E,4CAAAA,E,sBAAAA,E,kCAAAA,E,gCAAAA,E,oCAAAA,E,kCAAAA,E,wCAAAA,E,oBAAAA,E,4BAAAA,E,oBAAAA,E,wBAAAA,E,wBAAAA,E,gBAAAA,E,gCAAAA,E,aAAAA,Q,cAwOAC,K,cAAAA,E,kCAAAA,E,YAAAA,E,YAAAA,E,oCAAAA,E,oCAAAA,E,kDAAAA,E,kDAAAA,E,oCAAAA,E,mBAAAA,Q,cAuBAC,K,gBAAAA,E,cAAAA,E,2CAAAA,Q,cAwBAC,K,YAAAA,E,4BAAAA,E,0CAAAA,E,YAAAA,E,cAAAA,E,sBAAAA,E,wDAAAA,E,0BAAAA,E,kBAAAA,E,oDAAAA,E,wCAAAA,E,gCAAAA,E,4BAAAA,E,cAAAA,E,oCAAAA,E,YAAAA,E,wCAAAA,E,4CAAAA,E,oCAAAA,E,4BAAAA,E,4CAAAA,E,sBAAAA,E,oCAAAA,E,sBAAAA,E,wBAAAA,E,oBAAAA,E,4BAAAA,E,gBAAAA,E,iBAAAA,Q,cA6OAC,K,gBAAAA,E,cAAAA,E,kCAAAA,E,YAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,mBAAAA,Q,cAiUAC,K,eAAAA,Q,cAKAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,YAAAA,E,uCAAAA,Q,cAmEAC,K,sBAAAA,E,aAAAA,Q,cAiDAC,K,oBAAAA,E,sBAAAA,E,2BAAAA,Q,cAqBAC,K,sBAAAA,E,gBAAAA,E,cAAAA,E,6BAAAA,Q,cAWAC,K,kBAAAA,E,gBAAAA,E,cAAAA,E,YAAAA,E,0BAAAA,E,YAAAA,E,kBAAAA,E,qBAAAA,Q,cAmBAC,K,kBAAAA,E,kBAAAA,E,sBAAAA,E,YAAAA,E,oBAAAA,E,oBAAAA,E,eAAAA,Q,cAgCAC,K,cAAAA,E,YAAAA,E,YAAAA,E,kBAAAA,E,qBAAAA,Q,cAaAC,K,gBAAAA,E,cAAAA,E,uBAAAA,Q,cAkZAC,K,cAAAA,E,YAAAA,E,YAAAA,E,kBAAAA,E,qBAAAA,Q,cAaAC,K,gBAAAA,E,cAAAA,E,uBAAAA,Q,cASAC,K,gBAAAA,E,UAAAA,E,kBAAAA,E,8BAAAA,E,sCAAAA,E,gBAAAA,E,kBAAAA,E,wBAAAA,E,mBAAAA,Q,cA8CAC,K,oBAAAA,E,0BAAAA,E,oBAAAA,E,gBAAAA,E,wBAAAA,E,wBAAAA,E,kCAAAA,E,wCAAAA,E,+CAAAA,Q,cAiCAC,K,sBAAAA,E,gBAAAA,E,cAAAA,E,6BAAAA,Q,cAWAC,K,kBAAAA,E,gBAAAA,E,cAAAA,E,YAAAA,E,4BAAAA,E,YAAAA,E,kBAAAA,E,qBAAAA,Q,cA41BAC,K,gBAAAA,E,eAAAA,Q,cAOAC,K,cAAAA,E,YAAAA,E,0BAAAA,E,0BAAAA,E,4BAAAA,E,4BAAAA,E,YAAAA,E,kBAAAA,E,oBAAAA,E,mBAAAA,Q,cAubAC,K,cAAAA,E,cAAAA,E,YAAAA,E,0BAAAA,E,mBAAAA,Q,cAaAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,YAAAA,E,uCAAAA,Q,cAmEAC,K,sBAAAA,E,aAAAA,Q,cAiEAC,K,cAAAA,E,yBAAAA,Q,cAOAC,K,sBAAAA,E,gBAAAA,E,wBAAAA,E,cAAAA,E,6BAAAA,Q,cAaAC,K,kBAAAA,E,gBAAAA,E,cAAAA,E,YAAAA,E,0BAAAA,E,YAAAA,E,kBAAAA,E,qBAAAA,Q,cA6BAC,K,gBAAAA,E,wBAAAA,E,cAAAA,E,6BAAAA,Q,cAWAC,K,gBAAAA,E,cAAAA,E,YAAAA,E,YAAAA,E,kBAAAA,E,qBAAAA,Q,cAeAC,K,mBAAAA,Q,cAKAC,K,gBAAAA,E,UAAAA,E,kBAAAA,E,8BAAAA,E,sCAAAA,E,gBAAAA,E,kBAAAA,E,wBAAAA,E,mBAAAA,Q,cA8CAC,K,sBAAAA,E,gBAAAA,E,wBAAAA,E,cAAAA,E,6BAAAA,Q,cAaAC,K,kBAAAA,E,gBAAAA,E,cAAAA,E,YAAAA,E,4BAAAA,E,YAAAA,E,kBAAAA,E,qBAAAA,Q,cAmiCAC,K,gBAAAA,E,eAAAA,Q,cAOAC,K,cAAAA,E,YAAAA,E,8BAAAA,E,0BAAAA,E,0BAAAA,E,wBAAAA,E,4BAAAA,E,4BAAAA,E,YAAAA,E,kBAAAA,E,oBAAAA,E,kBAAAA,E,oCAAAA,E,qCAAAA,Q,cA8CAC,K,cAAAA,E,cAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,mBAAAA,Q,cAshBAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,cAAAA,E,8BAAAA,E,YAAAA,E,uCAAAA,Q,cAiBAC,K,kCAAAA,E,iCAAAA,Q,cAiPAC,K,gBAAAA,E,cAAAA,E,YAAAA,E,UAAAA,E,sBAAAA,E,sBAAAA,E,YAAAA,E,kBAAAA,E,uBAAAA,Q,cAqBAC,K,gBAAAA,E,wBAAAA,E,YAAAA,E,gBAAAA,E,8BAAAA,E,kBAAAA,E,+BAAAA,Q,cA6BAC,K,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,QAAAA,E,SAAAA,Q,cAmqBAC,K,UAAAA,E,cAAAA,E,YAAAA,E,aAAAA,Q,cAsFAC,K,4BAAAA,E,+BAAAA,Q,cA4gBAC,K,gCAAAA,E,4BAAAA,E,cAAAA,E,sBAAAA,E,eAAAA,Q,cAaAC,K,gCAAAA,E,gCAAAA,E,wBAAAA,E,wBAAAA,E,YAAAA,E,YAAAA,E,sBAAAA,E,sBAAAA,E,oBAAAA,E,gBAAAA,E,gCAAAA,E,8DAAAA,E,oDAAAA,E,0CAAAA,E,gDAAAA,E,YAAAA,E,sCAAAA,E,kBAAAA,E,0BAAAA,E,sCAAAA,E,sBAAAA,E,kCAAAA,E,4BAAAA,E,oBAAAA,E,aAAAA,Q,cA0UAC,K,0BAAAA,E,cAAAA,E,gBAAAA,E,eAAAA,Q,cAwGAC,K,cAAAA,E,gBAAAA,E,cAAAA,E,yBAAAA,Q,cAWAC,K,YAAAA,E,cAAAA,E,YAAAA,E,gBAAAA,E,cAAAA,E,0CAAAA,E,oBAAAA,E,sCAAAA,E,cAAAA,E,cAAAA,E,YAAAA,E,oBAAAA,E,kCAAAA,E,YAAAA,E,sCAAAA,E,uBAAAA,Q,cAmCAC,K,YAAAA,E,cAAAA,E,YAAAA,E,gBAAAA,E,cAAAA,E,0CAAAA,E,oBAAAA,E,sCAAAA,E,cAAAA,E,cAAAA,E,YAAAA,E,oBAAAA,E,kCAAAA,E,YAAAA,E,uCAAAA,Q,cA2iBAC,K,cAAAA,E,gBAAAA,E,cAAAA,E,eAAAA,Q,cAWAC,K,wBAAAA,E,oCAAAA,E,oCAAAA,E,sCAAAA,E,4CAAAA,E,wCAAAA,E,YAAAA,E,YAAAA,E,sBAAAA,E,sBAAAA,E,oBAAAA,E,gBAAAA,E,gCAAAA,E,8DAAAA,E,oDAAAA,E,0CAAAA,E,oCAAAA,E,YAAAA,E,sCAAAA,E,kBAAAA,E,0BAAAA,E,sCAAAA,E,sBAAAA,E,kCAAAA,E,oBAAAA,E,aAAAA,Q,cAuDAC,K,wBAAAA,E,wBAAAA,E,YAAAA,E,YAAAA,E,sBAAAA,E,sBAAAA,E,oBAAAA,E,gBAAAA,E,gCAAAA,E,8DAAAA,E,oDAAAA,E,0CAAAA,E,sBAAAA,E,gCAAAA,E,gCAAAA,E,gCAAAA,E,YAAAA,E,sCAAAA,E,kBAAAA,E,0BAAAA,E,sCAAAA,E,sBAAAA,E,kCAAAA,E,oBAAAA,E,aAAAA,Q,cAqDAC,K,cAAAA,E,gBAAAA,E,gDAAAA,E,kCAAAA,E,eAAAA,Q,cAiEAC,K,cAAAA,E,cAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,mBAAAA,Q,cAuIAC,K,cAAAA,E,gBAAAA,E,eAAAA,Q,cASAC,K,wBAAAA,E,YAAAA,E,YAAAA,E,gBAAAA,E,0CAAAA,E,0CAAAA,E,gCAAAA,E,YAAAA,E,sCAAAA,E,aAAAA,Q,cAuBAC,K,iBAAAA,Q,cAkGAC,K,cAAAA,E,gBAAAA,E,4CAAAA,E,eAAAA,Q,cAWAC,K,YAAAA,E,cAAAA,E,YAAAA,E,gBAAAA,E,cAAAA,E,4CAAAA,E,0CAAAA,E,oBAAAA,E,sCAAAA,E,cAAAA,E,cAAAA,E,YAAAA,E,oBAAAA,E,kCAAAA,E,YAAAA,E,uCAAAA,Q,cA4VAC,K,cAAAA,E,gBAAAA,E,eAAAA,Q,cAkBAC,K,wBAAAA,E,YAAAA,E,YAAAA,E,sBAAAA,E,sBAAAA,E,oBAAAA,E,YAAAA,E,gBAAAA,E,gCAAAA,E,8DAAAA,E,oDAAAA,E,0CAAAA,E,YAAAA,E,sCAAAA,E,0BAAAA,E,sCAAAA,E,sBAAAA,E,kCAAAA,E,YAAAA,E,eAAAA,Q,cAgTAC,K,4BAAAA,E,cAAAA,E,sBAAAA,E,eAAAA,Q,cAWAC,K,gBAAAA,E,wBAAAA,E,YAAAA,E,YAAAA,E,sBAAAA,E,sBAAAA,E,oBAAAA,E,gBAAAA,E,gCAAAA,E,8DAAAA,E,oDAAAA,E,0CAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,sCAAAA,E,kBAAAA,E,0BAAAA,E,sCAAAA,E,sBAAAA,E,kCAAAA,E,oBAAAA,E,aAAAA,Q,cAkFAC,K,kBAAAA,E,oBAAAA,E,YAAAA,E,oBAAAA,E,cAAAA,E,eAAAA,Q,cA0OAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,oBAAAA,E,aAAAA,Q,cAaAC,K,cAAAA,E,uBAAAA,Q,cAOAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,sBAAAA,E,gCAAAA,E,gCAAAA,E,gCAAAA,E,YAAAA,E,kBAAAA,E,kBAAAA,E,sBAAAA,E,eAAAA,Q,cA8FAC,K,WAAAA,Q,cAmVAC,K,cAAAA,E,4BAAAA,E,YAAAA,E,kCAAAA,E,YAAAA,E,mBAAAA,Q,cAeAC,K,gBAAAA,E,eAAAA,Q,cAuMAC,K,gBAAAA,E,cAAAA,E,oCAAAA,E,kCAAAA,E,YAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,mBAAAA,Q,cA8aAC,K,cAAAA,E,gCAAAA,E,kCAAAA,E,sBAAAA,E,YAAAA,E,YAAAA,E,uBAAAA,Q,cAiBAC,K,wCAAAA,E,sCAAAA,E,4BAAAA,E,kCAAAA,E,gBAAAA,E,wBAAAA,E,cAAAA,E,yBAAAA,Q,cAuHAC,K,cAAAA,E,gCAAAA,E,kCAAAA,E,YAAAA,E,YAAAA,E,uBAAAA,Q,cAeAC,K,wCAAAA,E,sCAAAA,E,kCAAAA,E,gBAAAA,E,cAAAA,E,yBAAAA,Q,cAyOAC,K,cAAAA,E,gCAAAA,E,kCAAAA,E,YAAAA,E,aAAAA,Q,cAaAC,K,kCAAAA,E,eAAAA,Q,cA+GAC,K,cAAAA,E,gCAAAA,E,kCAAAA,E,YAAAA,E,YAAAA,E,uBAAAA,Q,cAeAC,K,kCAAAA,E,gBAAAA,E,cAAAA,E,yBAAAA,Q,cA8BAC,K,YAAAA,E,mBAAAA,Q,cAuGAC,K,cAAAA,E,gCAAAA,E,kCAAAA,E,YAAAA,E,oBAAAA,E,aAAAA,Q,cAeAC,K,kCAAAA,E,gBAAAA,E,cAAAA,E,kCAAAA,E,wCAAAA,E,iCAAAA,Q,cA0IAC,K,cAAAA,E,gCAAAA,E,kCAAAA,E,YAAAA,E,YAAAA,E,uBAAAA,Q,cAeAC,K,kCAAAA,E,gBAAAA,E,cAAAA,E,yBAAAA,Q,cAqUAC,K,wBAAAA,E,6BAAAA,Q,cAOAC,K,oBAAAA,E,gCAAAA,E,8BAAAA,E,gCAAAA,E,cAAAA,E,wBAAAA,E,gBAAAA,E,YAAAA,E,sBAAAA,E,gCAAAA,E,gCAAAA,E,gCAAAA,E,gCAAAA,E,YAAAA,E,mBAAAA,Q,cA+SAC,K,cAAAA,E,wBAAAA,E,4BAAAA,E,YAAAA,E,cAAAA,E,aAAAA,Q,cAeAC,K,cAAAA,E,iBAAAA,Q,cAOAC,K,cAAAA,E,wBAAAA,E,gBAAAA,E,YAAAA,E,sBAAAA,E,gCAAAA,E,gCAAAA,E,gCAAAA,E,YAAAA,E,mBAAAA,Q,cAsgBAC,K,cAAAA,E,wBAAAA,E,4CAAAA,E,0CAAAA,E,YAAAA,E,cAAAA,E,cAAAA,E,0BAAAA,E,0BAAAA,E,8CAAAA,E,4CAAAA,E,cAAAA,E,YAAAA,E,mBAAAA,Q,cA+BAC,K,kBAAAA,E,8BAAAA,E,gBAAAA,E,4BAAAA,E,cAAAA,E,gBAAAA,E,sBAAAA,E,gCAAAA,E,8BAAAA,E,kBAAAA,E,kCAAAA,E,gBAAAA,E,WAAAA,Q,cA6BAC,K,cAAAA,E,YAAAA,E,sBAAAA,E,gCAAAA,E,gCAAAA,E,gCAAAA,E,YAAAA,E,mBAAAA,Q,cAmBAC,K,UAAAA,E,0BAAAA,E,gCAAAA,E,4BAAAA,E,oBAAAA,E,wBAAAA,E,oCAAAA,E,oBAAAA,E,gBAAAA,E,gBAAAA,E,cAAAA,E,cAAAA,E,+BAAAA,Q,cAqnBAC,K,gBAAAA,E,cAAAA,E,YAAAA,E,UAAAA,E,sBAAAA,E,sBAAAA,E,YAAAA,E,kBAAAA,E,uBAAAA,Q,cAqBAC,K,gBAAAA,E,cAAAA,E,sBAAAA,E,mBAAAA,Q,cAwMAC,K,gBAAAA,E,cAAAA,E,oCAAAA,E,kCAAAA,E,YAAAA,E,sBAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,mBAAAA,Q,cAuVAC,K,gBAAAA,E,cAAAA,E,kBAAAA,E,iBAAAA,Q,cAWAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,cAAAA,E,aAAAA,Q,cA6LAC,K,gBAAAA,E,cAAAA,E,YAAAA,E,UAAAA,E,sBAAAA,E,sBAAAA,E,4BAAAA,E,aAAAA,Q,cAiXAC,K,gBAAAA,E,cAAAA,E,YAAAA,E,UAAAA,E,sBAAAA,E,sBAAAA,E,4BAAAA,E,aAAAA,Q,cAmBAC,K,gBAAAA,E,cAAAA,E,sBAAAA,E,mBAAAA,Q,cAsBAC,K,qBAAAA,Q,cAkBAC,K,YAAAA,E,kBAAAA,E,cAAAA,E,sBAAAA,E,gBAAAA,E,aAAAA,Q,cAwKAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,UAAAA,E,sBAAAA,E,sBAAAA,E,YAAAA,E,kBAAAA,E,eAAAA,Q,cA2CAC,K,kBAAAA,E,qBAAAA,Q,cAmQAC,K,wBAAAA,E,YAAAA,E,oBAAAA,E,gBAAAA,E,sBAAAA,E,gCAAAA,E,gCAAAA,E,gDAAAA,E,sCAAAA,E,aAAAA,Q,cAuBAC,K,wBAAAA,E,cAAAA,E,gBAAAA,E,oBAAAA,E,gBAAAA,E,gDAAAA,E,eAAAA,Q,cA2KAC,K,wBAAAA,E,YAAAA,E,sBAAAA,E,oBAAAA,E,wBAAAA,E,aAAAA,Q,cAeAC,K,wBAAAA,E,cAAAA,E,gBAAAA,E,cAAAA,E,oBAAAA,E,0BAAAA,E,8BAAAA,E,wBAAAA,E,cAAAA,E,uCAAAA,Q,cAuBAC,K,cAAAA,E,YAAAA,E,sBAAAA,E,gCAAAA,E,gCAAAA,E,gCAAAA,E,YAAAA,E,kBAAAA,E,kBAAAA,E,eAAAA,Q,cAuBAC,K,kBAAAA,E,mCAAAA,Q,cAuOAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,sBAAAA,E,gCAAAA,E,gCAAAA,E,gCAAAA,E,YAAAA,E,kBAAAA,E,kBAAAA,E,eAAAA,Q,cAyBAC,K,gBAAAA,E,cAAAA,E,gDAAAA,E,kCAAAA,E,kBAAAA,E,cAAAA,E,WAAAA,Q,cAkQAC,K,YAAAA,E,sCAAAA,E,UAAAA,E,oBAAAA,E,sBAAAA,E,YAAAA,E,oCAAAA,E,sCAAAA,E,eAAAA,Q,cAqBAC,K,cAAAA,E,sCAAAA,E,gBAAAA,E,cAAAA,E,uCAAAA,Q,cA6JAC,K,YAAAA,E,UAAAA,E,oBAAAA,E,oBAAAA,E,sBAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,oCAAAA,E,eAAAA,Q,cAuBAC,K,cAAAA,E,gBAAAA,E,oBAAAA,E,gBAAAA,E,eAAAA,Q,cAsKAC,K,YAAAA,E,UAAAA,E,oBAAAA,E,oBAAAA,E,sBAAAA,E,gBAAAA,E,YAAAA,E,oCAAAA,E,eAAAA,Q,cAqBAC,K,cAAAA,E,gBAAAA,E,gBAAAA,E,cAAAA,E,8BAAAA,E,2BAAAA,Q,cAkTAC,K,YAAAA,E,kBAAAA,E,YAAAA,E,kCAAAA,E,oCAAAA,E,gCAAAA,E,2BAAAA,Q,cAiBAC,K,kCAAAA,E,cAAAA,E,kCAAAA,E,4BAAAA,E,8BAAAA,E,8CAAAA,E,eAAAA,Q,cAyMAC,K,YAAAA,E,kBAAAA,E,YAAAA,E,kCAAAA,E,oCAAAA,E,gCAAAA,E,2BAAAA,Q,cAiBAC,K,kCAAAA,E,cAAAA,E,kCAAAA,E,4BAAAA,E,8BAAAA,E,8CAAAA,E,eAAAA,Q,cA8QAC,K,gBAAAA,E,YAAAA,E,kBAAAA,E,YAAAA,E,kCAAAA,E,oCAAAA,E,gCAAAA,E,2BAAAA,Q,cAmBAC,K,kCAAAA,E,cAAAA,E,sBAAAA,E,0BAAAA,E,kCAAAA,E,4BAAAA,E,8BAAAA,E,eAAAA,Q,cAoMAC,K,YAAAA,E,kBAAAA,E,YAAAA,E,kCAAAA,E,oCAAAA,E,gCAAAA,E,2BAAAA,Q,cAiBAC,K,kCAAAA,E,cAAAA,E,sBAAAA,E,0BAAAA,E,kCAAAA,E,4BAAAA,E,8BAAAA,E,eAAAA,Q,cAmBAC,K,gBAAAA,E,mCAAAA,Q,cAkMAC,K,gBAAAA,E,YAAAA,E,kBAAAA,E,YAAAA,E,kCAAAA,E,oCAAAA,E,gCAAAA,E,2BAAAA,Q,cAmBAC,K,kCAAAA,E,cAAAA,E,sBAAAA,E,0BAAAA,E,kCAAAA,E,4BAAAA,E,8BAAAA,E,cAAAA,E,mCAAAA,Q,cAoLAC,K,YAAAA,E,kBAAAA,E,YAAAA,E,kCAAAA,E,oCAAAA,E,gCAAAA,E,2BAAAA,Q,cAiBAC,K,kCAAAA,E,cAAAA,E,sBAAAA,E,0BAAAA,E,kCAAAA,E,4BAAAA,E,8BAAAA,E,cAAAA,E,qCAAAA,Q,cA8UAC,K,cAAAA,E,qBAAAA,Q,cAOAC,K,cAAAA,E,YAAAA,E,oBAAAA,E,oBAAAA,E,YAAAA,E,mBAAAA,Q,cAmEAC,K,cAAAA,E,cAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,mBAAAA,Q,cA0KAC,K,gBAAAA,E,cAAAA,E,kCAAAA,E,YAAAA,E,gBAAAA,E,YAAAA,E,kBAAAA,E,6BAAAA,Q,cAmBAC,K,gBAAAA,E,wBAAAA,E,cAAAA,E,kBAAAA,E,qBAAAA,Q,cA8NAC,K,cAAAA,E,YAAAA,E,UAAAA,E,sBAAAA,E,0BAAAA,E,YAAAA,E,sBAAAA,E,mBAAAA,Q,cAmBAC,K,gBAAAA,E,cAAAA,E,kBAAAA,E,kBAAAA,E,qBAAAA,Q,cAgQAC,K,gBAAAA,E,kCAAAA,E,YAAAA,E,UAAAA,E,sBAAAA,E,sBAAAA,E,gBAAAA,E,oBAAAA,E,0BAAAA,E,gBAAAA,E,YAAAA,E,sBAAAA,E,kBAAAA,E,6BAAAA,Q,cAwHAC,K,oBAAAA,E,oCAAAA,E,oCAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,sBAAAA,E,UAAAA,E,0BAAAA,E,kBAAAA,E,gCAAAA,E,4BAAAA,E,oBAAAA,E,kCAAAA,E,gCAAAA,E,YAAAA,E,4BAAAA,E,oBAAAA,E,gBAAAA,E,UAAAA,E,YAAAA,E,wBAAAA,E,oCAAAA,E,oBAAAA,E,oBAAAA,E,gBAAAA,E,gBAAAA,E,gBAAAA,E,8BAAAA,E,oBAAAA,E,cAAAA,E,kBAAAA,E,gBAAAA,E,YAAAA,E,cAAAA,E,8BAAAA,E,eAAAA,Q,cAqLAC,K,UAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,gBAAAA,E,kBAAAA,E,WAAAA,Q,cA0BAC,K,oBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,gBAAAA,E,UAAAA,E,oBAAAA,E,oBAAAA,E,gBAAAA,E,cAAAA,E,gBAAAA,E,aAAAA,Q,cAykBAC,K,4BAAAA,E,wBAAAA,E,cAAAA,E,gBAAAA,E,eAAAA,Q,cAkKAC,K,kBAAAA,E,kBAAAA,E,YAAAA,E,YAAAA,E,oCAAAA,E,yCAAAA,Q,cAeAC,K,kBAAAA,E,cAAAA,E,gBAAAA,E,gBAAAA,E,cAAAA,E,kCAAAA,E,uCAAAA,Q,cAyGAC,K,4BAAAA,E,YAAAA,E,gBAAAA,E,0BAAAA,E,YAAAA,E,2BAAAA,Q,cAeAC,K,cAAAA,E,gBAAAA,E,eAAAA,Q,cA2LAC,K,4BAAAA,E,oCAAAA,E,kCAAAA,E,YAAAA,E,gBAAAA,E,aAAAA,Q,cAeAC,K,4BAAAA,E,wBAAAA,E,cAAAA,E,0BAAAA,E,gBAAAA,E,eAAAA,Q,cAiMAC,K,4BAAAA,E,oCAAAA,E,kCAAAA,E,YAAAA,E,gBAAAA,E,aAAAA,Q,cAeAC,K,4BAAAA,E,cAAAA,E,0BAAAA,E,gBAAAA,E,eAAAA,Q,cAaAC,K,iBAAAA,Q,cAwJAC,K,YAAAA,E,0DAAAA,E,wDAAAA,E,0DAAAA,E,wDAAAA,E,YAAAA,E,oCAAAA,E,wCAAAA,E,qCAAAA,Q,cAqBAC,K,cAAAA,E,cAAAA,E,oCAAAA,E,yCAAAA,Q,cAoOAC,K,kDAAAA,E,gDAAAA,E,4BAAAA,E,YAAAA,E,4DAAAA,E,0DAAAA,E,wDAAAA,E,sDAAAA,E,sDAAAA,E,oDAAAA,E,YAAAA,E,oCAAAA,E,8BAAAA,E,2BAAAA,Q,cA+BAC,K,cAAAA,E,gBAAAA,E,cAAAA,E,8BAAAA,E,2BAAAA,Q,cAiKAC,K,4BAAAA,E,oCAAAA,E,kCAAAA,E,YAAAA,E,4BAAAA,E,0BAAAA,E,gBAAAA,E,aAAAA,Q,cAmBAC,K,4BAAAA,E,wBAAAA,E,cAAAA,E,4BAAAA,E,8BAAAA,E,gBAAAA,E,eAAAA,Q,cAyKAC,K,YAAAA,E,gBAAAA,E,YAAAA,E,kCAAAA,E,qCAAAA,Q,cAaAC,K,cAAAA,E,gBAAAA,E,gBAAAA,E,eAAAA,Q,cA6IAC,K,4BAAAA,E,8CAAAA,E,4CAAAA,E,0CAAAA,E,wCAAAA,E,YAAAA,E,gBAAAA,E,YAAAA,E,8BAAAA,E,0BAAAA,E,wBAAAA,E,qBAAAA,Q,cA2BAC,K,4BAAAA,E,wBAAAA,E,cAAAA,E,0BAAAA,E,gBAAAA,E,eAAAA,Q,cAeAC,K,kBAAAA,E,4BAAAA,E,YAAAA,E,aAAAA,Q,cAWAC,K,oDAAAA,E,2CAAAA,Q,cAkBAC,K,cAAAA,E,qBAAAA,Q,cAoBAC,K,gBAAAA,E,kBAAAA,E,cAAAA,E,cAAAA,E,kBAAAA,E,wBAAAA,E,kCAAAA,E,UAAAA,E,iBAAAA,Q,cAqBAC,K,gBAAAA,E,kBAAAA,E,cAAAA,E,cAAAA,E,kBAAAA,E,gDAAAA,E,kCAAAA,E,WAAAA,Q,cAmBAC,K,gBAAAA,E,cAAAA,E,gDAAAA,E,kCAAAA,E,kBAAAA,E,cAAAA,E,WAAAA,Q,cA6BAC,K,UAAAA,E,kBAAAA,E,0CAAAA,E,oBAAAA,E,YAAAA,E,YAAAA,E,cAAAA,E,uBAAAA,Q,cA4UAC,K,wBAAAA,E,YAAAA,E,gBAAAA,E,0BAAAA,E,0CAAAA,E,kBAAAA,E,YAAAA,E,uCAAAA,Q,cAyIAC,K,kBAAAA,E,gBAAAA,E,wBAAAA,E,YAAAA,E,gBAAAA,E,0BAAAA,E,4BAAAA,E,0CAAAA,E,aAAAA,Q,cAqBAC,K,kBAAAA,E,wBAAAA,E,wBAAAA,E,cAAAA,E,eAAAA,Q,cAaAC,K,cAAAA,E,gBAAAA,E,eAAAA,Q,cAyPAC,K,wBAAAA,E,YAAAA,E,gBAAAA,E,0CAAAA,E,sBAAAA,E,aAAAA,Q,cAeAC,K,4BAAAA,E,cAAAA,E,gBAAAA,E,sBAAAA,E,eAAAA,Q,cAsCAC,K,wBAAAA,E,YAAAA,E,UAAAA,E,gBAAAA,E,0CAAAA,E,sBAAAA,E,aAAAA,Q,cAiBAC,K,cAAAA,E,gBAAAA,E,sBAAAA,E,eAAAA,Q,cAWAC,K,iBAAAA,Q,cAKAC,K,UAAAA,E,YAAAA,E,kBAAAA,E,iBAAAA,Q,cAqNAC,K,wBAAAA,E,YAAAA,E,UAAAA,E,gBAAAA,E,0BAAAA,E,0CAAAA,E,sBAAAA,E,YAAAA,E,mCAAAA,Q,cAqBAC,K,cAAAA,E,gBAAAA,E,sBAAAA,E,gBAAAA,E,eAAAA,Q,cA8JAC,K,gBAAAA,E,wBAAAA,E,YAAAA,E,sBAAAA,E,gBAAAA,E,0CAAAA,E,sBAAAA,E,YAAAA,E,+BAAAA,Q,cAqBAC,K,YAAAA,E,8BAAAA,E,gCAAAA,E,YAAAA,E,gCAAAA,E,gCAAAA,E,YAAAA,E,cAAAA,E,gCAAAA,E,8BAAAA,E,oBAAAA,E,aAAAA,Q,cAuCAC,K,cAAAA,E,gBAAAA,E,oCAAAA,E,gCAAAA,E,sBAAAA,E,eAAAA,Q,cAeAC,K,gCAAAA,E,kCAAAA,E,oBAAAA,E,8BAAAA,E,yBAAAA,Q,cAuCAC,K,mBAAAA,Q,cA+HAC,K,YAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,qCAAAA,Q,cAaAC,K,cAAAA,E,oBAAAA,E,gBAAAA,E,cAAAA,E,qCAAAA,Q,cA8HAC,K,UAAAA,E,aAAAA,Q,cAyJAC,K,8BAAAA,E,wBAAAA,E,0BAAAA,E,sBAAAA,E,0BAAAA,E,gCAAAA,E,4BAAAA,E,4BAAAA,E,4BAAAA,E,0BAAAA,E,0BAAAA,E,kBAAAA,E,0CAAAA,E,4CAAAA,E,wCAAAA,E,8BAAAA,E,8BAAAA,E,4BAAAA,E,qBAAAA,Q,cAqDAC,K,0BAAAA,E,8BAAAA,E,4BAAAA,E,2BAAAA,Q,cAmCAC,K,gBAAAA,E,wBAAAA,E,cAAAA,E,sBAAAA,E,kBAAAA,E,sBAAAA,E,WAAAA,Q,cAmVAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,YAAAA,E,kBAAAA,E,mBAAAA,Q,cAeAC,K,cAAAA,E,uBAAAA,Q,cAOAC,K,cAAAA,E,wBAAAA,E,YAAAA,E,sBAAAA,E,gCAAAA,E,gCAAAA,E,gCAAAA,E,YAAAA,E,kBAAAA,E,kBAAAA,E,eAAAA,Q,cAwFAC,K,8BAAAA,E,kDAAAA,E,8BAAAA,E,wBAAAA,E,oBAAAA,E,0BAAAA,E,gCAAAA,E,gCAAAA,E,0CAAAA,E,oCAAAA,E,8BAAAA,E,8CAAAA,E,kCAAAA,E,gCAAAA,E,gCAAAA,E,4BAAAA,E,oBAAAA,E,8BAAAA,E,4BAAAA,E,8BAAAA,E,kCAAAA,E,0BAAAA,E,kCAAAA,E,sCAAAA,E,8BAAAA,E,0BAAAA,E,kCAAAA,E,8BAAAA,E,+BAAAA,Q,cAyEAC,K,cAAAA,E,8BAAAA,E,YAAAA,E,YAAAA,E,kBAAAA,E,qBAAAA,Q,cAkmBAC,K,cAAAA,E,wBAAAA,E,4CAAAA,E,0CAAAA,E,YAAAA,E,cAAAA,E,cAAAA,E,0BAAAA,E,0BAAAA,E,8CAAAA,E,4CAAAA,E,cAAAA,E,YAAAA,E,mBAAAA,Q,cA+BAC,K,kBAAAA,E,8BAAAA,E,gBAAAA,E,4BAAAA,E,cAAAA,E,gBAAAA,E,sBAAAA,E,gCAAAA,E,8BAAAA,E,kCAAAA,E,gBAAAA,E,WAAAA,Q,cA2BAC,K,cAAAA,E,YAAAA,E,sBAAAA,E,gCAAAA,E,gCAAAA,E,gCAAAA,E,YAAAA,E,kBAAAA,E,kBAAAA,E,eAAAA,Q,cAuBAC,K,aAAAA,Q,cAkyBAC,K,wBAAAA,E,0BAAAA,E,cAAAA,E,4CAAAA,E,sCAAAA,E,0CAAAA,E,4BAAAA,E,gCAAAA,E,cAAAA,E,8BAAAA,E,YAAAA,E,0BAAAA,E,8CAAAA,E,wCAAAA,E,4CAAAA,E,8BAAAA,E,kCAAAA,E,gBAAAA,E,YAAAA,E,mBAAAA,Q,cA2CAC,K,gBAAAA,E,gCAAAA,E,gBAAAA,E,cAAAA,E,sBAAAA,E,kCAAAA,E,mBAAAA,Q,cA8SAC,K,cAAAA,E,YAAAA,E,wBAAAA,E,UAAAA,E,sBAAAA,E,0DAAAA,E,sBAAAA,E,YAAAA,E,mBAAAA,Q,cAqBAC,K,gBAAAA,E,eAAAA,Q,cA+QAC,K,gBAAAA,E,cAAAA,E,oCAAAA,E,kCAAAA,E,YAAAA,E,oBAAAA,E,gBAAAA,E,YAAAA,E,oBAAAA,E,wBAAAA,E,mBAAAA,Q,KA+FsBY,aAAH,iLAwCxB,IAAMC,GAAmBD,aAAH,kQA0CtB,IAAME,GAA2BF,aAAH,kV,oFCps2B9B,SAASG,KACZ,IAAMC,EAAa,aACnB,MAAO,CACH,CACIC,MAAO,cACPhB,MAAO,EACPjP,MAAO,CACHkQ,aAAOC,aAAY,IAAIC,MAASJ,GAChCE,aAAOG,aAAU,IAAID,MAASJ,KAGtC,CACIC,MAAO,aACPhB,MAAO,EACPjP,MAAO,CACHkQ,aAAOI,aAAa,IAAIF,MAASJ,GACjCE,aAAOK,aAAW,IAAIH,MAASJ,KAGvC,CACIC,MAAO,aACPhB,MAAO,EACPjP,MAAO,CACHkQ,aAAOI,aAAaE,aAAU,IAAIJ,KAAQ,IAAKJ,GAC/CE,aAAOK,aAAWC,aAAU,IAAIJ,KAAQ,IAAKJ,KAGrD,CACIC,MAAO,YACPhB,MAAO,EACPjP,MAAO,CACHkQ,aAAOO,aAAY,IAAIL,MAASJ,GAChCE,aAAOQ,aAAU,IAAIN,MAASJ,MCgC/BW,OAvEf,WAAkB,IAAD,kBACLC,EAAMC,eAAND,EACR,EFks2BG,SAA8BE,GAC3B,IAAMC,EAAO,2BAAOpB,IAAmBmB,GACvC,OAAOE,KAA2DnB,GAAkBkB,GEps2B3BE,GAA/D,mBAAOC,EAAP,YAA4BC,EAA5B,EAAmBhC,QAA6BiC,EAAhD,EAA0CC,KAC1C,EF8u2BG,SAAsCP,GACnC,IAAMC,EAAO,2BAAOpB,IAAmBmB,GACvC,OAAOE,KAA2ElB,GAA0BiB,GE/u2B9GO,GADJ,mBAAOC,EAAP,YAAoCC,EAApC,EAA2BrC,QAAqCsC,EAAhE,EAA0DJ,KAE1D,EAAoBzR,EAAe,iBAA5B8R,EAAP,oBAEMC,EAAqBC,mBACvB,0BACIC,kBAAO,OAACJ,QAAD,IAACA,GAAD,UAACA,EAAmBK,gBAApB,iBAAC,EAA6BC,aAA9B,aAAC,EAAoCC,OAAO,SAACC,GAAD,gBAAU,CACzD,CAAEC,KAAI,UAAED,EAAKE,YAAP,aAAE,EAAWA,KAAMlD,MAAOgD,EAAKG,UAAWC,SAAUzB,EAAE,cAC5D,CAAEsB,KAAI,UAAED,EAAKE,YAAP,aAAE,EAAWA,KAAMlD,MAAOgD,EAAKK,OAAQD,SAAUzB,EAAE,WACzD,CAAEsB,KAAI,UAAED,EAAKE,YAAP,aAAE,EAAWA,KAAMlD,MAAOgD,EAAKM,UAAWF,SAAUzB,EAAE,oBAEpE,CAACa,IAYL,OATAe,qBAAU,WACN,IAAQxS,EAAUyS,eAAK1C,KAAmB,CAAEd,MAAOyC,IAA3C1R,MAEJA,IACAkR,EAAS,CAAEwB,UAAW,CAAEC,KAAM3S,EAAM,GAAI4S,KAAM5S,EAAM,MACpDuR,EAAiB,CAAEmB,UAAW,CAAEC,KAAM3S,EAAM,GAAI4S,KAAM5S,EAAM,SAEjE,CAAC0R,IAGA,eAAC,IAAD,CAAKmB,OAAQ,CAAC,EAAG,GAAjB,UACI,cAAC,IAAD,CAAKC,GAAI,GAAIC,GAAI,EAAjB,SACI,cAAC,GAAD,CACIC,MAAOpC,EAAE,aACTzQ,KAAK,UACL8O,OAAgB,OAATmC,QAAS,IAATA,GAAA,UAAAA,EAAWU,gBAAX,mBAAqBC,aAArB,mBAA4BC,aAA5B,eAAoC,GAAGI,YAAa,EAC3DjD,QAASgC,MAGjB,cAAC,IAAD,CAAK2B,GAAI,GAAIC,GAAI,EAAjB,SACI,cAAC,GAAD,CACIC,MAAOpC,EAAE,aACTzQ,KAAK,UACL8O,OAAgB,OAATmC,QAAS,IAATA,GAAA,UAAAA,EAAWU,gBAAX,mBAAqBC,aAArB,mBAA4BC,aAA5B,eAAoC,GAAGO,YAAa,EAC3DpD,QAASgC,MAGjB,cAAC,IAAD,CAAK2B,GAAI,GAAIC,GAAI,EAAjB,SACI,cAAC,GAAD,CACIC,MAAOpC,EAAE,UACTzQ,KAAK,QACL8O,OAAgB,OAATmC,QAAS,IAATA,GAAA,UAAAA,EAAWU,gBAAX,mBAAqBC,aAArB,mBAA4BC,aAA5B,eAAoC,GAAGM,SAAU,EACxDnD,QAASgC,MAGjB,cAAC,IAAD,CAAK2B,GAAI,GAAIC,GAAI,GAAjB,SACI,cAAC,GAAD,CAAUC,MAAOpC,EAAE,sBAAuBzB,QAASqC,EAAnD,SACI,cAAC,KAAD,CACIH,KAAMM,EACNsB,OAAQ,IACRC,OAAO,OACPC,OAAO,QACPC,YAAY,WACZC,MAAO,CACH7D,KAAM,QAEV8D,MAAO,CAAC,UAAW,UAAW,qBCpEhDC,GAAS,kBAEFC,GAAS,CAClBC,MAAO,CACHC,KAAK,GAAD,OAAKH,GAAL,KACJI,UAAW,cAAC,GAAD,IACXC,SAAU,CACNC,KAAM,cAACC,EAAA,EAAD,KAEVC,KAAM,SAEVC,UAAW,CACPN,KAAK,GAAD,OAAKH,GAAL,cACJI,UAAW,cAAC,EAAD,IACXC,SAAU,CACNC,KAAM,cAACI,EAAA,EAAD,KAEVF,KAAM,aAEVG,WAAY,CACRR,KAAK,GAAD,OAAKH,GAAL,eACJI,UAAW,cAAC,EAAD,IACXC,SAAU,CACNC,KAAM,cAACM,EAAA,EAAD,KAEVJ,KAAM,e,mBCrBNK,GAA2BC,IAA3BD,QAASE,GAAkBD,IAAlBC,MAAOC,GAAWF,IAAXE,OAChBC,GAAgBC,IAAhBD,MAAO9E,GAAS+E,IAAT/E,KAoDAgF,OA9Cf,YAAoC,IAApBtF,EAAmB,EAAnBA,SACNuF,EAAWC,eACThE,EAAMC,eAAND,EACR,EAA0BhR,EAAe,iBAAzC,mBAAOI,EAAP,KAAc6U,EAAd,KAIA,OAFAC,QAAQC,IAAIhF,KAAmB,mBAG3B,eAAC,IAAD,CAAQb,UAAU,WAAlB,UACI,cAACoF,GAAD,CAAOU,aAAW,EAAlB,SACI,cAAC,IAAD,CAAMC,MAAM,OAAOC,aAAc,CAACP,EAASQ,UAAWC,KAAK,SAA3D,SACKC,cAAI7B,IAAQ,gBAAGO,EAAH,EAAGA,KAAkBF,EAArB,EAASD,SAAYC,KAAQH,EAA7B,EAA6BA,KAA7B,OACT,cAAC,IAAK4B,KAAN,CAAsBzB,KAAMA,EAA5B,SACI,cAAC,KAAD,CAAM0B,GAAI7B,EAAV,SAAiB9C,EAAEmD,MADPL,UAM5B,eAAC,IAAD,WACI,cAACa,GAAD,CAAQrF,UAAU,8BAAlB,SACI,eAAC,IAAD,CAAKsG,QAAQ,gBAAgBtG,UAAU,eAAvC,UACI,cAACsF,GAAD,CAAOiB,MAAO,EAAGvG,UAAU,0CAA3B,SACK0B,EAAE,2BAEP,gCACI,cAAClB,GAAD,CAAMR,UAAU,kBAAhB,SAAmC0B,EAAE,gBACrC,cAAC,IAAD,CACI3B,MAAOjP,EACP0V,SAAU,SAACzG,GAAD,OAAW4F,EAAS5F,IAC9BC,UAAU,OACV6B,QAASsE,cAAItF,MAAmB,gBAAGd,EAAH,EAAGA,MAAOgB,EAAV,EAAUA,MAAV,MAAuB,CACnDhB,QACAgB,MAAOW,EAAEX,iBAM7B,cAACmE,GAAD,CAASlF,UAAU,MAAMyG,MAAO,CAAEC,UAAW,QAA7C,SACKxG,W,oBC1CNyG,OAXf,WACI,OACI,cAAC,KAAD,CACIC,OAAO,MACP9C,MAAM,MACN+C,SAAS,8CACTC,MAAO,cAAC,KAAD,CAAQxG,KAAK,UAAb,0B,8BCJbyG,GAAY,CACdC,KAAM,CACFC,YAAaC,KAIrBC,KAAKC,IAAIC,MAAkBC,KAAK,CAC5BP,aACAQ,cAAe,CACXC,aAAa,GAEjBC,IAAK,OACLC,cAAc,EACdC,YAAa,SAGFR,GAAf,EAAeA,IClBoBS,GCQ7BC,IDR6BD,GCQDE,mCDPvB,IAAIC,IAAa,CACpBC,KAAM,IAAIC,IAAS,CACfC,IAAKJ,8BACLK,QAAS,CACL,YAAaP,MAGrBQ,MAAO,IAAIC,OCoBJC,OAlBf,WACI,OACI,cAACC,EAAA,EAAD,CAAgBV,OAAQA,GAAxB,SACI,cAAC,KAAD,UACI,cAAC,GAAD,UACI,eAAC,KAAD,WACK1B,cAAI7B,IAAQ,gBAAGE,EAAH,EAAGA,KAAMC,EAAT,EAASA,UAAT,OACT,cAAC,KAAD,CAAkBD,KAAMA,EAAMgE,QAAS/D,GAA3BD,MAGhB,cAAC,KAAD,CAAOA,KAAK,IAAIgE,QAAS,cAAC,GAAD,gBCRlCC,GAZS,SAACC,GACjBA,GAAeA,aAAuBC,UACtC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QACzDJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCJpBQ,IAASC,OACL,cAAC,IAAMC,WAAP,UACI,cAACC,GAAD,MAEJjY,SAASkY,eAAe,SAM5Bb,O","file":"static/js/main.c76a4ce3.chunk.js","sourcesContent":["import { createGlobalState } from 'react-hooks-global-state';\r\n\r\nexport const { useGlobalState } = createGlobalState({\r\n    dateRangeType: 1,\r\n});\r\n","import { useGlobalState } from 'constants/globalState';\r\n\r\nfunction Continents() {\r\n    const [range] = useGlobalState('dateRangeType');\r\n\r\n    return <div>{range}</div>;\r\n}\r\n\r\nexport default Continents;\r\n","function Countries() {\r\n    return <>Countries</>;\r\n}\r\n\r\nexport default Countries;\r\n","import { Card, CardProps, Spin, Typography } from 'antd';\nimport { isUndefined } from 'lodash';\nimport styled from 'styled-components';\n\nexport type Props = {\n    kind?: 'success' | 'warning' | 'error';\n    value?: number;\n} & CardProps;\n\nconst getColor = (kind: Props['kind']) => {\n    if (!kind) return null;\n\n    const color = window\n        .getComputedStyle(document.documentElement)\n        .getPropertyValue(`--${kind}-color`);\n\n    return color;\n};\n\nfunction StatCard({ value, className, loading, children, ...props }: Props) {\n    return (\n        <Spin spinning={!!loading} size=\"large\">\n            <Card type=\"inner\" {...props} className={className}>\n                {isUndefined(value) ? (\n                    children\n                ) : (\n                    <Typography.Text className=\"block text-center text-6xl p-4\">\n                        {value}\n                    </Typography.Text>\n                )}\n            </Card>\n        </Spin>\n    );\n}\n\nexport default styled(StatCard)`\n    border-color: ${({ kind }) => getColor(kind)};\n\n    & span {\n        color: ${({ kind }) => getColor(kind)};\n    }\n`;\n","import { gql } from '@apollo/client';\nimport * as Apollo from '@apollo/client';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nconst defaultOptions =  {}\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */\n  BigInt: any;\n  /**\n   * Represents fractional signed whole numeric values.\n   * Since the value may exceed the size of a 32-bit integer, it's encoded as a string.\n   */\n  DecimalNumber: any;\n  /**\n   * Represents fractional signed whole numeric values.\n   * Since the value may exceed the size of a 32-bit integer, it's encoded as a string.\n   */\n  DecimalNumberAsDiv: any;\n  /** An ISO 8601-encoded date */\n  ISO8601Date: any;\n  /** An ISO 8601-encoded datetime */\n  ISO8601DateTime: any;\n};\n\n/** Account */\nexport type Account = {\n  __typename?: 'Account';\n  /** Account ID */\n  id: Scalars['String'];\n  /** Account number, the equivalent of a human-friendly public key */\n  num: Scalars['Int'];\n  /** Realm number  */\n  realmId: Scalars['Int'];\n  /** Shard number */\n  shardId: Scalars['Int'];\n};\n\n/** Solana Action */\nexport type Action = {\n  __typename?: 'Action';\n  name: Scalars['String'];\n  type: Scalars['String'];\n};\n\n/** Blockchain address */\nexport type Address = {\n  __typename?: 'Address';\n  /** Address */\n  address?: Maybe<Scalars['String']>;\n  /** Annotations ( tags ), if exists */\n  annotation?: Maybe<Scalars['String']>;\n};\n\n/** Address selector */\nexport type AddressSelector = {\n  /** In the list of Addresses */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Equal to Address */\n  is?: InputMaybe<Scalars['String']>;\n  /** Not Equal to Address */\n  not?: InputMaybe<Scalars['String']>;\n  /** Not in the list of Addresses */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Address selector */\nexport type AddressSelectorIn = {\n  /** In the list of Addresses */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Equal to Address */\n  is?: InputMaybe<Scalars['String']>;\n};\n\n/** Blockchain account with address and type */\nexport type AddressWithAccount = {\n  __typename?: 'AddressWithAccount';\n  /** Account ID */\n  account: Scalars['String'];\n  /** Address */\n  address?: Maybe<Scalars['String']>;\n  /** Annotations ( tags ), if exists */\n  annotation?: Maybe<Scalars['String']>;\n  /** Account type */\n  type: Scalars['String'];\n};\n\n/** Algorand Blockchain */\nexport type Algorand = {\n  __typename?: 'Algorand';\n  /** Basic information about address ( or smart contract ) */\n  address: Array<AlgorandAddressInfo>;\n  /** Arguments of Smart Contract Calls and Events */\n  arguments?: Maybe<Array<AlgorandArguments>>;\n  /** Blockchain Blocks */\n  blocks?: Maybe<Array<AlgorandBlocks>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<AlgorandCoinpath>>;\n  /** Smart Contract Calls */\n  smartContractCalls?: Maybe<Array<AlgorandSmartContractCalls>>;\n  /** Blockchain Transactions */\n  transactions?: Maybe<Array<AlgorandTransactions>>;\n  /** Currency Transfers */\n  transfers?: Maybe<Array<AlgorandTransfers>>;\n};\n\n\n/** Algorand Blockchain */\nexport type AlgorandaddressArgs = {\n  address: Array<AddressSelectorIn>;\n};\n\n\n/** Algorand Blockchain */\nexport type AlgorandargumentsArgs = {\n  any?: InputMaybe<Array<AlgorandArgumentFilter>>;\n  argindex?: InputMaybe<ArgumentIndexSelector>;\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  caller?: InputMaybe<Array<AddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  reference?: InputMaybe<Array<AddressSelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<AddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txType?: InputMaybe<TxTypeSelector>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Algorand Blockchain */\nexport type AlgorandblocksArgs = {\n  any?: InputMaybe<Array<AlgorandBlockFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  currentProtocol?: InputMaybe<StringIdSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  nextProtocol?: InputMaybe<StringIdSelector>;\n  options?: InputMaybe<QueryOptions>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Algorand Blockchain */\nexport type AlgorandcoinpathArgs = {\n  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<AddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CoinpathOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Algorand Blockchain */\nexport type AlgorandsmartContractCallsArgs = {\n  any?: InputMaybe<Array<AlgorandSmartContractCallFilter>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txType?: InputMaybe<TxTypeSelector>;\n};\n\n\n/** Algorand Blockchain */\nexport type AlgorandtransactionsArgs = {\n  any?: InputMaybe<Array<AlgorandTransactionFilter>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txSubtype?: InputMaybe<TxSubtypeSelector>;\n  txType?: InputMaybe<TxTypeSelector>;\n};\n\n\n/** Algorand Blockchain */\nexport type AlgorandtransfersArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<AlgorandTransferFilter>>;\n  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<Array<AddressSelector>>;\n  sender?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transferType?: InputMaybe<AlgorandTransferTypeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txType?: InputMaybe<TxTypeSelector>;\n};\n\n/** Address detailed information for Algorand network */\nexport type AlgorandAddressInfo = {\n  __typename?: 'AlgorandAddressInfo';\n  /** Address */\n  address?: Maybe<Address>;\n  /** Current address balance */\n  balance?: Maybe<Scalars['Float']>;\n  /** Current pending rewards */\n  pendingRewards?: Maybe<Scalars['Float']>;\n  /** Current rewards */\n  rewards?: Maybe<Scalars['Float']>;\n  /** Current round */\n  round?: Maybe<Scalars['String']>;\n  /** Smart Contract if exists on the address */\n  smartContract?: Maybe<AlgorandSmartContract>;\n  /** Current status */\n  status?: Maybe<Scalars['String']>;\n};\n\nexport type AlgorandArgumentFilter = {\n  argindex?: InputMaybe<ArgumentIndexSelector>;\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  caller?: InputMaybe<Array<AddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  reference?: InputMaybe<Array<AddressSelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<AddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txType?: InputMaybe<TxTypeSelector>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArguments = {\n  __typename?: 'AlgorandArguments';\n  any?: Maybe<Scalars['String']>;\n  /** Sequential index of value in array ( multi-dimensional) */\n  argindex: Scalars['Int'];\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  firstRound?: Maybe<Scalars['Int']>;\n  genesisHash64?: Maybe<Scalars['String']>;\n  genesisId?: Maybe<Scalars['String']>;\n  lastRound?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  note?: Maybe<Scalars['String']>;\n  poolerror?: Maybe<Scalars['String']>;\n  /** Smart contract being called */\n  smartContract?: Maybe<AlgorandSmartContract>;\n  /** Transaction where call happened */\n  transaction?: Maybe<TransactionHashIndex>;\n  /** Transaction sender */\n  txSender?: Maybe<Address>;\n  /** Transaction type in which the transfer happened */\n  txType?: Maybe<AlgorandTxType>;\n  /** The Value of argument */\n  value?: Maybe<Scalars['String']>;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentsanyArgs = {\n  of: AlgorandArgumentsMeasureable;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentscountArgs = {\n  argindex?: InputMaybe<ArgumentIndexSelector>;\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  caller?: InputMaybe<Array<AddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  reference?: InputMaybe<Array<AddressSelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<AddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txType?: InputMaybe<TxTypeSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentscountBigIntArgs = {\n  argindex?: InputMaybe<ArgumentIndexSelector>;\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  caller?: InputMaybe<Array<AddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  reference?: InputMaybe<Array<AddressSelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<AddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txType?: InputMaybe<TxTypeSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentsmaximumArgs = {\n  get?: InputMaybe<AlgorandArgumentsMeasureable>;\n  of: AlgorandArgumentsMeasureable;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentsminimumArgs = {\n  get?: InputMaybe<AlgorandArgumentsMeasureable>;\n  of: AlgorandArgumentsMeasureable;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentssmartContractArgs = {\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentstransactionArgs = {\n  txFrom?: InputMaybe<Array<AddressSelector>>;\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentstxSenderArgs = {\n  txSender?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentstxTypeArgs = {\n  txType?: InputMaybe<Array<AlgorandTxType>>;\n};\n\n\n/** Arguments of Smart Contract Calls */\nexport type AlgorandArgumentsvalueArgs = {\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\nexport enum AlgorandArgumentsMeasureable {\n  /** Argument index */\n  argument_index = 'argument_index',\n  /** Argument value */\n  argument_value = 'argument_value',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction Sender */\n  tx_sender = 'tx_sender',\n  /** Transaction type */\n  tx_type = 'tx_type'\n}\n\nexport type AlgorandBlockFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  currentProtocol?: InputMaybe<StringIdSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  nextProtocol?: InputMaybe<StringIdSelector>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlocks = {\n  __typename?: 'AlgorandBlocks';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  currentProtocol?: Maybe<Scalars['String']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  frac: Scalars['BigInt'];\n  /** Block hash */\n  hash: Scalars['String'];\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  nextProtocol?: Maybe<Scalars['String']>;\n  nextProtocolApprovals?: Maybe<Scalars['BigInt']>;\n  nextProtocolSwitchOn?: Maybe<Scalars['BigInt']>;\n  nextProtocolVoteBefore?: Maybe<Scalars['BigInt']>;\n  /** Previous block hash */\n  previousBlockHash: Scalars['String'];\n  /** Block proposer */\n  proposer?: Maybe<Address>;\n  rate?: Maybe<Scalars['Float']>;\n  reward?: Maybe<Scalars['Float']>;\n  seed?: Maybe<Scalars['String']>;\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n  txnRoot: Scalars['String'];\n  upgradeApprove?: Maybe<Scalars['Int']>;\n  upgradePropose?: Maybe<Scalars['String']>;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlocksanyArgs = {\n  of: AlgorandBlocksMeasureable;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlockscountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  currentProtocol?: InputMaybe<StringIdSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  nextProtocol?: InputMaybe<StringIdSelector>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<AlgorandBlocksUniq>;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlockscountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  currentProtocol?: InputMaybe<StringIdSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  nextProtocol?: InputMaybe<StringIdSelector>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<AlgorandBlocksUniq>;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlockshashArgs = {\n  blockHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlocksheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlocksmaximumArgs = {\n  get?: InputMaybe<AlgorandBlocksMeasureable>;\n  of: AlgorandBlocksMeasureable;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlocksminimumArgs = {\n  get?: InputMaybe<AlgorandBlocksMeasureable>;\n  of: AlgorandBlocksMeasureable;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlocksproposerArgs = {\n  proposer?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlocksrateArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currentProtocol?: InputMaybe<StringIdSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  nextProtocol?: InputMaybe<StringIdSelector>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlocksrewardArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currentProtocol?: InputMaybe<StringIdSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nextProtocol?: InputMaybe<StringIdSelector>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Algorand blockchain */\nexport type AlgorandBlockstimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport enum AlgorandBlocksMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Block Reward */\n  block_reward = 'block_reward',\n  /** Date */\n  date = 'date',\n  /** Next protocol approvals */\n  next_protocol_approvals = 'next_protocol_approvals',\n  /** Block Proposer */\n  proposer = 'proposer',\n  /** Time */\n  time = 'time'\n}\n\nexport enum AlgorandBlocksUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique proposer count */\n  proposers = 'proposers'\n}\n\nexport enum AlgorandCallsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction Sender */\n  tx_sender = 'tx_sender',\n  /** Transaction type */\n  tx_type = 'tx_type'\n}\n\n/** Coinpath */\nexport type AlgorandCoinpath = {\n  __typename?: 'AlgorandCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<Address>;\n  /** Sender address */\n  sender?: Maybe<Address>;\n  /** Transaction of transfer happened */\n  transaction?: Maybe<TransactionHashValue>;\n};\n\n\n/** Coinpath */\nexport type AlgorandCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Coinpath */\nexport type AlgorandCoinpathanyArgs = {\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type AlgorandCoinpathmaximumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type AlgorandCoinpathminimumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n/**\n * Currency selector in Algorand blockchain.\n *   Currency is selected by asset ID. To select ALGO use ID=0\n */\nexport type AlgorandCurrencySelector = {\n  /** Currency in the list */\n  in?: InputMaybe<Array<Scalars['Int']>>;\n  /** Currency is */\n  is?: InputMaybe<Scalars['Int']>;\n  /** Currency not */\n  not?: InputMaybe<Scalars['Int']>;\n  /** Currency not in the list */\n  notIn?: InputMaybe<Array<Scalars['Int']>>;\n};\n\nexport enum AlgorandNetwork {\n  /** Algorand Mainnet (ALGO) */\n  algorand = 'algorand',\n  /** Algorand Betanet */\n  algorand_betanet = 'algorand_betanet',\n  /** Algorand Testnet */\n  algorand_testnet = 'algorand_testnet'\n}\n\n/** Algorand smart contract */\nexport type AlgorandSmartContract = {\n  __typename?: 'AlgorandSmartContract';\n  /** Smart Contract Address */\n  address: Address;\n  /** Smart Contract byte code */\n  bytecode?: Maybe<Scalars['String']>;\n  /** Smart Contract Deassembled source code */\n  source?: Maybe<Scalars['String']>;\n};\n\nexport type AlgorandSmartContractCallFilter = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txType?: InputMaybe<TxTypeSelector>;\n};\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCalls = {\n  __typename?: 'AlgorandSmartContractCalls';\n  any?: Maybe<Scalars['String']>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Fee used in transaction call */\n  fee?: Maybe<Scalars['Float']>;\n  firstRound?: Maybe<Scalars['Int']>;\n  genesisHash64?: Maybe<Scalars['String']>;\n  genesisId?: Maybe<Scalars['String']>;\n  lastRound?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  note?: Maybe<Scalars['String']>;\n  poolerror?: Maybe<Scalars['String']>;\n  /** Smart contract being called */\n  smartContract?: Maybe<AlgorandSmartContract>;\n  /** Transaction where call happened */\n  transaction?: Maybe<TransactionHashIndex>;\n  /** Transaction sender */\n  txSender?: Maybe<Address>;\n  /** Transaction type in which the transfer happened */\n  txType?: Maybe<AlgorandTxType>;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallsanyArgs = {\n  of: AlgorandCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallscountArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txType?: InputMaybe<TxTypeSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallscountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txType?: InputMaybe<TxTypeSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallsfeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txType?: InputMaybe<TxTypeSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallsmaximumArgs = {\n  get?: InputMaybe<AlgorandCallsMeasureable>;\n  of: AlgorandCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallsminimumArgs = {\n  get?: InputMaybe<AlgorandCallsMeasureable>;\n  of: AlgorandCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallssmartContractArgs = {\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallstransactionArgs = {\n  txFrom?: InputMaybe<Array<AddressSelector>>;\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallstxSenderArgs = {\n  txSender?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Smart Contract Calls */\nexport type AlgorandSmartContractCallstxTypeArgs = {\n  txType?: InputMaybe<Array<AlgorandTxType>>;\n};\n\nexport type AlgorandTransactionFilter = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txSubtype?: InputMaybe<TxSubtypeSelector>;\n  txType?: InputMaybe<TxTypeSelector>;\n};\n\n/** Algorand transaction with attributes */\nexport type AlgorandTransactionWithAttributes = {\n  __typename?: 'AlgorandTransactionWithAttributes';\n  /** Block of the Output Transaction for this input */\n  block?: Maybe<Scalars['Int']>;\n  /** Transaction fee */\n  fee?: Maybe<Scalars['Float']>;\n  firstRound?: Maybe<Scalars['Int']>;\n  /** Transaction rewards ( from )  */\n  fromrewards?: Maybe<Scalars['Float']>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0-based */\n  index: Scalars['String'];\n  lastRound?: Maybe<Scalars['Int']>;\n  lease?: Maybe<Scalars['String']>;\n  note?: Maybe<Scalars['String']>;\n  poolerror?: Maybe<Scalars['String']>;\n  /** Transfer transaction sender */\n  sender?: Maybe<Address>;\n  /** Transaction sub type */\n  subtype?: Maybe<AlgorandTxSubType>;\n  /** Transaction type in which the transfer happened */\n  type?: Maybe<AlgorandTxType>;\n};\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactions = {\n  __typename?: 'AlgorandTransactions';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Asset related to transaction */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  fee?: Maybe<Scalars['Float']>;\n  firstRound?: Maybe<Scalars['Int']>;\n  genesisHash?: Maybe<Scalars['String']>;\n  genesisId?: Maybe<Scalars['String']>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0 based */\n  index?: Maybe<Scalars['Int']>;\n  lastRound?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  note?: Maybe<Scalars['String']>;\n  poolerror?: Maybe<Scalars['String']>;\n  /** Transaction sender */\n  sender?: Maybe<Address>;\n  /** Transaction sub type */\n  subtype?: Maybe<AlgorandTxSubType>;\n  /** Transaction type */\n  type?: Maybe<AlgorandTxType>;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionsanyArgs = {\n  of: AlgorandTransactionsMeasureable;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionscountArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txSubtype?: InputMaybe<TxSubtypeSelector>;\n  txType?: InputMaybe<TxTypeSelector>;\n  uniq?: InputMaybe<AlgorandTransactionsUniq>;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionscountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txSubtype?: InputMaybe<TxSubtypeSelector>;\n  txType?: InputMaybe<TxTypeSelector>;\n  uniq?: InputMaybe<AlgorandTransactionsUniq>;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionscurrencyArgs = {\n  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionsfeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCurrency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txSubtype?: InputMaybe<TxSubtypeSelector>;\n  txType?: InputMaybe<TxTypeSelector>;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionshashArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionsindexArgs = {\n  txIndex?: InputMaybe<Array<TxIndexSelector>>;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionsmaximumArgs = {\n  get?: InputMaybe<AlgorandTransactionsMeasureable>;\n  of: AlgorandTransactionsMeasureable;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionsminimumArgs = {\n  get?: InputMaybe<AlgorandTransactionsMeasureable>;\n  of: AlgorandTransactionsMeasureable;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionssenderArgs = {\n  txSender?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionssubtypeArgs = {\n  txType?: InputMaybe<TxSubtypeSelector>;\n};\n\n\n/** Transactions in Algorand blockchain */\nexport type AlgorandTransactionstypeArgs = {\n  txType?: InputMaybe<TxTypeSelector>;\n};\n\nexport enum AlgorandTransactionsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Fee value */\n  fee = 'fee',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction Sender */\n  tx_sender = 'tx_sender'\n}\n\nexport enum AlgorandTransactionsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique currencies */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique TX senders count */\n  senders = 'senders'\n}\n\nexport type AlgorandTransferFilter = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<Array<AddressSelector>>;\n  sender?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transferType?: InputMaybe<AlgorandTransferTypeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txType?: InputMaybe<TxTypeSelector>;\n};\n\nexport enum AlgorandTransferType {\n  /** Close */\n  close = 'close',\n  /** Create Asset */\n  create = 'create',\n  /** Asset Freeze */\n  freeze = 'freeze',\n  /** Genesis Block */\n  genesis = 'genesis',\n  /** Reward */\n  reward = 'reward',\n  /** Send */\n  send = 'send',\n  /** Asset Unfreeze */\n  unfreeze = 'unfreeze'\n}\n\n/** Select transfers by type */\nexport type AlgorandTransferTypeSelector = {\n  /** Transfer Type in the list */\n  in?: InputMaybe<Array<AlgorandTransferType>>;\n  /** Transfer Type is */\n  is?: InputMaybe<AlgorandTransferType>;\n  /** Transfer Type not */\n  not?: InputMaybe<AlgorandTransferType>;\n  /** Transfer Type not in the list */\n  notIn?: InputMaybe<Array<AlgorandTransferType>>;\n};\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransfers = {\n  __typename?: 'AlgorandTransfers';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  firstRound?: Maybe<Scalars['Int']>;\n  lastRound?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  memo?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transfer receiver */\n  receiver?: Maybe<Address>;\n  /** Transfer sender */\n  sender?: Maybe<Address>;\n  /** Transaction where transfer happened */\n  transaction?: Maybe<AlgorandTransactionWithAttributes>;\n  /** Transfer Type */\n  transferType?: Maybe<AlgorandTransferType>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransfersamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  receiver?: InputMaybe<Array<AddressSelector>>;\n  sender?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transferType?: InputMaybe<AlgorandTransferTypeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txType?: InputMaybe<TxTypeSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransfersanyArgs = {\n  of: AlgorandTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransfersblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransferscountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<Array<AddressSelector>>;\n  sender?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transferType?: InputMaybe<AlgorandTransferTypeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txType?: InputMaybe<TxTypeSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransferscountBigIntArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<Array<AddressSelector>>;\n  sender?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transferType?: InputMaybe<AlgorandTransferTypeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<AddressSelector>>;\n  txType?: InputMaybe<TxTypeSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransferscurrencyArgs = {\n  currency?: InputMaybe<Array<AlgorandCurrencySelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransfersmaximumArgs = {\n  get?: InputMaybe<AlgorandTransfersMeasureable>;\n  of: AlgorandTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransfersminimumArgs = {\n  get?: InputMaybe<AlgorandTransfersMeasureable>;\n  of: AlgorandTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransfersreceiverArgs = {\n  receiver?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransferssenderArgs = {\n  sender?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransferstransactionArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type AlgorandTransferstransferTypeArgs = {\n  transferType?: InputMaybe<Array<AlgorandTransferType>>;\n};\n\nexport enum AlgorandTransfersMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Currency Asset ID */\n  asset_id = 'asset_id',\n  /** Block */\n  block = 'block',\n  /** Currency symbol */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** Receiver */\n  receiver = 'receiver',\n  /** Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transfer type */\n  transfer_type = 'transfer_type',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** TX Sender */\n  tx_sender = 'tx_sender',\n  /** Transaction type */\n  tx_type = 'tx_type'\n}\n\nexport enum AlgorandTxSubType {\n  /** Close */\n  close = 'close',\n  /** Asset Configuration */\n  configure = 'configure',\n  /** Create */\n  create = 'create',\n  /** Asset Freeze */\n  freeze = 'freeze',\n  /** Key Reg */\n  keyreg = 'keyreg',\n  /** None */\n  none = 'none',\n  /** Send */\n  send = 'send',\n  /** Asset Unfreeze */\n  unfreeze = 'unfreeze'\n}\n\nexport enum AlgorandTxType {\n  /** Asset Configuration */\n  acfg = 'acfg',\n  /** Asset Freeze or Unfreeze */\n  afrz = 'afrz',\n  /** Application Call */\n  appl = 'appl',\n  /** Asset Transfer */\n  axfer = 'axfer',\n  /** Genesis Block */\n  genesis = 'genesis',\n  /** Key Reg */\n  keyreg = 'keyreg',\n  /** Pay */\n  pay = 'pay'\n}\n\nexport enum AmountAggregateFunction {\n  /** Any value */\n  any = 'any',\n  /** Last value */\n  anyLast = 'anyLast',\n  /** Average */\n  average = 'average',\n  /** Maximum */\n  maximum = 'maximum',\n  /** Median */\n  median = 'median',\n  /** Minimum */\n  minimum = 'minimum',\n  /** Sum (total) */\n  sum = 'sum',\n  /** Unique estimate fast */\n  unique = 'unique',\n  /** Unique exact */\n  uniqueExact = 'uniqueExact'\n}\n\n/** Select by amount */\nexport type AmountSelector = {\n  /** Amount in range */\n  between?: InputMaybe<Array<Scalars['Float']>>;\n  /** Amount greater than */\n  gt?: InputMaybe<Scalars['Float']>;\n  /** Amount greater or equal than */\n  gteq?: InputMaybe<Scalars['Float']>;\n  /** Amount in the list */\n  in?: InputMaybe<Array<Scalars['Float']>>;\n  /** Amount is */\n  is?: InputMaybe<Scalars['Float']>;\n  /** Amount less than */\n  lt?: InputMaybe<Scalars['Float']>;\n  /** Amount less or equal than */\n  lteq?: InputMaybe<Scalars['Float']>;\n  /** Amount not */\n  not?: InputMaybe<Scalars['Float']>;\n  /** Amount not in the list */\n  notIn?: InputMaybe<Array<Scalars['Float']>>;\n};\n\n/** Selector of index of argument in call */\nexport type ArgumentIndexSelector = {\n  /** Tx index in the list */\n  in?: InputMaybe<Array<Scalars['Int']>>;\n  /** Tx index is */\n  is?: InputMaybe<Scalars['Int']>;\n  /** Tx index not */\n  not?: InputMaybe<Scalars['Int']>;\n  /** Tx index not in the list */\n  notIn?: InputMaybe<Array<Scalars['Int']>>;\n};\n\n/** Argument of Smart contract method or event */\nexport type ArgumentName = {\n  __typename?: 'ArgumentName';\n  /** Name */\n  name: Scalars['String'];\n  /** Type */\n  type: Scalars['String'];\n};\n\n/** Argument name and value of smart contract call or event */\nexport type ArgumentNameValue = {\n  __typename?: 'ArgumentNameValue';\n  /** Argument name */\n  argument: Scalars['String'];\n  /** Argument data type */\n  argumentType: Scalars['String'];\n  /** Sequential index of value in array ( multi-dimensional) */\n  index: Scalars['String'];\n  /** Value as String */\n  value: Scalars['String'];\n};\n\n/** Selector of argument for smart contract method or event */\nexport type ArgumentSelector = {\n  /** Argument in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Argument is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Argument not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Argument not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Selector of argument type for smart contract method or event */\nexport type ArgumentTypeSelector = {\n  /** Argument type in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Argument type is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Argument type not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Argument type not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Argument value of smart contract call or event */\nexport type ArgumentValue = {\n  __typename?: 'ArgumentValue';\n  /** Value as Address */\n  address?: Maybe<EthereumAddressInfo>;\n  /** Value as String */\n  value: Scalars['String'];\n};\n\n/** Selector of value of argument for smart contract method or event */\nexport type ArgumentValueSelector = {\n  /** Value in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Value is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Value not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Value not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\nexport enum BaseCurrencyEnum {\n  /** Bitcoin */\n  BTC = 'BTC',\n  /** Ethereum */\n  ETH = 'ETH',\n  /** Dollar */\n  USD = 'USD',\n  /** Tether USDT */\n  USDT = 'USDT'\n}\n\n/** Select by ID with BigInt datatype */\nexport type BigIntIdSelector = {\n  /** ID in range */\n  between?: InputMaybe<Array<Scalars['BigInt']>>;\n  /** ID greater than */\n  gt?: InputMaybe<Scalars['BigInt']>;\n  /** ID greater or equal than */\n  gteq?: InputMaybe<Scalars['BigInt']>;\n  /** ID in the list */\n  in?: InputMaybe<Array<Scalars['BigInt']>>;\n  /** ID is */\n  is?: InputMaybe<Scalars['BigInt']>;\n  /** ID less than */\n  lt?: InputMaybe<Scalars['BigInt']>;\n  /** ID less or equal than */\n  lteq?: InputMaybe<Scalars['BigInt']>;\n  /** ID not */\n  not?: InputMaybe<Scalars['BigInt']>;\n  /** ID not in the list */\n  notIn?: InputMaybe<Array<Scalars['BigInt']>>;\n};\n\n/** Binance DEX */\nexport type Binance = {\n  __typename?: 'Binance';\n  /** Binance DEX Network Blocks */\n  blocks?: Maybe<Array<BinanceBlock>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<BinanceCoinpath>>;\n  /** Binance DEX Network Exchange Orders */\n  orders?: Maybe<Array<BinanceOrders>>;\n  /** Binance DEX Network Trades between currencies */\n  trades?: Maybe<Array<BinanceTrades>>;\n  /** Binance DEX Network Transactions */\n  transactions?: Maybe<Array<BinanceTransactions>>;\n  /** Binance DEX Network Currency Transfers */\n  transfers?: Maybe<Array<BinanceTransfers>>;\n};\n\n\n/** Binance DEX */\nexport type BinanceblocksArgs = {\n  any?: InputMaybe<Array<BinanceBlockFilter>>;\n  blockId?: InputMaybe<StringIdSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  validatorFeeAddr?: InputMaybe<BinanceAddressSelector>;\n  validatorMoniker?: InputMaybe<StringIdSelector>;\n  validatorOperahraddress?: InputMaybe<BinanceAddressSelector>;\n  validatorOperatorAddress?: InputMaybe<BinanceAddressSelector>;\n};\n\n\n/** Binance DEX */\nexport type BinancecoinpathArgs = {\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<BinanceAddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CoinpathOptions>;\n  receiver?: InputMaybe<BinanceAddressSelector>;\n  sender?: InputMaybe<BinanceAddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Binance DEX */\nexport type BinanceordersArgs = {\n  any?: InputMaybe<Array<BinanceOrderFilter>>;\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;\n  orderSide?: InputMaybe<Array<OrderSideSelector>>;\n  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;\n  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;\n  orderType?: InputMaybe<Array<OrderTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Binance DEX */\nexport type BinancetradesArgs = {\n  any?: InputMaybe<Array<BinanceTradeFilter>>;\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  buyer?: InputMaybe<Array<BinanceAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  seller?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Binance DEX */\nexport type BinancetransactionsArgs = {\n  any?: InputMaybe<Array<BinanceTransactionFilter>>;\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  deposit?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  proposalId?: InputMaybe<StringIdSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCode?: InputMaybe<IntIdSelector>;\n  transactionSource?: InputMaybe<IntIdSelector>;\n  transactionType?: InputMaybe<BinanceTransactionTypeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Binance DEX */\nexport type BinancetransfersArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<BinanceTransferFilter>>;\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;\n  receiver?: InputMaybe<Array<BinanceAddressSelector>>;\n  sender?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n/** Binance Address should start with bnb and contain 42 chars. */\nexport type BinanceAddressSelector = {\n  /** In the list of Addresses */\n  in?: InputMaybe<Scalars['String']>;\n  /** Equal to Address */\n  is?: InputMaybe<Scalars['String']>;\n  /** Not Equal to Address */\n  not?: InputMaybe<Scalars['String']>;\n  /** Not in the list of Addresses */\n  notIn?: InputMaybe<Scalars['String']>;\n};\n\n/** Block */\nexport type BinanceBlock = {\n  __typename?: 'BinanceBlock';\n  any?: Maybe<Scalars['String']>;\n  /** Block ID */\n  blockId?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n  /** Validator consensus pubkey */\n  validatorConsensusPubkey?: Maybe<Scalars['String']>;\n  /** Validator fee address */\n  validatorFeeAddr?: Maybe<Address>;\n  /** Validator moniker */\n  validatorMoniker?: Maybe<Scalars['String']>;\n  /** Validator operator HR address */\n  validatorOperaHrAddress?: Maybe<Address>;\n  /** Validator operator address */\n  validatorOperatorAddress?: Maybe<Address>;\n};\n\n\n/** Block */\nexport type BinanceBlockanyArgs = {\n  of: BinanceBlocksMeasureable;\n};\n\n\n/** Block */\nexport type BinanceBlockblockIdArgs = {\n  blockId?: InputMaybe<StringIdSelector>;\n};\n\n\n/** Block */\nexport type BinanceBlockcountArgs = {\n  blockId?: InputMaybe<StringIdSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<BinanceBlockUniq>;\n  validatorFeeAddr?: InputMaybe<BinanceAddressSelector>;\n  validatorMoniker?: InputMaybe<StringIdSelector>;\n  validatorOperahraddress?: InputMaybe<BinanceAddressSelector>;\n  validatorOperatorAddress?: InputMaybe<BinanceAddressSelector>;\n};\n\n\n/** Block */\nexport type BinanceBlockcountBigIntArgs = {\n  blockId?: InputMaybe<StringIdSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<BinanceBlockUniq>;\n  validatorFeeAddr?: InputMaybe<BinanceAddressSelector>;\n  validatorMoniker?: InputMaybe<StringIdSelector>;\n  validatorOperahraddress?: InputMaybe<BinanceAddressSelector>;\n  validatorOperatorAddress?: InputMaybe<BinanceAddressSelector>;\n};\n\n\n/** Block */\nexport type BinanceBlockheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Block */\nexport type BinanceBlockmaximumArgs = {\n  get?: InputMaybe<BinanceBlocksMeasureable>;\n  of: BinanceBlocksMeasureable;\n};\n\n\n/** Block */\nexport type BinanceBlockminimumArgs = {\n  get?: InputMaybe<BinanceBlocksMeasureable>;\n  of: BinanceBlocksMeasureable;\n};\n\n\n/** Block */\nexport type BinanceBlocktimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type BinanceBlockvalidatorConsensusPubkeyArgs = {\n  validatorConsensusPubkey?: InputMaybe<StringIdSelector>;\n};\n\n\n/** Block */\nexport type BinanceBlockvalidatorFeeAddrArgs = {\n  validatorFeeAddr?: InputMaybe<BinanceAddressSelector>;\n};\n\n\n/** Block */\nexport type BinanceBlockvalidatorMonikerArgs = {\n  validatorMoniker?: InputMaybe<StringIdSelector>;\n};\n\n\n/** Block */\nexport type BinanceBlockvalidatorOperaHrAddressArgs = {\n  validatorOperaHrAddress?: InputMaybe<BinanceAddressSelector>;\n};\n\n\n/** Block */\nexport type BinanceBlockvalidatorOperatorAddressArgs = {\n  validatorOperatorAddress?: InputMaybe<BinanceAddressSelector>;\n};\n\nexport type BinanceBlockFilter = {\n  blockId?: InputMaybe<StringIdSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  validatorFeeAddr?: InputMaybe<BinanceAddressSelector>;\n  validatorMoniker?: InputMaybe<StringIdSelector>;\n  validatorOperahraddress?: InputMaybe<BinanceAddressSelector>;\n  validatorOperatorAddress?: InputMaybe<BinanceAddressSelector>;\n};\n\nexport enum BinanceBlockUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Validator fee addresses */\n  validator_fee_addresses = 'validator_fee_addresses',\n  /** Validator operators */\n  validator_operator_addresses = 'validator_operator_addresses'\n}\n\nexport enum BinanceBlocksMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Validator moniker */\n  validator_moniker = 'validator_moniker'\n}\n\n/** Coinpath */\nexport type BinanceCoinpath = {\n  __typename?: 'BinanceCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<Address>;\n  /** Sender address */\n  sender?: Maybe<Address>;\n  /** Transaction of transfer happened */\n  transaction?: Maybe<TransactionHashValue>;\n};\n\n\n/** Coinpath */\nexport type BinanceCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Coinpath */\nexport type BinanceCoinpathanyArgs = {\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type BinanceCoinpathmaximumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type BinanceCoinpathminimumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n/**\n * Binance token selector by tokenId.\n *     Native binance token has BNB symbol.\n *     Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'\n */\nexport type BinanceCurrencySelector = {\n  /** Currency in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Currency is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Currency not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Currency not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\nexport type BinanceOrderFilter = {\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;\n  orderSide?: InputMaybe<Array<OrderSideSelector>>;\n  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;\n  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;\n  orderType?: InputMaybe<Array<OrderTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\nexport enum BinanceOrderSide {\n  /** Buy Side */\n  buy = 'buy',\n  /** Sell Side */\n  sell = 'sell'\n}\n\nexport enum BinanceOrderStatus {\n  /** Ack */\n  Ack = 'Ack',\n  /** Canceled */\n  Canceled = 'Canceled',\n  /** Expired */\n  Expired = 'Expired',\n  /** Failed Blocking */\n  FailedBlocking = 'FailedBlocking',\n  /** Fully Fill */\n  FullyFill = 'FullyFill',\n  /** Ioc Expire */\n  IocExpire = 'IocExpire',\n  /** Ioc No Fill */\n  IocNoFill = 'IocNoFill',\n  /** Partial Fill */\n  PartialFill = 'PartialFill'\n}\n\nexport enum BinanceOrderTimeInForce {\n  /** Good Till Expiry */\n  GTE = 'GTE',\n  /** Immediate Or Cancel */\n  IOC = 'IOC'\n}\n\nexport enum BinanceOrderType {\n  /** Limit Order */\n  LimitOrder = 'LimitOrder'\n}\n\n/** Binance DEX Order */\nexport type BinanceOrders = {\n  __typename?: 'BinanceOrders';\n  any?: Maybe<Scalars['String']>;\n  baseAmount?: Maybe<Scalars['Float']>;\n  baseCurrency?: Maybe<Currency>;\n  /** Block where order transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Order ID */\n  orderId?: Maybe<Scalars['String']>;\n  /** Order owner address */\n  orderOwner?: Maybe<Address>;\n  /** Order Side */\n  orderSide?: Maybe<BinanceOrderSide>;\n  /** Order Status */\n  orderStatus?: Maybe<BinanceOrderStatus>;\n  /** Order Time In Force */\n  orderTimeInForce?: Maybe<BinanceOrderTimeInForce>;\n  /** Order Type */\n  orderType?: Maybe<BinanceOrderType>;\n  price?: Maybe<Scalars['Float']>;\n  quoteAmount?: Maybe<Scalars['Float']>;\n  quoteCurrency?: Maybe<Currency>;\n  /** Transaction where order created */\n  transaction?: Maybe<TransactionHash>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersanyArgs = {\n  of: BinanceOrdersMeasureable;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersbaseAmountArgs = {\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;\n  orderSide?: InputMaybe<Array<OrderSideSelector>>;\n  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;\n  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;\n  orderType?: InputMaybe<Array<OrderTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersbaseCurrencyArgs = {\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrderscountArgs = {\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;\n  orderSide?: InputMaybe<Array<OrderSideSelector>>;\n  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;\n  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;\n  orderType?: InputMaybe<Array<OrderTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<BinanceOrdersUniq>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrderscountBigIntArgs = {\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;\n  orderSide?: InputMaybe<Array<OrderSideSelector>>;\n  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;\n  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;\n  orderType?: InputMaybe<Array<OrderTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<BinanceOrdersUniq>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersmaximumArgs = {\n  get?: InputMaybe<BinanceOrdersMeasureable>;\n  of: BinanceOrdersMeasureable;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersminimumArgs = {\n  get?: InputMaybe<BinanceOrdersMeasureable>;\n  of: BinanceOrdersMeasureable;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersorderIdArgs = {\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersorderOwnerArgs = {\n  owner?: InputMaybe<Array<BinanceAddressSelector>>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersorderSideArgs = {\n  orderSide?: InputMaybe<Array<OrderSideSelector>>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersorderStatusArgs = {\n  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersorderTimeInForceArgs = {\n  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersorderTypeArgs = {\n  orderType?: InputMaybe<Array<OrderTypeSelector>>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersquoteAmountArgs = {\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  orderOwner?: InputMaybe<Array<BinanceAddressSelector>>;\n  orderSide?: InputMaybe<Array<OrderSideSelector>>;\n  orderStatus?: InputMaybe<Array<OrderStatusSelector>>;\n  orderTimeInForce?: InputMaybe<Array<OrderTimeInForceSelector>>;\n  orderType?: InputMaybe<Array<OrderTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrdersquoteCurrencyArgs = {\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n};\n\n\n/** Binance DEX Order */\nexport type BinanceOrderstransactionArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\nexport enum BinanceOrdersMeasureable {\n  /** Base Amount */\n  base_amount = 'base_amount',\n  /** Base currency */\n  base_currency = 'base_currency',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Order ID */\n  order_id = 'order_id',\n  /** Order owner */\n  order_owner = 'order_owner',\n  /** Order side */\n  order_side = 'order_side',\n  /** Order status */\n  order_status = 'order_status',\n  /** Price */\n  price = 'price',\n  /** Quote Amount */\n  quote_amount = 'quote_amount',\n  /** Quote currency */\n  quote_currency = 'quote_currency',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\nexport enum BinanceOrdersUniq {\n  /** Unique base currencies */\n  base_currencies = 'base_currencies',\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique order ID count */\n  orders = 'orders',\n  /** Unique order owners */\n  owners = 'owners',\n  /** Unique quote currencies */\n  quote_currencies = 'quote_currencies',\n  /** Unique Transactions */\n  txs = 'txs'\n}\n\nexport type BinanceTradeFilter = {\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  buyer?: InputMaybe<Array<BinanceAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  seller?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n/** Binance DEX Trades */\nexport type BinanceTrades = {\n  __typename?: 'BinanceTrades';\n  any?: Maybe<Scalars['String']>;\n  baseAmount?: Maybe<Scalars['Float']>;\n  baseCurrency?: Maybe<Currency>;\n  /** Block where trade transaction is included */\n  block?: Maybe<Block>;\n  /** Buy Order ID */\n  buyOrderId?: Maybe<Scalars['String']>;\n  /** Trade buyer address */\n  buyer?: Maybe<Address>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  price?: Maybe<Scalars['Float']>;\n  quoteAmount?: Maybe<Scalars['Float']>;\n  quoteCurrency?: Maybe<Currency>;\n  /** Sell Order ID */\n  sellOrderId?: Maybe<Scalars['String']>;\n  /** Trade seller address */\n  seller?: Maybe<Address>;\n  /** Trade ID */\n  tradeId?: Maybe<Scalars['String']>;\n  /** Transaction where trade happened */\n  transaction?: Maybe<TransactionHashIndex>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradesanyArgs = {\n  of: BinanceTradesMeasureable;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradesbaseAmountArgs = {\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  buyer?: InputMaybe<Array<BinanceAddressSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  seller?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradesbaseCurrencyArgs = {\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradesblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradesbuyOrderIdArgs = {\n  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradesbuyerArgs = {\n  buyer?: InputMaybe<Array<BinanceAddressSelector>>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradescountArgs = {\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  buyer?: InputMaybe<Array<BinanceAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  seller?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<BinanceTradesUniq>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradescountBigIntArgs = {\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  buyer?: InputMaybe<Array<BinanceAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  seller?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<BinanceTradesUniq>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradesmaximumArgs = {\n  get?: InputMaybe<BinanceTradesMeasureable>;\n  of: BinanceTradesMeasureable;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradesminimumArgs = {\n  get?: InputMaybe<BinanceTradesMeasureable>;\n  of: BinanceTradesMeasureable;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradesquoteAmountArgs = {\n  baseAmount?: InputMaybe<Array<AmountSelector>>;\n  baseCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  buyOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  buyer?: InputMaybe<Array<BinanceAddressSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  quoteAmount?: InputMaybe<Array<AmountSelector>>;\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;\n  seller?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradesquoteCurrencyArgs = {\n  quoteCurrency?: InputMaybe<Array<BinanceCurrencySelector>>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradessellOrderIdArgs = {\n  sellOrderId?: InputMaybe<Array<OrderIdSelector>>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradessellerArgs = {\n  seller?: InputMaybe<Array<BinanceAddressSelector>>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradestradeIdArgs = {\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n};\n\n\n/** Binance DEX Trades */\nexport type BinanceTradestransactionArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\nexport enum BinanceTradesMeasureable {\n  /** Base Amount */\n  base_amount = 'base_amount',\n  /** Base currency */\n  base_currency = 'base_currency',\n  /** Block */\n  block = 'block',\n  /** Buy Order ID */\n  buy_order_id = 'buy_order_id',\n  /** Buyer */\n  buyer = 'buyer',\n  /** Date */\n  date = 'date',\n  /** Price */\n  price = 'price',\n  /** Quote Amount */\n  quote_amount = 'quote_amount',\n  /** Quote currency */\n  quote_currency = 'quote_currency',\n  /** Sell Order ID */\n  sell_order_id = 'sell_order_id',\n  /** Seller */\n  seller = 'seller',\n  /** Time */\n  time = 'time',\n  /** Trade ID */\n  trade_id = 'trade_id',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\nexport enum BinanceTradesUniq {\n  /** Unique base currencies */\n  base_currencies = 'base_currencies',\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Buy Orders */\n  buy_orders = 'buy_orders',\n  /** Unique buyers count */\n  buyers = 'buyers',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique quote currencies */\n  quote_currencies = 'quote_currencies',\n  /** Sell Orders */\n  sell_orders = 'sell_orders',\n  /** Unique sellers count */\n  sellers = 'sellers',\n  /** Trades */\n  trades = 'trades',\n  /** Unique Transactions */\n  txs = 'txs'\n}\n\nexport type BinanceTransactionFilter = {\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  deposit?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  proposalId?: InputMaybe<StringIdSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCode?: InputMaybe<IntIdSelector>;\n  transactionSource?: InputMaybe<IntIdSelector>;\n  transactionType?: InputMaybe<BinanceTransactionTypeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\nexport enum BinanceTransactionType {\n  /** Bind */\n  BIND = 'BIND',\n  /** Submit evidence */\n  BSC_SUBMIT_EVIDENCE = 'BSC_SUBMIT_EVIDENCE',\n  /** Burn */\n  BURN = 'BURN',\n  /** Cancel Order */\n  CANCEL_ORDER = 'CANCEL_ORDER',\n  /** Cross chain claim */\n  CLAIM = 'CLAIM',\n  /** Hash Timer Locked Claim */\n  CLAIM_HTL = 'CLAIM_HTL',\n  /** Create sidechain validator */\n  CREATE_SIDECHAIN_VALIDATOR = 'CREATE_SIDECHAIN_VALIDATOR',\n  /** Deposit */\n  DEPOSIT = 'DEPOSIT',\n  /** Hash Timer Locked Deposit */\n  DEPOSIT_HTL = 'DEPOSIT_HTL',\n  /** Edit sidechain validator */\n  EDIT_SIDECHAIN_VALIDATOR = 'EDIT_SIDECHAIN_VALIDATOR',\n  /** Freeze Token */\n  FREEZE_TOKEN = 'FREEZE_TOKEN',\n  /** Hash Timer Locked Transfer */\n  HTL_TRANSFER = 'HTL_TRANSFER',\n  /** Issue */\n  ISSUE = 'ISSUE',\n  /** Listing */\n  LISTING = 'LISTING',\n  /** Mini Token Issue */\n  MINI_TOKEN_ISSUE = 'MINI_TOKEN_ISSUE',\n  /** Mini Token Listing */\n  MINI_TOKEN_LIST = 'MINI_TOKEN_LIST',\n  /** Mini Token Set URI */\n  MINI_TOKEN_SET_URI = 'MINI_TOKEN_SET_URI',\n  /** Mint */\n  MINT = 'MINT',\n  /** New Order */\n  NEW_ORDER = 'NEW_ORDER',\n  /** Hash Timer Locked  Refund */\n  REFUND_HTL = 'REFUND_HTL',\n  /** Delegate for sidechain */\n  SIDECHAIN_DELEGATE = 'SIDECHAIN_DELEGATE',\n  /** ReDelegate for sidechain */\n  SIDECHAIN_REDELEGATE = 'SIDECHAIN_REDELEGATE',\n  /** Unbond from sidechain */\n  SIDECHAIN_UNBOND = 'SIDECHAIN_UNBOND',\n  /** Unjail from sidechain */\n  SIDECHAIN_UNJAIL = 'SIDECHAIN_UNJAIL',\n  /** Side chain deposit */\n  SIDE_DEPOSIT = 'SIDE_DEPOSIT',\n  /** Side chain submit poroposal */\n  SIDE_SUBMIT_PROPOSAL = 'SIDE_SUBMIT_PROPOSAL',\n  /** Side chain vote */\n  SIDE_VOTE = 'SIDE_VOTE',\n  /** Submit Proposal */\n  SUBMIT_PROPOSAL = 'SUBMIT_PROPOSAL',\n  /** Set Account Flag */\n  SetAccountFlag = 'SetAccountFlag',\n  /** Tiny Token Issue */\n  TINY_TOKEN_ISSUE = 'TINY_TOKEN_ISSUE',\n  /** Tiny Token Listing */\n  TINY_TOKEN_LIST = 'TINY_TOKEN_LIST',\n  /** Tiny Token Set URI */\n  TINY_TOKEN_SET_URI = 'TINY_TOKEN_SET_URI',\n  /** Transfer */\n  TRANSFER = 'TRANSFER',\n  /** Cross chain transfer */\n  TRANSFER_OUT = 'TRANSFER_OUT',\n  /** Time Lock */\n  TimeLock = 'TimeLock',\n  /** Time Relock */\n  TimeRelock = 'TimeRelock',\n  /** Time Unlock */\n  TimeUnlock = 'TimeUnlock',\n  /** UnBind */\n  UNBIND = 'UNBIND',\n  /** Unfreeze Token */\n  UNFREEZE_TOKEN = 'UNFREEZE_TOKEN',\n  /** Vote */\n  VOTE = 'VOTE'\n}\n\n/** Select by transaction type */\nexport type BinanceTransactionTypeSelector = {\n  /** Transaction Type in the list */\n  in?: InputMaybe<Array<BinanceTransactionType>>;\n  /** Transaction Type is */\n  is?: InputMaybe<BinanceTransactionType>;\n  /** Transaction Type not */\n  not?: InputMaybe<BinanceTransactionType>;\n  /** Transaction Type not in the list */\n  notIn?: InputMaybe<Array<BinanceTransactionType>>;\n};\n\n/** Transaction */\nexport type BinanceTransactions = {\n  __typename?: 'BinanceTransactions';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency issued in transaction */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Deposit amount in transaction */\n  deposit?: Maybe<Scalars['Float']>;\n  /** Transaction Description */\n  description?: Maybe<Scalars['String']>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** TX index in block, 0 based */\n  index?: Maybe<Scalars['Int']>;\n  /** Transaction Log */\n  log?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Transaction Memo */\n  memo?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Proposal ID */\n  proposalId?: Maybe<Scalars['Int']>;\n  /** Transaction Type */\n  transactionCode?: Maybe<Scalars['Int']>;\n  /** Transaction Source */\n  transactionSource?: Maybe<TransactionSource>;\n  /** Transaction Type */\n  transactionType?: Maybe<BinanceTransactionType>;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionsanyArgs = {\n  of: BinanceTransactionsMeasureable;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionscountArgs = {\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  deposit?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  proposalId?: InputMaybe<StringIdSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCode?: InputMaybe<IntIdSelector>;\n  transactionSource?: InputMaybe<IntIdSelector>;\n  transactionType?: InputMaybe<BinanceTransactionTypeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<BinanceTransactionsUniq>;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionscountBigIntArgs = {\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  deposit?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  proposalId?: InputMaybe<StringIdSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCode?: InputMaybe<IntIdSelector>;\n  transactionSource?: InputMaybe<IntIdSelector>;\n  transactionType?: InputMaybe<BinanceTransactionTypeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<BinanceTransactionsUniq>;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionscurrencyArgs = {\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionsdepositArgs = {\n  deposit?: InputMaybe<Array<AmountSelector>>;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionshashArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionsmaximumArgs = {\n  get?: InputMaybe<BinanceTransactionsMeasureable>;\n  of: BinanceTransactionsMeasureable;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionsminimumArgs = {\n  get?: InputMaybe<BinanceTransactionsMeasureable>;\n  of: BinanceTransactionsMeasureable;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionsproposalIdArgs = {\n  proposalId?: InputMaybe<Array<IntIdSelector>>;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionstransactionCodeArgs = {\n  transactionCode?: InputMaybe<IntIdSelector>;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionstransactionSourceArgs = {\n  transactionSource?: InputMaybe<IntIdSelector>;\n};\n\n\n/** Transaction */\nexport type BinanceTransactionstransactionTypeArgs = {\n  transactionType?: InputMaybe<Array<BinanceTransactionTypeSelector>>;\n};\n\nexport enum BinanceTransactionsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Currency */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Transaction Code */\n  transaction_code = 'transaction_code',\n  /** Transaction Memo */\n  transaction_memo = 'transaction_memo',\n  /** Transaction Source Code */\n  transaction_source_code = 'transaction_source_code',\n  /** Transaction Source Name */\n  transaction_source_name = 'transaction_source_name',\n  /** Transaction Type */\n  transaction_type = 'transaction_type',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\nexport enum BinanceTransactionsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transaction source count */\n  transaction_sources = 'transaction_sources'\n}\n\nexport type BinanceTransferFilter = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;\n  receiver?: InputMaybe<Array<BinanceAddressSelector>>;\n  sender?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\nexport enum BinanceTransferType {\n  /** Bind */\n  BIND = 'BIND',\n  /** Reward for block */\n  BLOCK_REWARD = 'BLOCK_REWARD',\n  /** Submit evidence */\n  BSC_SUBMIT_EVIDENCE = 'BSC_SUBMIT_EVIDENCE',\n  /** Burning amount */\n  BURN = 'BURN',\n  /** Cross chain claim */\n  CLAIM = 'CLAIM',\n  /** Claiming Hash Timer Locked Transfer */\n  CLAIM_HTL = 'CLAIM_HTL',\n  /** Create sidechain validator */\n  CREATE_SIDECHAIN_VALIDATOR = 'CREATE_SIDECHAIN_VALIDATOR',\n  /** Deposit for Hash Timer Locked Transfer */\n  DEPOSIT_HTL = 'DEPOSIT_HTL',\n  /** Fee for DEX orders */\n  DEX_FEE = 'DEX_FEE',\n  /** Edit sidechain validator */\n  EDIT_SIDECHAIN_VALIDATOR = 'EDIT_SIDECHAIN_VALIDATOR',\n  /** Genesis declaration */\n  GENESIS_DELEGATION = 'GENESIS_DELEGATION',\n  /** Genesis supply declaration */\n  GENESIS_SUPPLY = 'GENESIS_SUPPLY',\n  /** Hash Timer Locked Transfer */\n  HTL_TRANSFER = 'HTL_TRANSFER',\n  /** Issue token */\n  ISSUE = 'ISSUE',\n  /** Mini Token Issue */\n  MINI_TOKEN_ISSUE = 'MINI_TOKEN_ISSUE',\n  /** Mint token */\n  MINT = 'MINT',\n  /** Delegate for sidechain */\n  SIDECHAIN_DELEGATE = 'SIDECHAIN_DELEGATE',\n  /** ReDelegate for sidechain */\n  SIDECHAIN_REDELEGATE = 'SIDECHAIN_REDELEGATE',\n  /** Unbond from sidechain */\n  SIDECHAIN_UNBOND = 'SIDECHAIN_UNBOND',\n  /** Side chain deposit */\n  SIDE_DEPOSIT = 'SIDE_DEPOSIT',\n  /** Side chain submit poroposal */\n  SIDE_SUBMIT_PROPOSAL = 'SIDE_SUBMIT_PROPOSAL',\n  /** Side chain vote */\n  SIDE_VOTE = 'SIDE_VOTE',\n  /** Tiny Token Issue */\n  TINY_TOKEN_ISSUE = 'TINY_TOKEN_ISSUE',\n  /** Trade buy side */\n  TRADE_BUY = 'TRADE_BUY',\n  /** Trade sell side */\n  TRADE_SELL = 'TRADE_SELL',\n  /** Transfer */\n  TRANSFER = 'TRANSFER',\n  /** Cross chain transfer */\n  TRANSFER_OUT = 'TRANSFER_OUT',\n  /** Transaction fee */\n  TX_FEE = 'TX_FEE',\n  /** UnBind */\n  UNBIND = 'UNBIND'\n}\n\n/** Select transfer type(s) */\nexport type BinanceTransferTypeSelector = {\n  /** Transfer type in the list */\n  in?: InputMaybe<Array<BinanceTransferType>>;\n  /** Transfer type is */\n  is?: InputMaybe<BinanceTransferType>;\n  /** Transfer type not */\n  not?: InputMaybe<BinanceTransferType>;\n  /** Transfer type not in the list */\n  notIn?: InputMaybe<Array<BinanceTransferType>>;\n};\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransfers = {\n  __typename?: 'BinanceTransfers';\n  /** Transfer amount */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  /** Transfer count */\n  count?: Maybe<Scalars['Int']>;\n  /** Transfer count */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Order Id of trade where transfer happened */\n  orderId?: Maybe<Scalars['String']>;\n  /** Index of the output for the transfer, 0-based */\n  outputIndex?: Maybe<Scalars['Int']>;\n  /** Transfer receiver */\n  receiver?: Maybe<Address>;\n  /** Transfer sender */\n  sender?: Maybe<Address>;\n  /** Id of trade where transfer happened */\n  tradeId?: Maybe<Scalars['String']>;\n  /** Transaction where transfer happened */\n  transaction?: Maybe<TransactionHashIndex>;\n  /** Transfer type */\n  transferType?: Maybe<BinanceTransferType>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransfersamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;\n  receiver?: InputMaybe<Array<BinanceAddressSelector>>;\n  sender?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransfersanyArgs = {\n  of: BinanceTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransfersblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransferscountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;\n  receiver?: InputMaybe<Array<BinanceAddressSelector>>;\n  sender?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransferscountBigIntArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;\n  receiver?: InputMaybe<Array<BinanceAddressSelector>>;\n  sender?: InputMaybe<Array<BinanceAddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransferscurrencyArgs = {\n  currency?: InputMaybe<Array<BinanceCurrencySelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransfersmaximumArgs = {\n  get?: InputMaybe<BinanceTransfersMeasureable>;\n  of: BinanceTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransfersminimumArgs = {\n  get?: InputMaybe<BinanceTransfersMeasureable>;\n  of: BinanceTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransfersorderIdArgs = {\n  orderId?: InputMaybe<Array<OrderIdSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransfersoutputIndexArgs = {\n  outputIndex?: InputMaybe<Array<OutputIndexSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransfersreceiverArgs = {\n  receiver?: InputMaybe<Array<BinanceAddressSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransferssenderArgs = {\n  sender?: InputMaybe<Array<BinanceAddressSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransferstradeIdArgs = {\n  tradeId?: InputMaybe<Array<TradeIdSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransferstransactionArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type BinanceTransferstransferTypeArgs = {\n  transferType?: InputMaybe<Array<BinanceTransferTypeSelector>>;\n};\n\nexport enum BinanceTransfersMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Currency symbol */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** Receiver */\n  receiver = 'receiver',\n  /** Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\n/** Bitcoin and other UTXO type blockchains */\nexport type Bitcoin = {\n  __typename?: 'Bitcoin';\n  /** Blockchain Blocks */\n  blocks?: Maybe<Array<BitcoinBlock>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<BitcoinCoinpath>>;\n  /** Blockchain Transaction Inputs */\n  inputs?: Maybe<Array<BitcoinTransactionInput>>;\n  /** Blockchain Transaction OmniTransactions */\n  omniTransactions?: Maybe<Array<BitcoinOmniTransactiosn>>;\n  /** Blockchain Transaction OmniTransfers */\n  omniTransfers?: Maybe<Array<BitcoinOmniTransfers>>;\n  /** Blockchain Transaction Outputs */\n  outputs?: Maybe<Array<BitcoinTransactionOutput>>;\n  /** Blockchain Transactions */\n  transactions?: Maybe<Array<BitcoinTransaction>>;\n};\n\n\n/** Bitcoin and other UTXO type blockchains */\nexport type BitcoinblocksArgs = {\n  any?: InputMaybe<Array<BitcoinBlockFilter>>;\n  blockHash?: InputMaybe<StringIdSelector>;\n  blockSize?: InputMaybe<IntegerSelector>;\n  blockStrippedSize?: InputMaybe<IntegerSelector>;\n  blockVersion?: InputMaybe<IntegerSelector>;\n  blockWeight?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  difficulty?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Bitcoin and other UTXO type blockchains */\nexport type BitcoincoinpathArgs = {\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<AddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<BitcoinCoinpathOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Bitcoin and other UTXO type blockchains */\nexport type BitcoininputsArgs = {\n  any?: InputMaybe<Array<BitcoinInputFilter>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputScriptType?: InputMaybe<BitcoinInputScriptTypeSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Bitcoin and other UTXO type blockchains */\nexport type BitcoinomniTransactionsArgs = {\n  any?: InputMaybe<Array<BitcoinOmniTransactionsFilter>>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  invalidReason?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  type?: InputMaybe<StringSelector>;\n  typeId?: InputMaybe<IntegerSelector>;\n  valid?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Bitcoin and other UTXO type blockchains */\nexport type BitcoinomniTransfersArgs = {\n  any?: InputMaybe<Array<BitcoinOmniTransfersFilter>>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  invalidReason?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  type?: InputMaybe<StringSelector>;\n  typeId?: InputMaybe<IntegerSelector>;\n  valid?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Bitcoin and other UTXO type blockchains */\nexport type BitcoinoutputsArgs = {\n  any?: InputMaybe<Array<BitcoinOutputFilter>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  outputAddress?: InputMaybe<AddressSelector>;\n  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;\n  outputIndex?: InputMaybe<IntegerSelector>;\n  outputScriptType?: InputMaybe<BitcoinOutputScriptTypeSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Bitcoin and other UTXO type blockchains */\nexport type BitcointransactionsArgs = {\n  any?: InputMaybe<Array<BitcoinTransactionFilter>>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  options?: InputMaybe<QueryOptions>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n/** Block */\nexport type BitcoinBlock = {\n  __typename?: 'BitcoinBlock';\n  any?: Maybe<Scalars['String']>;\n  /** Block Hash */\n  blockHash?: Maybe<Scalars['String']>;\n  /** Block size */\n  blockSize?: Maybe<Scalars['Int']>;\n  /** Block stripped size */\n  blockStrippedSize?: Maybe<Scalars['Int']>;\n  /** Block version */\n  blockVersion?: Maybe<Scalars['Int']>;\n  /** Block weight */\n  blockWeight?: Maybe<Scalars['Int']>;\n  /** Block chainwork */\n  chainwork?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Difficulty */\n  difficulty?: Maybe<Scalars['Float']>;\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  maximum?: Maybe<Scalars['String']>;\n  /** Block median timestamp */\n  medianTime?: Maybe<DateTime>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n  /** Transaction count in block */\n  transactionCount?: Maybe<Scalars['Int']>;\n};\n\n\n/** Block */\nexport type BitcoinBlockanyArgs = {\n  of: BitcoinBlocksMeasureable;\n};\n\n\n/** Block */\nexport type BitcoinBlockblockHashArgs = {\n  blockHash?: InputMaybe<StringIdSelector>;\n};\n\n\n/** Block */\nexport type BitcoinBlockblockSizeArgs = {\n  blockSize?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block */\nexport type BitcoinBlockblockStrippedSizeArgs = {\n  blockStrippedSize?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block */\nexport type BitcoinBlockblockVersionArgs = {\n  blockVersion?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block */\nexport type BitcoinBlockblockWeightArgs = {\n  blockWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block */\nexport type BitcoinBlockcountArgs = {\n  blockHash?: InputMaybe<StringIdSelector>;\n  blockSize?: InputMaybe<IntegerSelector>;\n  blockStrippedSize?: InputMaybe<IntegerSelector>;\n  blockVersion?: InputMaybe<IntegerSelector>;\n  blockWeight?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  difficulty?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCount?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinBlockUniq>;\n};\n\n\n/** Block */\nexport type BitcoinBlockcountBigIntArgs = {\n  blockHash?: InputMaybe<StringIdSelector>;\n  blockSize?: InputMaybe<IntegerSelector>;\n  blockStrippedSize?: InputMaybe<IntegerSelector>;\n  blockVersion?: InputMaybe<IntegerSelector>;\n  blockWeight?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  difficulty?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCount?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinBlockUniq>;\n};\n\n\n/** Block */\nexport type BitcoinBlockdifficultyArgs = {\n  difficulty?: InputMaybe<FloatSelector>;\n};\n\n\n/** Block */\nexport type BitcoinBlockheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Block */\nexport type BitcoinBlockmaximumArgs = {\n  get?: InputMaybe<BitcoinBlocksMeasureable>;\n  of: BitcoinBlocksMeasureable;\n};\n\n\n/** Block */\nexport type BitcoinBlockminimumArgs = {\n  get?: InputMaybe<BitcoinBlocksMeasureable>;\n  of: BitcoinBlocksMeasureable;\n};\n\n\n/** Block */\nexport type BitcoinBlocktimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type BitcoinBlocktransactionCountArgs = {\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\nexport type BitcoinBlockFilter = {\n  blockHash?: InputMaybe<StringIdSelector>;\n  blockSize?: InputMaybe<IntegerSelector>;\n  blockStrippedSize?: InputMaybe<IntegerSelector>;\n  blockVersion?: InputMaybe<IntegerSelector>;\n  blockWeight?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  difficulty?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\nexport enum BitcoinBlockUniq {\n  /** Unique date count */\n  dates = 'dates'\n}\n\nexport enum BitcoinBlocksMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Tx Count */\n  transaction_count = 'transaction_count'\n}\n\n/** Coinpath */\nexport type BitcoinCoinpath = {\n  __typename?: 'BitcoinCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<Address>;\n  /** Sender address */\n  sender?: Maybe<Address>;\n  /** Transaction of transfer happened */\n  transaction?: Maybe<BitcoinTransactionHashIndexValues>;\n  /** Attributes of transaction included in Coinpath result */\n  transactions?: Maybe<Array<CoinpathEntry>>;\n};\n\n\n/** Coinpath */\nexport type BitcoinCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Coinpath */\nexport type BitcoinCoinpathanyArgs = {\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type BitcoinCoinpathmaximumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type BitcoinCoinpathminimumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\nexport enum BitcoinCoinpathMethod {\n  /** Tracking money flow by amounts, ignoring coins (default) */\n  moneyflow = 'moneyflow',\n  /** Tracking coins by UTXO transactions */\n  utxo = 'utxo'\n}\n\n/** Limits, Ordering, Constraints, Coinpath Options */\nexport type BitcoinCoinpathOptions = {\n  /** Ordering field(s) for ascending */\n  asc?: InputMaybe<Array<Scalars['String']>>;\n  /** Method to use coinpath */\n  coinpathMethod?: InputMaybe<BitcoinCoinpathMethod>;\n  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */\n  complexityLimit?: InputMaybe<Scalars['Int']>;\n  /** Ordering field(s) for descending */\n  desc?: InputMaybe<Array<Scalars['String']>>;\n  /** Flow direction */\n  direction?: InputMaybe<FlowDirection>;\n  /** Limit number of results */\n  limit?: InputMaybe<Scalars['Int']>;\n  /** Limit number of results by specific field */\n  limitBy?: InputMaybe<LimitByOption>;\n  /** Do not expand addresses having count transactions more than this */\n  maximumAddressTxCount?: InputMaybe<Scalars['Int']>;\n  /** Maximum total transaction count returned */\n  maximumTotalTxCount?: InputMaybe<Scalars['Int']>;\n  /** Do not include transactions below this amount */\n  minimumTxAmount?: InputMaybe<Scalars['Float']>;\n  /** Offset of results, starting from 0 */\n  offset?: InputMaybe<Scalars['Int']>;\n  /** Invalidating cache seed */\n  seed?: InputMaybe<Scalars['Int']>;\n};\n\nexport type BitcoinInputFilter = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputScriptType?: InputMaybe<BitcoinInputScriptTypeSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\nexport enum BitcoinInputScriptType {\n  /** Input Script Coinbase Script */\n  coinbase = 'coinbase',\n  /** Input Script Signature */\n  scriptSig = 'scriptSig',\n  /** Input Script TX Witness Script */\n  txinwitness = 'txinwitness'\n}\n\n/** Selector of input script type */\nexport type BitcoinInputScriptTypeSelector = {\n  /** In the list of Script Type */\n  in?: InputMaybe<Array<BitcoinInputScriptType>>;\n  /** Equal to Script Type */\n  is?: InputMaybe<BitcoinInputScriptType>;\n  /** Not Equal to Script Type */\n  not?: InputMaybe<BitcoinInputScriptType>;\n  /** Not in the list of Script Type */\n  notIn?: InputMaybe<Array<BitcoinInputScriptType>>;\n};\n\nexport enum BitcoinInputUniq {\n  /** Unique addresses count */\n  addresses = 'addresses',\n  /** Unique block count */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transactions count */\n  transactions = 'transactions'\n}\n\nexport enum BitcoinInputsMeasureable {\n  /** Address */\n  address = 'address',\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Input index */\n  input_index = 'input_index',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction index */\n  tx_index = 'tx_index'\n}\n\nexport enum BitcoinNetwork {\n  /** Bitcoin Cash ( BCH ) */\n  bitcash = 'bitcash',\n  /** Bitcoin ( BTC ) */\n  bitcoin = 'bitcoin',\n  /** Bitcoin SV ( BSV ) */\n  bitcoinsv = 'bitcoinsv',\n  /** Dash ( DASH ) */\n  dash = 'dash',\n  /** Dogecoin ( DOGE ) */\n  dogecoin = 'dogecoin',\n  /** Litecoin ( LTC ) */\n  litecoin = 'litecoin',\n  /** ZCash ( ZCASH ) */\n  zcash = 'zcash'\n}\n\nexport type BitcoinOmniTransactionsFilter = {\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  invalidReason?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  type?: InputMaybe<StringSelector>;\n  typeId?: InputMaybe<IntegerSelector>;\n  valid?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\nexport enum BitcoinOmniTransactionsMeasureablse {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Transactions hash */\n  tx_hash = 'tx_hash',\n  /** Transactions index */\n  tx_index = 'tx_index'\n}\n\nexport enum BitcoinOmniTransactionsUniq {\n  /** Unique block count */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transaction sender */\n  tx_sender = 'tx_sender'\n}\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosn = {\n  __typename?: 'BitcoinOmniTransactiosn';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Hash of the block */\n  blockHash: Scalars['String'];\n  /** OmniTransaction s count */\n  count?: Maybe<Scalars['Int']>;\n  /** OmniTransaction s count */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Transactions total fee value */\n  feeValue?: Maybe<Scalars['Float']>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** OmniTransactions index in block, 0-based */\n  index: Scalars['String'];\n  /** Invalid Reason */\n  invalidReason: Scalars['String'];\n  /** Invalid Reason */\n  json: Scalars['String'];\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transaction Sender */\n  txSender: Scalars['String'];\n  /** Type */\n  type: Scalars['String'];\n  /** Type Int */\n  typeInt: Scalars['Int'];\n  /** Version */\n  valid: Scalars['Int'];\n  /** Version */\n  version: Scalars['Int'];\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnanyArgs = {\n  of: BitcoinOmniTransactionsMeasureablse;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnblockHashArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosncountArgs = {\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  invalidReason?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  type?: InputMaybe<StringSelector>;\n  typeId?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinOmniTransactionsUniq>;\n  valid?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosncountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  invalidReason?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  type?: InputMaybe<StringSelector>;\n  typeId?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinOmniTransactionsUniq>;\n  valid?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnfeeValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  invalidReason?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  type?: InputMaybe<StringSelector>;\n  typeId?: InputMaybe<IntegerSelector>;\n  valid?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnhashArgs = {\n  txHash?: InputMaybe<StringIdSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnindexArgs = {\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosninvalidReasonArgs = {\n  invalidReason?: InputMaybe<StringSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnjsonArgs = {\n  json?: InputMaybe<StringSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnmaximumArgs = {\n  get?: InputMaybe<BitcoinOmniTransactionsMeasureablse>;\n  of: BitcoinOmniTransactionsMeasureablse;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnminimumArgs = {\n  get?: InputMaybe<BitcoinOmniTransactionsMeasureablse>;\n  of: BitcoinOmniTransactionsMeasureablse;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosntxSenderArgs = {\n  txSender?: InputMaybe<HashSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosntypeArgs = {\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosntypeIntArgs = {\n  typeInt?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnvalidArgs = {\n  valid?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransactions */\nexport type BitcoinOmniTransactiosnversionArgs = {\n  version?: InputMaybe<IntegerSelector>;\n};\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfers = {\n  __typename?: 'BitcoinOmniTransfers';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Hash of the block */\n  blockHash: Scalars['String'];\n  /** Transaction s count */\n  count?: Maybe<Scalars['Int']>;\n  /** Transaction s count */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Direction */\n  direction?: Maybe<Scalars['String']>;\n  /** Divisible */\n  divisible?: Maybe<Scalars['Int']>;\n  /** Transactions total fee value */\n  feeValue?: Maybe<Scalars['Float']>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transactions index in block, 0-based */\n  index: Scalars['String'];\n  /** Ismine */\n  ismine?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transfer From */\n  transferFrom: Scalars['String'];\n  /** Transfer From */\n  transferTo: Scalars['String'];\n  /** Transaction Sender */\n  txSender: Scalars['String'];\n  /** Type */\n  type: Scalars['String'];\n  /** Type Int */\n  typeInt: Scalars['Int'];\n  /** value */\n  value?: Maybe<Scalars['Float']>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersanyArgs = {\n  of: BitcoinOmniTransfersMeasureablse;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersblockHashArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransferscountArgs = {\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  invalidReason?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  type?: InputMaybe<StringSelector>;\n  typeId?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinOmniTransfersUniq>;\n  valid?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransferscountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  invalidReason?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  type?: InputMaybe<StringSelector>;\n  typeId?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinOmniTransfersUniq>;\n  valid?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersdirectionArgs = {\n  direction?: InputMaybe<StringSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersdivisibleArgs = {\n  divisible?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersfeeValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  invalidReason?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  type?: InputMaybe<StringSelector>;\n  typeId?: InputMaybe<IntegerSelector>;\n  valid?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfershashArgs = {\n  txHash?: InputMaybe<StringIdSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersindexArgs = {\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersismineArgs = {\n  ismine?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersmaximumArgs = {\n  get?: InputMaybe<BitcoinOmniTransfersMeasureablse>;\n  of: BitcoinOmniTransfersMeasureablse;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersminimumArgs = {\n  get?: InputMaybe<BitcoinOmniTransfersMeasureablse>;\n  of: BitcoinOmniTransfersMeasureablse;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransferstransferFromArgs = {\n  transferFrom?: InputMaybe<HashSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransferstransferToArgs = {\n  transferTo?: InputMaybe<HashSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransferstxSenderArgs = {\n  txSender?: InputMaybe<HashSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransferstypeArgs = {\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransferstypeIntArgs = {\n  typeInt?: InputMaybe<IntegerSelector>;\n};\n\n\n/** OmniTransfers */\nexport type BitcoinOmniTransfersvalueArgs = {\n  value?: InputMaybe<FloatSelector>;\n};\n\nexport type BitcoinOmniTransfersFilter = {\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  invalidReason?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  type?: InputMaybe<StringSelector>;\n  typeId?: InputMaybe<IntegerSelector>;\n  valid?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\nexport enum BitcoinOmniTransfersMeasureablse {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Transactions hash */\n  tx_hash = 'tx_hash',\n  /** Transactions index */\n  tx_index = 'tx_index'\n}\n\nexport enum BitcoinOmniTransfersUniq {\n  /** Unique block count */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transaction sender */\n  tx_sender = 'tx_sender'\n}\n\nexport enum BitcoinOutputDirection {\n  /** Change return */\n  change = 'change',\n  /** Fee */\n  fee = 'fee',\n  /** Genesis */\n  genesis = 'genesis',\n  /** Likely Change return */\n  likely_change = 'likely_change',\n  /** Likely Not a change return */\n  likely_not_change = 'likely_not_change',\n  /** Mining */\n  mining = 'mining',\n  /** Minting */\n  minting = 'minting',\n  /** Not a change return */\n  not_change = 'not_change',\n  /** Not defined */\n  unknown = 'unknown'\n}\n\n/** A guessed direction of output */\nexport type BitcoinOutputDirectionSelector = {\n  /** In the list of direction */\n  in?: InputMaybe<Array<BitcoinOutputDirection>>;\n  /** Equal to direction */\n  is?: InputMaybe<BitcoinOutputDirection>;\n  /** Not Equal to direction */\n  not?: InputMaybe<BitcoinOutputDirection>;\n  /** Not in the list of direction */\n  notIn?: InputMaybe<Array<BitcoinOutputDirection>>;\n};\n\nexport type BitcoinOutputFilter = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  outputAddress?: InputMaybe<AddressSelector>;\n  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;\n  outputIndex?: InputMaybe<IntegerSelector>;\n  outputScriptType?: InputMaybe<BitcoinOutputScriptTypeSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\nexport enum BitcoinOutputScriptType {\n  /** Output Multisignature Wallet */\n  multisig = 'multisig',\n  /** Non standard output script */\n  nonstandard = 'nonstandard',\n  /** Output nulldata */\n  nulldata = 'nulldata',\n  /** Output PubKey */\n  pubkey = 'pubkey',\n  /** Output PubKey Hash */\n  pubkeyhash = 'pubkeyhash',\n  /** Output Script Hash */\n  scripthash = 'scripthash',\n  /** Output Witness Other */\n  witness_unknown = 'witness_unknown',\n  /** Output Witness Key Hash */\n  witness_v0_keyhash = 'witness_v0_keyhash',\n  /** Output Witness Script Hash */\n  witness_v0_scripthash = 'witness_v0_scripthash'\n}\n\n/** Selector of output script type */\nexport type BitcoinOutputScriptTypeSelector = {\n  /** In the list of Script Type */\n  in?: InputMaybe<Array<BitcoinOutputScriptType>>;\n  /** Equal to Script Type */\n  is?: InputMaybe<BitcoinOutputScriptType>;\n  /** Not Equal to Script Type */\n  not?: InputMaybe<BitcoinOutputScriptType>;\n  /** Not in the list of Script Type */\n  notIn?: InputMaybe<Array<BitcoinOutputScriptType>>;\n};\n\nexport enum BitcoinOutputUniq {\n  /** Unique input addresses count */\n  addresses = 'addresses',\n  /** Unique block count */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transactions count */\n  transactions = 'transactions'\n}\n\nexport enum BitcoinOutputsMeasureable {\n  /** Address */\n  address = 'address',\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Output index */\n  output_index = 'output_index',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction index */\n  tx_index = 'tx_index'\n}\n\n/** Transaction */\nexport type BitcoinTransaction = {\n  __typename?: 'BitcoinTransaction';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Transaction  count */\n  count?: Maybe<Scalars['Int']>;\n  /** Transaction  count */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Transaction total fee value */\n  feeValue?: Maybe<Scalars['Float']>;\n  /** Transaction total fee value */\n  feeValueDecimal?: Maybe<Scalars['DecimalNumber']>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0-based */\n  index: Scalars['String'];\n  /** Transaction total input count */\n  inputCount?: Maybe<Scalars['Int']>;\n  /** Transaction total input count */\n  inputCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Transaction total input value */\n  inputValue?: Maybe<Scalars['Float']>;\n  /** Transaction total input value as decimal */\n  inputValueDecimal?: Maybe<Scalars['DecimalNumber']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Transaction total mined value */\n  minedValue?: Maybe<Scalars['Float']>;\n  /** Transaction total mined value */\n  minedValueDecimal?: Maybe<Scalars['DecimalNumber']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transaction total output count */\n  outputCount?: Maybe<Scalars['Int']>;\n  /** Transaction total output count */\n  outputCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Transaction total output value */\n  outputValue?: Maybe<Scalars['Float']>;\n  /** Transaction total output value */\n  outputValueDecimal?: Maybe<Scalars['DecimalNumber']>;\n  /** Transaction is coinbase */\n  txCoinbase?: Maybe<Scalars['Boolean']>;\n  /** Transaction locktime */\n  txLocktime?: Maybe<Scalars['BigInt']>;\n  /** Transaction size */\n  txSize?: Maybe<Scalars['Int']>;\n  /** Transaction version */\n  txVersion?: Maybe<Scalars['Int']>;\n  /** Transaction vsize */\n  txVsize?: Maybe<Scalars['Int']>;\n  /** Transaction weight */\n  txWeight?: Maybe<Scalars['Int']>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionanyArgs = {\n  of: BitcoinTransactionsMeasureable;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactioncountArgs = {\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinTransactionUniq>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactioncountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinTransactionUniq>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionfeeValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionfeeValueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionhashArgs = {\n  txHash?: InputMaybe<StringIdSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionindexArgs = {\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactioninputCountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactioninputCountBigIntArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactioninputValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactioninputValueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionmaximumArgs = {\n  get?: InputMaybe<BitcoinTransactionsMeasureable>;\n  of: BitcoinTransactionsMeasureable;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionminedValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionminedValueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionminimumArgs = {\n  get?: InputMaybe<BitcoinTransactionsMeasureable>;\n  of: BitcoinTransactionsMeasureable;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionoutputCountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionoutputCountBigIntArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionoutputValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactionoutputValueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactiontxCoinbaseArgs = {\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactiontxLocktimeArgs = {\n  txLocktime?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactiontxSizeArgs = {\n  txSize?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactiontxVersionArgs = {\n  txVersion?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactiontxVsizeArgs = {\n  txVsize?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type BitcoinTransactiontxWeightArgs = {\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\nexport type BitcoinTransactionFilter = {\n  date?: InputMaybe<DateSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  minedValue?: InputMaybe<FloatSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCoinbase?: InputMaybe<Scalars['Boolean']>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txLocktime?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  txVersion?: InputMaybe<IntegerSelector>;\n  txVsize?: InputMaybe<IntegerSelector>;\n  txWeight?: InputMaybe<IntegerSelector>;\n};\n\n/** Blockchain transaction */\nexport type BitcoinTransactionHashIndexValues = {\n  __typename?: 'BitcoinTransactionHashIndexValues';\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0-based */\n  index: Scalars['String'];\n  /** Transaction value in input */\n  valueIn: Scalars['Float'];\n  /** Transaction value in input */\n  valueInDecimal: Scalars['DecimalNumber'];\n  /** Transaction value in output */\n  valueOut: Scalars['Float'];\n  /** Transaction value in output */\n  valueOutDecimal: Scalars['DecimalNumber'];\n};\n\n/** Transaction Input */\nexport type BitcoinTransactionInput = {\n  __typename?: 'BitcoinTransactionInput';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Input count */\n  count?: Maybe<Scalars['Int']>;\n  /** Input count */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Input address */\n  inputAddress?: Maybe<Address>;\n  /** Input index */\n  inputIndex?: Maybe<Scalars['Int']>;\n  /** Input script */\n  inputScript?: Maybe<Scalars['String']>;\n  /** Input script type and attributes */\n  inputScriptType?: Maybe<InputScript>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Output Transaction for this input */\n  outputTransaction?: Maybe<TransactionHashIndex>;\n  /** Transaction ID Hash */\n  transaction?: Maybe<TransactionHashIndex>;\n  /** Input value */\n  value?: Maybe<Scalars['Float']>;\n  /** Input value as decimal */\n  valueDecimal?: Maybe<Scalars['DecimalNumber']>;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputanyArgs = {\n  of: BitcoinInputsMeasureable;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputcountArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputScriptType?: InputMaybe<BitcoinInputScriptTypeSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinInputUniq>;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputcountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputScriptType?: InputMaybe<BitcoinInputScriptTypeSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinInputUniq>;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputinputAddressArgs = {\n  inputAddress?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputinputIndexArgs = {\n  inputIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputinputScriptTypeArgs = {\n  inputScriptType?: InputMaybe<BitcoinInputScriptTypeSelector>;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputmaximumArgs = {\n  get?: InputMaybe<BitcoinInputsMeasureable>;\n  of: BitcoinInputsMeasureable;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputminimumArgs = {\n  get?: InputMaybe<BitcoinInputsMeasureable>;\n  of: BitcoinInputsMeasureable;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputoutputTransactionArgs = {\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<StringIdSelector>;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputtransactionArgs = {\n  txId?: InputMaybe<StringIdSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputvalueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputScriptType?: InputMaybe<BitcoinInputScriptTypeSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Input */\nexport type BitcoinTransactionInputvalueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputScriptType?: InputMaybe<BitcoinInputScriptTypeSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n/** Transaction Output */\nexport type BitcoinTransactionOutput = {\n  __typename?: 'BitcoinTransactionOutput';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Output count */\n  count?: Maybe<Scalars['Int']>;\n  /** Output count */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Output address */\n  outputAddress?: Maybe<Address>;\n  /** Output guessed direction */\n  outputDirection?: Maybe<BitcoinOutputDirection>;\n  /** Output index */\n  outputIndex?: Maybe<Scalars['Int']>;\n  /** Output script */\n  outputScript?: Maybe<Scalars['String']>;\n  /** Output script type and attributes */\n  outputScriptType?: Maybe<OutputScript>;\n  reqSigs?: Maybe<Scalars['Int']>;\n  /** Transaction ID Hash */\n  transaction?: Maybe<TransactionHashIndex>;\n  /** Output value */\n  value?: Maybe<Scalars['Float']>;\n  /** Output value as decimal */\n  valueDecimal?: Maybe<Scalars['DecimalNumber']>;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputanyArgs = {\n  of: BitcoinOutputsMeasureable;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputcountArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  outputAddress?: InputMaybe<AddressSelector>;\n  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;\n  outputIndex?: InputMaybe<IntegerSelector>;\n  outputScriptType?: InputMaybe<BitcoinOutputScriptTypeSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinOutputUniq>;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputcountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  outputAddress?: InputMaybe<AddressSelector>;\n  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;\n  outputIndex?: InputMaybe<IntegerSelector>;\n  outputScriptType?: InputMaybe<BitcoinOutputScriptTypeSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<BitcoinOutputUniq>;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputmaximumArgs = {\n  get?: InputMaybe<BitcoinOutputsMeasureable>;\n  of: BitcoinOutputsMeasureable;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputminimumArgs = {\n  get?: InputMaybe<BitcoinOutputsMeasureable>;\n  of: BitcoinOutputsMeasureable;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputoutputAddressArgs = {\n  outputAddress?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputoutputDirectionArgs = {\n  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputoutputIndexArgs = {\n  outputIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputoutputScriptTypeArgs = {\n  inputScriptType?: InputMaybe<BitcoinOutputScriptTypeSelector>;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputtransactionArgs = {\n  txId?: InputMaybe<StringIdSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputvalueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  outputAddress?: InputMaybe<AddressSelector>;\n  outputDirection?: InputMaybe<BitcoinOutputDirectionSelector>;\n  outputIndex?: InputMaybe<IntegerSelector>;\n  outputScriptType?: InputMaybe<BitcoinOutputScriptTypeSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Output */\nexport type BitcoinTransactionOutputvalueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputScriptType?: InputMaybe<BitcoinInputScriptTypeSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\nexport enum BitcoinTransactionUniq {\n  /** Unique block count */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates'\n}\n\nexport enum BitcoinTransactionsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Input count */\n  input_count = 'input_count',\n  /** Transaction input value */\n  input_value = 'input_value',\n  /** Output count */\n  output_count = 'output_count',\n  /** Transaction output value */\n  output_value = 'output_value',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction index */\n  tx_index = 'tx_index',\n  /** Transaction size */\n  tx_size = 'tx_size'\n}\n\n/** Block */\nexport type Block = {\n  __typename?: 'Block';\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n};\n\n/** BlockExtended */\nexport type BlockExtended = {\n  __typename?: 'BlockExtended';\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n};\n\n/** ConfluxBlock */\nexport type BlockInfo = {\n  __typename?: 'BlockInfo';\n  /** Block hash */\n  hash?: Maybe<Scalars['String']>;\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n};\n\n/** Select block by height ( sequence number) */\nexport type BlockSelector = {\n  /** Block height in range */\n  between?: InputMaybe<Array<Scalars['Int']>>;\n  /** Block height greater than */\n  gt?: InputMaybe<Scalars['Int']>;\n  /** Block height greater or equal than */\n  gteq?: InputMaybe<Scalars['Int']>;\n  /** Block height in the list */\n  in?: InputMaybe<Array<Scalars['Int']>>;\n  /** Block height is */\n  is?: InputMaybe<Scalars['Int']>;\n  /** Block height less than */\n  lt?: InputMaybe<Scalars['Int']>;\n  /** Block height less or equal than */\n  lteq?: InputMaybe<Scalars['Int']>;\n  /** Block height not */\n  not?: InputMaybe<Scalars['Int']>;\n  /** Block height not in the list */\n  notIn?: InputMaybe<Array<Scalars['Int']>>;\n};\n\n/** Select block by height ( sequence number) */\nexport type BlockSelectorRange = {\n  /** Block height in range */\n  between?: InputMaybe<Array<Scalars['Int']>>;\n  /** Block height greater or equal than */\n  gteq?: InputMaybe<Scalars['Int']>;\n  /** Block height less or equal than */\n  lteq?: InputMaybe<Scalars['Int']>;\n};\n\n/** Blockchain network */\nexport type BlockchainNetwork = {\n  __typename?: 'BlockchainNetwork';\n  /** Network name */\n  network: Network;\n  /** Network protocol type */\n  protocol: Protocol;\n};\n\n/** Select by boolean (sequence number) */\nexport type BooleanSelector = {\n  /** Is */\n  is?: InputMaybe<Scalars['Boolean']>;\n  /** Is not */\n  not?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** Information about call */\nexport type CallElrond = {\n  __typename?: 'CallElrond';\n  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */\n  callDepth?: Maybe<Scalars['String']>;\n  /** Contract method invoked */\n  smartContractAddress?: Maybe<Scalars['String']>;\n  /** Smart contract name */\n  smartContractName?: Maybe<Scalars['String']>;\n  /** Smart contract signature */\n  smartContractSignature?: Maybe<Scalars['String']>;\n  /** Signature Hash */\n  smartContractSignatureHash?: Maybe<Scalars['String']>;\n};\n\n\n/** Information about call */\nexport type CallElrondsmartContractAddressArgs = {\n  smartContractAddress?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about call */\nexport type CallElrondsmartContractNameArgs = {\n  smartContractName?: InputMaybe<StringSelector>;\n};\n\n\n/** Information about call */\nexport type CallElrondsmartContractSignatureArgs = {\n  smartContractSignature?: InputMaybe<StringSelector>;\n};\n\n\n/** Information about call */\nexport type CallElrondsmartContractSignatureHashArgs = {\n  smartContractSignatureHash?: InputMaybe<HashSelector>;\n};\n\n/** Cardano */\nexport type Cardano = {\n  __typename?: 'Cardano';\n  /** Information about address */\n  address: Array<CardanoAddressInfo>;\n  /** Blockchain Blocks */\n  blocks?: Maybe<Array<CardanoBlock>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<CardanoCoinpath>>;\n  /** Blockchain Transaction Inputs */\n  inputs?: Maybe<Array<CardanoTransactionInput>>;\n  /** Blockchain Tokens Mints */\n  mints?: Maybe<Array<CardanoTransactionMint>>;\n  /** Blockchain Transaction Outputs */\n  outputs?: Maybe<Array<CardanoTransactionOutput>>;\n  /** Blockchain Transactions */\n  transactions?: Maybe<Array<CardanoTransaction>>;\n};\n\n\n/** Cardano */\nexport type CardanoaddressArgs = {\n  address: Array<AddressSelectorIn>;\n};\n\n\n/** Cardano */\nexport type CardanoblocksArgs = {\n  any?: InputMaybe<Array<CardanoBlockFilter>>;\n  blockHash?: InputMaybe<StringIdSelector>;\n  blockSize?: InputMaybe<IntegerSelector>;\n  blockVersion?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  opCert?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  slot?: InputMaybe<IntegerSelector>;\n  slotInEpoch?: InputMaybe<IntegerSelector>;\n  slotLeaderHash?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<StringSelector>;\n  vrfKey?: InputMaybe<StringSelector>;\n};\n\n\n/** Cardano */\nexport type CardanocoinpathArgs = {\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<AddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CardanoCoinpathOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Cardano */\nexport type CardanoinputsArgs = {\n  any?: InputMaybe<Array<CardanoInputFilter>>;\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Cardano */\nexport type CardanomintsArgs = {\n  any?: InputMaybe<Array<CardanoMintFilter>>;\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  value?: InputMaybe<FloatSelector>;\n};\n\n\n/** Cardano */\nexport type CardanooutputsArgs = {\n  any?: InputMaybe<Array<CardanoOutputFilter>>;\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  outputAddress?: InputMaybe<AddressSelector>;\n  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;\n  outputIndex?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Cardano */\nexport type CardanotransactionsArgs = {\n  any?: InputMaybe<Array<CardanoTransactionFilter>>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  options?: InputMaybe<QueryOptions>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n/** Address balance information for Cardano network */\nexport type CardanoAddressBalance = {\n  __typename?: 'CardanoAddressBalance';\n  /** Currency */\n  currency?: Maybe<Currency>;\n  /** Currency value */\n  value?: Maybe<Scalars['Float']>;\n};\n\n/** Address detailed information for Cardano network */\nexport type CardanoAddressInfo = {\n  __typename?: 'CardanoAddressInfo';\n  /** Address */\n  address?: Maybe<Address>;\n  /** Current address balances */\n  balance?: Maybe<Array<CardanoAddressBalance>>;\n  /** Current staking addressese info */\n  staking?: Maybe<Array<CardanoStakingAddress>>;\n};\n\n/** Block */\nexport type CardanoBlock = {\n  __typename?: 'CardanoBlock';\n  any?: Maybe<Scalars['String']>;\n  /** Block Hash */\n  blockHash?: Maybe<Scalars['String']>;\n  /** Block size */\n  blockSize?: Maybe<Scalars['Int']>;\n  /** Block version */\n  blockVersion?: Maybe<Scalars['Int']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Epoch number */\n  epoch?: Maybe<Scalars['Int']>;\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Op cert */\n  opCert?: Maybe<Scalars['String']>;\n  /** Slot number */\n  slot?: Maybe<Scalars['Int']>;\n  /** Slot in epoch number */\n  slotInEpoch?: Maybe<Scalars['Int']>;\n  /** Slot leader description */\n  slotLeaderDescription?: Maybe<Scalars['String']>;\n  /** Slot leader hash */\n  slotLeaderHash?: Maybe<Scalars['String']>;\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n  /** Transaction count in block */\n  transactionCount?: Maybe<Scalars['Int']>;\n  /** VRF Key */\n  vrfKey?: Maybe<Scalars['String']>;\n};\n\n\n/** Block */\nexport type CardanoBlockanyArgs = {\n  of: CardanoBlocksMeasureable;\n};\n\n\n/** Block */\nexport type CardanoBlockblockHashArgs = {\n  blockHash?: InputMaybe<StringIdSelector>;\n};\n\n\n/** Block */\nexport type CardanoBlockblockSizeArgs = {\n  blockSize?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block */\nexport type CardanoBlockblockVersionArgs = {\n  blockVersion?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block */\nexport type CardanoBlockcountArgs = {\n  blockHash?: InputMaybe<StringIdSelector>;\n  blockSize?: InputMaybe<IntegerSelector>;\n  blockStrippedSize?: InputMaybe<IntegerSelector>;\n  blockVersion?: InputMaybe<IntegerSelector>;\n  blockWeight?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  difficulty?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCount?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<CardanoBlockUniq>;\n};\n\n\n/** Block */\nexport type CardanoBlockcountBigIntArgs = {\n  blockHash?: InputMaybe<StringIdSelector>;\n  blockSize?: InputMaybe<IntegerSelector>;\n  blockStrippedSize?: InputMaybe<IntegerSelector>;\n  blockVersion?: InputMaybe<IntegerSelector>;\n  blockWeight?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  difficulty?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCount?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<CardanoBlockUniq>;\n};\n\n\n/** Block */\nexport type CardanoBlockheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Block */\nexport type CardanoBlockmaximumArgs = {\n  get?: InputMaybe<CardanoBlocksMeasureable>;\n  of: CardanoBlocksMeasureable;\n};\n\n\n/** Block */\nexport type CardanoBlockminimumArgs = {\n  get?: InputMaybe<CardanoBlocksMeasureable>;\n  of: CardanoBlocksMeasureable;\n};\n\n\n/** Block */\nexport type CardanoBlocktimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type CardanoBlocktransactionCountArgs = {\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\nexport type CardanoBlockFilter = {\n  blockHash?: InputMaybe<StringIdSelector>;\n  blockSize?: InputMaybe<IntegerSelector>;\n  blockVersion?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  opCert?: InputMaybe<StringSelector>;\n  slot?: InputMaybe<IntegerSelector>;\n  slotInEpoch?: InputMaybe<IntegerSelector>;\n  slotLeaderHash?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  version?: InputMaybe<StringSelector>;\n  vrfKey?: InputMaybe<StringSelector>;\n};\n\nexport enum CardanoBlockUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique epoch */\n  epoch = 'epoch',\n  /** Unique slot */\n  slot = 'slot',\n  /** Unique slot leader */\n  slot_leader = 'slot_leader',\n  /** Unique version */\n  version = 'version'\n}\n\nexport enum CardanoBlocksMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Tx Count */\n  transaction_count = 'transaction_count'\n}\n\n/** Coinpath */\nexport type CardanoCoinpath = {\n  __typename?: 'CardanoCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<Address>;\n  /** Sender address */\n  sender?: Maybe<Address>;\n  /** Transaction of transfer happened */\n  transaction?: Maybe<CardanoTransactionHashIndexValues>;\n  /** Attributes of transaction included in Coinpath result */\n  transactions?: Maybe<Array<CoinpathEntry>>;\n};\n\n\n/** Coinpath */\nexport type CardanoCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Coinpath */\nexport type CardanoCoinpathanyArgs = {\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type CardanoCoinpathmaximumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type CardanoCoinpathminimumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\nexport enum CardanoCoinpathMethod {\n  /** Tracking money flow by amounts, ignoring coins (default) */\n  moneyflow = 'moneyflow',\n  /** Tracking coins by UTXO transactions */\n  utxo = 'utxo'\n}\n\n/** Limits, Ordering, Constraints, Coinpath Options */\nexport type CardanoCoinpathOptions = {\n  /** Ordering field(s) for ascending */\n  asc?: InputMaybe<Array<Scalars['String']>>;\n  /** Method to use coinpath */\n  coinpathMethod?: InputMaybe<CardanoCoinpathMethod>;\n  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */\n  complexityLimit?: InputMaybe<Scalars['Int']>;\n  /** Ordering field(s) for descending */\n  desc?: InputMaybe<Array<Scalars['String']>>;\n  /** Flow direction */\n  direction?: InputMaybe<FlowDirection>;\n  /** Limit number of results */\n  limit?: InputMaybe<Scalars['Int']>;\n  /** Limit number of results by specific field */\n  limitBy?: InputMaybe<LimitByOption>;\n  /** Do not expand addresses having count transactions more than this */\n  maximumAddressTxCount?: InputMaybe<Scalars['Int']>;\n  /** Maximum total transaction count returned */\n  maximumTotalTxCount?: InputMaybe<Scalars['Int']>;\n  /** Do not include transactions below this amount */\n  minimumTxAmount?: InputMaybe<Scalars['Float']>;\n  /** Offset of results, starting from 0 */\n  offset?: InputMaybe<Scalars['Int']>;\n  /** Invalidating cache seed */\n  seed?: InputMaybe<Scalars['Int']>;\n};\n\n/**\n * Cardano token selector by tokenId.\n *     Native binance token has ADA symbol, pass it as argument.\n *     Otherwise pass asset fingerprint, starting from asset...\n */\nexport type CardanoCurrencySelector = {\n  /** Currency in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Currency is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Currency not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Currency not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\nexport type CardanoInputFilter = {\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\nexport enum CardanoInputSource {\n  /** Input */\n  input = 'input',\n  /** Withdrawal */\n  withdrawal = 'withdrawal'\n}\n\nexport enum CardanoInputUniq {\n  /** Unique addresses count */\n  addresses = 'addresses',\n  /** Unique block count */\n  blocks = 'blocks',\n  /** Unique currencies count */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transactions count */\n  transactions = 'transactions'\n}\n\nexport enum CardanoInputsMeasureable {\n  /** Address */\n  address = 'address',\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Input index */\n  input_index = 'input_index',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction index */\n  tx_index = 'tx_index'\n}\n\nexport type CardanoMintFilter = {\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  value?: InputMaybe<FloatSelector>;\n};\n\nexport enum CardanoMintUniq {\n  /** Unique block count */\n  blocks = 'blocks',\n  /** Unique currencies count */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transactions count */\n  transactions = 'transactions'\n}\n\nexport enum CardanoMintsMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction index */\n  tx_index = 'tx_index'\n}\n\nexport enum CardanoNetwork {\n  /** Cardano ( ADA ) */\n  cardano = 'cardano'\n}\n\nexport enum CardanoOutputDirection {\n  /** Change return */\n  change = 'change',\n  /** Fee */\n  fee = 'fee',\n  /** Genesis */\n  genesis = 'genesis',\n  /** Likely Change return */\n  likely_change = 'likely_change',\n  /** Likely Not a change return */\n  likely_not_change = 'likely_not_change',\n  /** Mining */\n  mining = 'mining',\n  /** Minting */\n  minting = 'minting',\n  /** Not a change return */\n  not_change = 'not_change',\n  /** Not defined */\n  unknown = 'unknown'\n}\n\n/** A guessed direction of output */\nexport type CardanoOutputDirectionSelector = {\n  /** In the list of direction */\n  in?: InputMaybe<Array<CardanoOutputDirection>>;\n  /** Equal to direction */\n  is?: InputMaybe<CardanoOutputDirection>;\n  /** Not Equal to direction */\n  not?: InputMaybe<CardanoOutputDirection>;\n  /** Not in the list of direction */\n  notIn?: InputMaybe<Array<CardanoOutputDirection>>;\n};\n\nexport type CardanoOutputFilter = {\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  outputAddress?: InputMaybe<AddressSelector>;\n  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;\n  outputIndex?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\nexport enum CardanoOutputUniq {\n  /** Unique input addresses count */\n  addresses = 'addresses',\n  /** Unique block count */\n  blocks = 'blocks',\n  /** Unique currencies count */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transactions count */\n  transactions = 'transactions'\n}\n\nexport enum CardanoOutputsMeasureable {\n  /** Address */\n  address = 'address',\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Output index */\n  output_index = 'output_index',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction index */\n  tx_index = 'tx_index'\n}\n\n/** Address staking information for Cardano network */\nexport type CardanoStakingAddress = {\n  __typename?: 'CardanoStakingAddress';\n  /** Staking Address */\n  address?: Maybe<Address>;\n  /** Rewards value */\n  rewardsAmount?: Maybe<Scalars['Float']>;\n  /** Staked value */\n  stakedAmount?: Maybe<Scalars['Float']>;\n  /** Staked value including rewards */\n  stakedAmountWithRewards?: Maybe<Scalars['Float']>;\n  /** Withdrawn value */\n  withdrawnAmount?: Maybe<Scalars['Float']>;\n};\n\n/** Transaction */\nexport type CardanoTransaction = {\n  __typename?: 'CardanoTransaction';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Transaction  count */\n  count?: Maybe<Scalars['Int']>;\n  /** Transaction  count */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Transaction total deposit value */\n  depositValue?: Maybe<Scalars['Float']>;\n  /** Transaction total fee value */\n  depositValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;\n  /** Transaction total fee value */\n  feeValue?: Maybe<Scalars['Float']>;\n  /** Transaction total fee value */\n  feeValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Included at timestamp */\n  includedAt?: Maybe<DateTime>;\n  /** Transaction index in block, 0-based */\n  index: Scalars['String'];\n  /** Transaction total input count */\n  inputCount?: Maybe<Scalars['Int']>;\n  /** Transaction total input count */\n  inputCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Transaction total input value */\n  inputValue?: Maybe<Scalars['Float']>;\n  /** Transaction total input value as decimal */\n  inputValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;\n  /** Invalid before */\n  invalidBefore?: Maybe<Scalars['String']>;\n  /** Invalid hereafter */\n  invalidHereafter?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Metadata */\n  metadata?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transaction total mint count */\n  mintCount?: Maybe<Scalars['Int']>;\n  /** Transaction total mint count */\n  mintCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Transaction total output count */\n  outputCount?: Maybe<Scalars['Int']>;\n  /** Transaction total output count */\n  outputCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Transaction total output value */\n  outputValue?: Maybe<Scalars['Float']>;\n  /** Transaction total output value */\n  outputValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;\n  /** Transaction size */\n  txSize?: Maybe<Scalars['Int']>;\n  /** Transaction total withdrawal count */\n  withdrawalCount?: Maybe<Scalars['Int']>;\n  /** Transaction total withdrawal count */\n  withdrawalCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Transaction total withdrawal value */\n  withdrawalValue?: Maybe<Scalars['Float']>;\n  /** Transaction total fee value */\n  withdrawalValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionanyArgs = {\n  of: CardanoTransactionsMeasureable;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactioncountArgs = {\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<CardanoTransactionUniq>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactioncountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<CardanoTransactionUniq>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactiondepositValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactiondepositValueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionfeeValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionfeeValueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionhashArgs = {\n  txHash?: InputMaybe<StringIdSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionindexArgs = {\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactioninputCountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactioninputCountBigIntArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactioninputValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactioninputValueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionmaximumArgs = {\n  get?: InputMaybe<CardanoTransactionsMeasureable>;\n  of: CardanoTransactionsMeasureable;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionminimumArgs = {\n  get?: InputMaybe<CardanoTransactionsMeasureable>;\n  of: CardanoTransactionsMeasureable;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionmintCountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionmintCountBigIntArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionoutputCountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionoutputCountBigIntArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionoutputValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionoutputValueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactiontxSizeArgs = {\n  txSize?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionwithdrawalCountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionwithdrawalCountBigIntArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionwithdrawalValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction */\nexport type CardanoTransactionwithdrawalValueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\nexport type CardanoTransactionFilter = {\n  date?: InputMaybe<DateSelector>;\n  depositValue?: InputMaybe<FloatSelector>;\n  feeValue?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inputAddress?: InputMaybe<AddressSelectorIn>;\n  inputCount?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  mintCount?: InputMaybe<IntegerSelector>;\n  outputAddress?: InputMaybe<AddressSelectorIn>;\n  outputCount?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txSize?: InputMaybe<IntegerSelector>;\n  withdrawalCount?: InputMaybe<IntegerSelector>;\n  withdrawalValue?: InputMaybe<FloatSelector>;\n};\n\n/** Blockchain transaction */\nexport type CardanoTransactionHashIndexValues = {\n  __typename?: 'CardanoTransactionHashIndexValues';\n  depositValue: Scalars['Float'];\n  /** Transaction deposit value as decimal */\n  depositValueDecimal: Scalars['DecimalNumberAsDiv'];\n  feeValue: Scalars['Float'];\n  /** Transaction fee value as decimal */\n  feeValueDecimal: Scalars['DecimalNumberAsDiv'];\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  includedAt: DateTime;\n  /** Transaction index in block, 0-based */\n  index: Scalars['String'];\n  invalidBefore: Scalars['String'];\n  invalidHereafter: Scalars['String'];\n  metadata: Scalars['String'];\n  txSize: Scalars['Int'];\n  /** Transaction value in input */\n  valueIn: Scalars['Float'];\n  /** Transaction value in input as decimal */\n  valueInDecimal: Scalars['DecimalNumberAsDiv'];\n  /** Transaction value in output */\n  valueOut: Scalars['Float'];\n  /** Transaction value in output as decimal */\n  valueOutDecimal: Scalars['DecimalNumberAsDiv'];\n  withdrawalValue: Scalars['Float'];\n  /** Transaction withdraw value as decimal */\n  withdrawalValueDecimal: Scalars['DecimalNumberAsDiv'];\n};\n\n/** Transaction Input */\nexport type CardanoTransactionInput = {\n  __typename?: 'CardanoTransactionInput';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Input count */\n  count?: Maybe<Scalars['Int']>;\n  /** Input count */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of the input */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Input address */\n  inputAddress?: Maybe<Address>;\n  /** Input index */\n  inputIndex?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Output Transaction for this input */\n  outputTransaction?: Maybe<TransactionHashIndex>;\n  /** Source of the input */\n  source?: Maybe<CardanoInputSource>;\n  /** Transaction ID Hash */\n  transaction?: Maybe<TransactionHashIndex>;\n  /** Input value */\n  value?: Maybe<Scalars['Float']>;\n  /** Input value as decimal */\n  valueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputanyArgs = {\n  of: CardanoInputsMeasureable;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputcountArgs = {\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<CardanoInputUniq>;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputcountBigIntArgs = {\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<CardanoInputUniq>;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputinputAddressArgs = {\n  inputAddress?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputinputIndexArgs = {\n  inputIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputmaximumArgs = {\n  get?: InputMaybe<CardanoInputsMeasureable>;\n  of: CardanoInputsMeasureable;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputminimumArgs = {\n  get?: InputMaybe<CardanoInputsMeasureable>;\n  of: CardanoInputsMeasureable;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputoutputTransactionArgs = {\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<StringIdSelector>;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputtransactionArgs = {\n  txId?: InputMaybe<StringIdSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputvalueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Input */\nexport type CardanoTransactionInputvalueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n/** Transaction Mint */\nexport type CardanoTransactionMint = {\n  __typename?: 'CardanoTransactionMint';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Mint count */\n  count?: Maybe<Scalars['Int']>;\n  /** Mint count */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of the mint */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transaction ID Hash */\n  transaction?: Maybe<TransactionHashIndex>;\n  /** Mint value */\n  value?: Maybe<Scalars['Float']>;\n};\n\n\n/** Transaction Mint */\nexport type CardanoTransactionMintanyArgs = {\n  of: CardanoMintsMeasureable;\n};\n\n\n/** Transaction Mint */\nexport type CardanoTransactionMintblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transaction Mint */\nexport type CardanoTransactionMintcountArgs = {\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<CardanoMintUniq>;\n  value?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction Mint */\nexport type CardanoTransactionMintcountBigIntArgs = {\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<CardanoMintUniq>;\n  value?: InputMaybe<FloatSelector>;\n};\n\n\n/** Transaction Mint */\nexport type CardanoTransactionMintmaximumArgs = {\n  get?: InputMaybe<CardanoMintsMeasureable>;\n  of: CardanoMintsMeasureable;\n};\n\n\n/** Transaction Mint */\nexport type CardanoTransactionMintminimumArgs = {\n  get?: InputMaybe<CardanoMintsMeasureable>;\n  of: CardanoMintsMeasureable;\n};\n\n\n/** Transaction Mint */\nexport type CardanoTransactionMinttransactionArgs = {\n  txId?: InputMaybe<StringIdSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Mint */\nexport type CardanoTransactionMintvalueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  value?: InputMaybe<FloatSelector>;\n};\n\n/** Transaction Output */\nexport type CardanoTransactionOutput = {\n  __typename?: 'CardanoTransactionOutput';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Output count */\n  count?: Maybe<Scalars['Int']>;\n  /** Output count */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of the output */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Output address */\n  outputAddress?: Maybe<Address>;\n  /** Output guessed direction */\n  outputDirection?: Maybe<CardanoOutputDirection>;\n  /** Output index */\n  outputIndex?: Maybe<Scalars['Int']>;\n  /** Transaction ID Hash */\n  transaction?: Maybe<TransactionHashIndex>;\n  /** Output value */\n  value?: Maybe<Scalars['Float']>;\n  /** Input value as decimal */\n  valueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputanyArgs = {\n  of: CardanoOutputsMeasureable;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputcountArgs = {\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  outputAddress?: InputMaybe<AddressSelector>;\n  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;\n  outputIndex?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<CardanoOutputUniq>;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputcountBigIntArgs = {\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  outputAddress?: InputMaybe<AddressSelector>;\n  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;\n  outputIndex?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  uniq?: InputMaybe<CardanoOutputUniq>;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputmaximumArgs = {\n  get?: InputMaybe<CardanoOutputsMeasureable>;\n  of: CardanoOutputsMeasureable;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputminimumArgs = {\n  get?: InputMaybe<CardanoOutputsMeasureable>;\n  of: CardanoOutputsMeasureable;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputoutputAddressArgs = {\n  outputAddress?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputoutputDirectionArgs = {\n  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputoutputIndexArgs = {\n  outputIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputtransactionArgs = {\n  txId?: InputMaybe<StringIdSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputvalueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  outputAddress?: InputMaybe<AddressSelector>;\n  outputDirection?: InputMaybe<CardanoOutputDirectionSelector>;\n  outputIndex?: InputMaybe<IntegerSelector>;\n  outputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction Output */\nexport type CardanoTransactionOutputvalueDecimalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<CardanoCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  inOutputIndex?: InputMaybe<IntegerSelector>;\n  inOutputTxId?: InputMaybe<HashSelector>;\n  inputAddress?: InputMaybe<AddressSelector>;\n  inputIndex?: InputMaybe<IntegerSelector>;\n  inputValue?: InputMaybe<FloatSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\nexport enum CardanoTransactionUniq {\n  /** Unique block count */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates'\n}\n\nexport enum CardanoTransactionsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Transaction deposit value */\n  deposit_value = 'deposit_value',\n  /** Input count */\n  input_count = 'input_count',\n  /** Transaction input value */\n  input_value = 'input_value',\n  /** Transaction mint count */\n  mint_count = 'mint_count',\n  /** Output count */\n  output_count = 'output_count',\n  /** Transaction output value */\n  output_value = 'output_value',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction index */\n  tx_index = 'tx_index',\n  /** Transaction size */\n  tx_size = 'tx_size',\n  /** Transaction withdrawal count */\n  withdrawal_count = 'withdrawal_count',\n  /** Transaction withdrawal value */\n  withdrawal_value = 'withdrawal_value'\n}\n\n/** Transaction attributes in coinpath */\nexport type CoinpathEntry = {\n  __typename?: 'CoinpathEntry';\n  /** Amount involved in the flow */\n  amount: Scalars['Float'];\n  /** Block of transaction */\n  height: Scalars['Int'];\n  /** Time of transaction in ISO 8601 format */\n  timestamp: Scalars['ISO8601DateTime'];\n  /** Hash of transaction */\n  txHash: Scalars['String'];\n  /** Amount transfered in transaction */\n  txValue: Scalars['Float'];\n};\n\nexport enum CoinpathMeasureable {\n  /** Block */\n  block = 'block',\n  /** Depth */\n  depth = 'depth',\n  /** Receiver */\n  receiver = 'receiver',\n  /** Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\n/** Limits, Ordering, Constraints, Coinpath Options */\nexport type CoinpathOptions = {\n  /** Ordering field(s) for ascending */\n  asc?: InputMaybe<Array<Scalars['String']>>;\n  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */\n  complexityLimit?: InputMaybe<Scalars['Int']>;\n  /** Ordering field(s) for descending */\n  desc?: InputMaybe<Array<Scalars['String']>>;\n  /** Flow direction */\n  direction?: InputMaybe<FlowDirection>;\n  /** Limit number of results */\n  limit?: InputMaybe<Scalars['Int']>;\n  /** Limit number of results by specific field */\n  limitBy?: InputMaybe<LimitByOption>;\n  /** Do not expand addresses having count transactions more than this */\n  maximumAddressTxCount?: InputMaybe<Scalars['Int']>;\n  /** Maximum total transaction count returned */\n  maximumTotalTxCount?: InputMaybe<Scalars['Int']>;\n  /** Do not include transactions below this amount */\n  minimumTxAmount?: InputMaybe<Scalars['Float']>;\n  /** Offset of results, starting from 0 */\n  offset?: InputMaybe<Scalars['Int']>;\n  /** Invalidating cache seed */\n  seed?: InputMaybe<Scalars['Int']>;\n};\n\n/** Conflux Chain */\nexport type Conflux = {\n  __typename?: 'Conflux';\n  /** Basic information about address ( or smart contract ) */\n  address: Array<EthereumAddressInfoWithBalance>;\n  /** Arguments of Smart Contract Calls and Events */\n  arguments?: Maybe<Array<EthereumArguments>>;\n  /** Blockchain Blocks */\n  blocks?: Maybe<Array<ConfluxBlocks>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<EthereumCoinpath>>;\n  /** Trades on Ethereum DEX Smart Contracts */\n  dexTrades?: Maybe<Array<EthereumDexTrades>>;\n  /** Smart Contract Calls */\n  smartContractCalls?: Maybe<Array<EthereumSmartContractCalls>>;\n  /** Smart Contract Events */\n  smartContractEvents?: Maybe<Array<EthereumSmartContractEvent>>;\n  /** Blockchain Transactions */\n  transactions?: Maybe<Array<ConfluxTransactions>>;\n  /** Currency Transfers */\n  transfers?: Maybe<Array<EthereumTransfers>>;\n};\n\n\n/** Conflux Chain */\nexport type ConfluxaddressArgs = {\n  address: Array<EthereumAddressSelectorIn>;\n};\n\n\n/** Conflux Chain */\nexport type ConfluxargumentsArgs = {\n  any?: InputMaybe<Array<EthereumArgumentFilter>>;\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  reference?: InputMaybe<Array<EthereumAddressSelector>>;\n  signatureType?: InputMaybe<SignatureTypeSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Conflux Chain */\nexport type ConfluxblocksArgs = {\n  any?: InputMaybe<Array<ConfluxBlockFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  options?: InputMaybe<QueryOptions>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Conflux Chain */\nexport type ConfluxcoinpathArgs = {\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<EthereumAddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CoinpathOptions>;\n  receiver?: InputMaybe<EthereumAddressSelector>;\n  sender?: InputMaybe<EthereumAddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Conflux Chain */\nexport type ConfluxdexTradesArgs = {\n  any?: InputMaybe<Array<EthereumDexTradeFilter>>;\n  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  options?: InputMaybe<QueryOptions>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  taker?: InputMaybe<Array<EthereumAddressSelector>>;\n  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Conflux Chain */\nexport type ConfluxsmartContractCallsArgs = {\n  any?: InputMaybe<Array<EthereumSmartContractCallFilter>>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Conflux Chain */\nexport type ConfluxsmartContractEventsArgs = {\n  any?: InputMaybe<Array<EthereumSmartContractEventFilter>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Conflux Chain */\nexport type ConfluxtransactionsArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<ConfluxTransactionFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Conflux Chain */\nexport type ConfluxtransfersArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<EthereumTransferFilter>>;\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<Array<EthereumAddressSelector>>;\n  sender?: InputMaybe<Array<EthereumAddressSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\nexport type ConfluxBlockFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocks = {\n  __typename?: 'ConfluxBlocks';\n  /** Block is adaptive */\n  adaptive: Scalars['Boolean'];\n  any?: Maybe<Scalars['String']>;\n  /** Blame */\n  blame: Scalars['Int'];\n  /** Block index in epoch */\n  blockPosition: Scalars['Int'];\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Epoch in blockchain */\n  epoch: Scalars['Int'];\n  /** Block hash */\n  hash: Scalars['String'];\n  /** Block height in blockchain */\n  height: Scalars['Int'];\n  maximum?: Maybe<Scalars['String']>;\n  /** Block miner */\n  miner?: Maybe<EthereumAddressInfo>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block nonce */\n  nonce: Scalars['Int'];\n  /** Parent block hash */\n  parentHash: Scalars['String'];\n  /** Block is pivot */\n  pivot: Scalars['Boolean'];\n  /** Power Quality */\n  powerQuality: Scalars['BigInt'];\n  refereeCount?: Maybe<Scalars['Int']>;\n  refereeCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Reference Block hash */\n  referenceBlockHash: Scalars['String'];\n  size?: Maybe<Scalars['Int']>;\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n  totalDifficulty?: Maybe<Scalars['Float']>;\n  transactionCount?: Maybe<Scalars['Int']>;\n  transactionCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Hash of Transaction included in block */\n  txHash: Scalars['String'];\n  uncleCount?: Maybe<Scalars['Int']>;\n  uncleCountBigInt?: Maybe<Scalars['BigInt']>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksanyArgs = {\n  of: ConfluxBlocksMeasureable;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlockscountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n  uniq?: InputMaybe<EthereumBlocksUniq>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlockscountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n  uniq?: InputMaybe<EthereumBlocksUniq>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksepochArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlockshashArgs = {\n  blockHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksmaximumArgs = {\n  get?: InputMaybe<ConfluxBlocksMeasureable>;\n  of: ConfluxBlocksMeasureable;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksminerArgs = {\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksminimumArgs = {\n  get?: InputMaybe<ConfluxBlocksMeasureable>;\n  of: ConfluxBlocksMeasureable;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksrefereeCountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksrefereeCountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksreferenceBlockHashArgs = {\n  referenceBlockHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlockssizeArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlockstimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlockstotalDifficultyArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlockstransactionCountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlockstransactionCountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlockstxHashArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksuncleCountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Conflux blockchain */\nexport type ConfluxBlocksuncleCountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<BlockSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  pivot?: InputMaybe<Scalars['Boolean']>;\n  refereeCount?: InputMaybe<Array<IntegerSelector>>;\n  referenceBlockHash?: InputMaybe<HashSelector>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\nexport enum ConfluxBlocksMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Block Miner */\n  miner = 'miner',\n  /** Block Referee Count */\n  referee_count = 'referee_count',\n  /** Time */\n  time = 'time',\n  /** Block TX Count */\n  transaction_count = 'transaction_count'\n}\n\nexport enum ConfluxNetwork {\n  /** Conflux Oceanus */\n  conflux_oceanus = 'conflux_oceanus',\n  /** Conflux Tethys */\n  conflux_tethys = 'conflux_tethys'\n}\n\nexport type ConfluxTransactionFilter = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactions = {\n  __typename?: 'ConfluxTransactions';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<BlockInfo>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Created smart contract */\n  creates?: Maybe<EthereumAddressInfo>;\n  /** Currency of amount */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Error message if any */\n  error?: Maybe<Scalars['String']>;\n  gas?: Maybe<Scalars['Int']>;\n  /** Currency of gas */\n  gasCurrency?: Maybe<Currency>;\n  /** Gas price in Gwei */\n  gasPrice: Scalars['Float'];\n  gasValue?: Maybe<Scalars['Float']>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0 based */\n  index?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transaction nonce */\n  nonce?: Maybe<Scalars['Int']>;\n  /** Transaction sender */\n  sender?: Maybe<EthereumAddressInfo>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Transaction receiver */\n  to?: Maybe<EthereumAddressInfo>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionsamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionsanyArgs = {\n  of: ConfluxTransactionsMeasureable;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionsblockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionscountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n  uniq?: InputMaybe<EthereumTransactionsUniq>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionscountBigIntArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n  uniq?: InputMaybe<EthereumTransactionsUniq>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionscreatesArgs = {\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionsgasArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionsgasCurrencyArgs = {\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionsgasPriceArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionsgasValueArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionshashArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionsindexArgs = {\n  txIndex?: InputMaybe<Array<TxIndexSelector>>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionsmaximumArgs = {\n  get?: InputMaybe<ConfluxTransactionsMeasureable>;\n  of: ConfluxTransactionsMeasureable;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionsminimumArgs = {\n  get?: InputMaybe<ConfluxTransactionsMeasureable>;\n  of: ConfluxTransactionsMeasureable;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionssenderArgs = {\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transactions in Conflux blockchain */\nexport type ConfluxTransactionstoArgs = {\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\nexport enum ConfluxTransactionsMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Gas used */\n  gas = 'gas',\n  /** Gas price */\n  gas_price = 'gas_price',\n  /** Gas value */\n  gas_value = 'gas_value',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction Sender */\n  tx_sender = 'tx_sender'\n}\n\nexport enum Continent {\n  /** Africa */\n  Africa = 'Africa',\n  /** Antarctica */\n  Antarctica = 'Antarctica',\n  /** Asia */\n  Asia = 'Asia',\n  /** Europe */\n  Europe = 'Europe',\n  /** North America */\n  North_America = 'North_America',\n  /** Oceania */\n  Oceania = 'Oceania',\n  /** South America */\n  South_America = 'South_America'\n}\n\n/** Continent selector */\nexport type ContinentSelector = {\n  /** Country code in the list */\n  in?: InputMaybe<Array<Continent>>;\n  /** Country code is */\n  is?: InputMaybe<Continent>;\n  /** Country code not */\n  not?: InputMaybe<Continent>;\n  /** Country code not in the list */\n  notIn?: InputMaybe<Array<Continent>>;\n};\n\nexport enum CountryCode {\n  /** Andorra */\n  AD = 'AD',\n  /** United Arab Emirates */\n  AE = 'AE',\n  /** Afghanistan */\n  AF = 'AF',\n  /** Antigua and Barbuda */\n  AG = 'AG',\n  /** Anguilla */\n  AI = 'AI',\n  /** Albania */\n  AL = 'AL',\n  /** Armenia */\n  AM = 'AM',\n  /** Netherlands Antilles */\n  AN = 'AN',\n  /** Angola */\n  AO = 'AO',\n  /** Antarctica */\n  AQ = 'AQ',\n  /** Argentina */\n  AR = 'AR',\n  /** American Samoa */\n  AS = 'AS',\n  /** Austria */\n  AT = 'AT',\n  /** Australia */\n  AU = 'AU',\n  /** Aruba */\n  AW = 'AW',\n  /** Azerbaijan */\n  AZ = 'AZ',\n  /** Bosnia and Herzegovina */\n  BA = 'BA',\n  /** Barbados */\n  BB = 'BB',\n  /** Bangladesh */\n  BD = 'BD',\n  /** Belgium */\n  BE = 'BE',\n  /** Burkina Faso */\n  BF = 'BF',\n  /** Bulgaria */\n  BG = 'BG',\n  /** Bahrain */\n  BH = 'BH',\n  /** Burundi */\n  BI = 'BI',\n  /** Benin */\n  BJ = 'BJ',\n  /** Saint Barthelemy */\n  BL = 'BL',\n  /** Bermuda */\n  BM = 'BM',\n  /** Brunei */\n  BN = 'BN',\n  /** Bolivia */\n  BO = 'BO',\n  /** Brazil */\n  BR = 'BR',\n  /** Bahamas */\n  BS = 'BS',\n  /** Bhutan */\n  BT = 'BT',\n  /** Botswana */\n  BW = 'BW',\n  /** Belarus */\n  BY = 'BY',\n  /** Belize */\n  BZ = 'BZ',\n  /** Canada */\n  CA = 'CA',\n  /** Cocos Islands */\n  CC = 'CC',\n  /** Democratic Republic of the Congo */\n  CD = 'CD',\n  /** Central African Republic */\n  CF = 'CF',\n  /** Republic of the Congo */\n  CG = 'CG',\n  /** Switzerland */\n  CH = 'CH',\n  /** Ivory Coast */\n  CI = 'CI',\n  /** Cook Islands */\n  CK = 'CK',\n  /** Chile */\n  CL = 'CL',\n  /** Cameroon */\n  CM = 'CM',\n  /** China */\n  CN = 'CN',\n  /** Colombia */\n  CO = 'CO',\n  /** Costa Rica */\n  CR = 'CR',\n  /** Cuba */\n  CU = 'CU',\n  /** Cape Verde */\n  CV = 'CV',\n  /** Curacao */\n  CW = 'CW',\n  /** Christmas Island */\n  CX = 'CX',\n  /** Cyprus */\n  CY = 'CY',\n  /** Czech Republic */\n  CZ = 'CZ',\n  /** Germany */\n  DE = 'DE',\n  /** Djibouti */\n  DJ = 'DJ',\n  /** Denmark */\n  DK = 'DK',\n  /** Dominica */\n  DM = 'DM',\n  /** Dominican Republic */\n  DO = 'DO',\n  /** Algeria */\n  DZ = 'DZ',\n  /** Ecuador */\n  EC = 'EC',\n  /** Estonia */\n  EE = 'EE',\n  /** Egypt */\n  EG = 'EG',\n  /** Western Sahara */\n  EH = 'EH',\n  /** Eritrea */\n  ER = 'ER',\n  /** Spain */\n  ES = 'ES',\n  /** Ethiopia */\n  ET = 'ET',\n  /** Finland */\n  FI = 'FI',\n  /** Fiji */\n  FJ = 'FJ',\n  /** Falkland Islands */\n  FK = 'FK',\n  /** Micronesia */\n  FM = 'FM',\n  /** Faroe Islands */\n  FO = 'FO',\n  /** France */\n  FR = 'FR',\n  /** Gabon */\n  GA = 'GA',\n  /** United Kingdom */\n  GB = 'GB',\n  /** Grenada */\n  GD = 'GD',\n  /** Georgia */\n  GE = 'GE',\n  /** Guernsey */\n  GG = 'GG',\n  /** Ghana */\n  GH = 'GH',\n  /** Gibraltar */\n  GI = 'GI',\n  /** Greenland */\n  GL = 'GL',\n  /** Gambia */\n  GM = 'GM',\n  /** Guinea */\n  GN = 'GN',\n  /** Equatorial Guinea */\n  GQ = 'GQ',\n  /** Greece */\n  GR = 'GR',\n  /** Guatemala */\n  GT = 'GT',\n  /** Guam */\n  GU = 'GU',\n  /** Guinea-Bissau */\n  GW = 'GW',\n  /** Guyana */\n  GY = 'GY',\n  /** Hong Kong */\n  HK = 'HK',\n  /** Honduras */\n  HN = 'HN',\n  /** Croatia */\n  HR = 'HR',\n  /** Haiti */\n  HT = 'HT',\n  /** Hungary */\n  HU = 'HU',\n  /** Indonesia */\n  ID = 'ID',\n  /** Ireland */\n  IE = 'IE',\n  /** Israel */\n  IL = 'IL',\n  /** Isle of Man */\n  IM = 'IM',\n  /** India */\n  IN = 'IN',\n  /** British Indian Ocean Territory */\n  IO = 'IO',\n  /** Iraq */\n  IQ = 'IQ',\n  /** Iran */\n  IR = 'IR',\n  /** Iceland */\n  IS = 'IS',\n  /** Italy */\n  IT = 'IT',\n  /** Jersey */\n  JE = 'JE',\n  /** Jamaica */\n  JM = 'JM',\n  /** Jordan */\n  JO = 'JO',\n  /** Japan */\n  JP = 'JP',\n  /** Kenya */\n  KE = 'KE',\n  /** Kyrgyzstan */\n  KG = 'KG',\n  /** Cambodia */\n  KH = 'KH',\n  /** Kiribati */\n  KI = 'KI',\n  /** Comoros */\n  KM = 'KM',\n  /** Saint Kitts and Nevis */\n  KN = 'KN',\n  /** North Korea */\n  KP = 'KP',\n  /** South Korea */\n  KR = 'KR',\n  /** Kuwait */\n  KW = 'KW',\n  /** Cayman Islands */\n  KY = 'KY',\n  /** Kazakhstan */\n  KZ = 'KZ',\n  /** Laos */\n  LA = 'LA',\n  /** Lebanon */\n  LB = 'LB',\n  /** Saint Lucia */\n  LC = 'LC',\n  /** Liechtenstein */\n  LI = 'LI',\n  /** Sri Lanka */\n  LK = 'LK',\n  /** Liberia */\n  LR = 'LR',\n  /** Lesotho */\n  LS = 'LS',\n  /** Lithuania */\n  LT = 'LT',\n  /** Luxembourg */\n  LU = 'LU',\n  /** Latvia */\n  LV = 'LV',\n  /** Libya */\n  LY = 'LY',\n  /** Morocco */\n  MA = 'MA',\n  /** Monaco */\n  MC = 'MC',\n  /** Moldova */\n  MD = 'MD',\n  /** Montenegro */\n  ME = 'ME',\n  /** Saint Martin */\n  MF = 'MF',\n  /** Madagascar */\n  MG = 'MG',\n  /** Marshall Islands */\n  MH = 'MH',\n  /** Macedonia */\n  MK = 'MK',\n  /** Mali */\n  ML = 'ML',\n  /** Myanmar */\n  MM = 'MM',\n  /** Mongolia */\n  MN = 'MN',\n  /** Macau */\n  MO = 'MO',\n  /** Northern Mariana Islands */\n  MP = 'MP',\n  /** Mauritania */\n  MR = 'MR',\n  /** Montserrat */\n  MS = 'MS',\n  /** Malta */\n  MT = 'MT',\n  /** Mauritius */\n  MU = 'MU',\n  /** Maldives */\n  MV = 'MV',\n  /** Malawi */\n  MW = 'MW',\n  /** Mexico */\n  MX = 'MX',\n  /** Malaysia */\n  MY = 'MY',\n  /** Mozambique */\n  MZ = 'MZ',\n  /** Namibia */\n  NA = 'NA',\n  /** New Caledonia */\n  NC = 'NC',\n  /** Niger */\n  NE = 'NE',\n  /** Nigeria */\n  NG = 'NG',\n  /** Nicaragua */\n  NI = 'NI',\n  /** Netherlands */\n  NL = 'NL',\n  /** Norway */\n  NO = 'NO',\n  /** Nepal */\n  NP = 'NP',\n  /** Nauru */\n  NR = 'NR',\n  /** Niue */\n  NU = 'NU',\n  /** New Zealand */\n  NZ = 'NZ',\n  /** Oman */\n  OM = 'OM',\n  /** Panama */\n  PA = 'PA',\n  /** Peru */\n  PE = 'PE',\n  /** French Polynesia */\n  PF = 'PF',\n  /** Papua New Guinea */\n  PG = 'PG',\n  /** Philippines */\n  PH = 'PH',\n  /** Pakistan */\n  PK = 'PK',\n  /** Poland */\n  PL = 'PL',\n  /** Saint Pierre and Miquelon */\n  PM = 'PM',\n  /** Pitcairn */\n  PN = 'PN',\n  /** Puerto Rico */\n  PR = 'PR',\n  /** Palestine */\n  PS = 'PS',\n  /** Portugal */\n  PT = 'PT',\n  /** Palau */\n  PW = 'PW',\n  /** Paraguay */\n  PY = 'PY',\n  /** Qatar */\n  QA = 'QA',\n  /** Reunion */\n  RE = 'RE',\n  /** Romania */\n  RO = 'RO',\n  /** Serbia */\n  RS = 'RS',\n  /** Russia */\n  RU = 'RU',\n  /** Rwanda */\n  RW = 'RW',\n  /** Saudi Arabia */\n  SA = 'SA',\n  /** Solomon Islands */\n  SB = 'SB',\n  /** Seychelles */\n  SC = 'SC',\n  /** Sudan */\n  SD = 'SD',\n  /** Sweden */\n  SE = 'SE',\n  /** Singapore */\n  SG = 'SG',\n  /** Saint Helena */\n  SH = 'SH',\n  /** Slovenia */\n  SI = 'SI',\n  /** Svalbard and Jan Mayen */\n  SJ = 'SJ',\n  /** Slovakia */\n  SK = 'SK',\n  /** Sierra Leone */\n  SL = 'SL',\n  /** San Marino */\n  SM = 'SM',\n  /** Senegal */\n  SN = 'SN',\n  /** Somalia */\n  SO = 'SO',\n  /** Suriname */\n  SR = 'SR',\n  /** South Sudan */\n  SS = 'SS',\n  /** Sao Tome and Principe */\n  ST = 'ST',\n  /** El Salvador */\n  SV = 'SV',\n  /** Sint Maarten */\n  SX = 'SX',\n  /** Syria */\n  SY = 'SY',\n  /** Swaziland */\n  SZ = 'SZ',\n  /** Turks and Caicos Islands */\n  TC = 'TC',\n  /** Chad */\n  TD = 'TD',\n  /** Togo */\n  TG = 'TG',\n  /** Thailand */\n  TH = 'TH',\n  /** Tajikistan */\n  TJ = 'TJ',\n  /** Tokelau */\n  TK = 'TK',\n  /** East Timor */\n  TL = 'TL',\n  /** Turkmenistan */\n  TM = 'TM',\n  /** Tunisia */\n  TN = 'TN',\n  /** Tonga */\n  TO = 'TO',\n  /** Turkey */\n  TR = 'TR',\n  /** Trinidad and Tobago */\n  TT = 'TT',\n  /** Tuvalu */\n  TV = 'TV',\n  /** Taiwan */\n  TW = 'TW',\n  /** Tanzania */\n  TZ = 'TZ',\n  /** Ukraine */\n  UA = 'UA',\n  /** Uganda */\n  UG = 'UG',\n  /** United States */\n  US = 'US',\n  /** Uruguay */\n  UY = 'UY',\n  /** Uzbekistan */\n  UZ = 'UZ',\n  /** Vatican */\n  VA = 'VA',\n  /** Saint Vincent and the Grenadines */\n  VC = 'VC',\n  /** Venezuela */\n  VE = 'VE',\n  /** British Virgin Islands */\n  VG = 'VG',\n  /** U.S. Virgin Islands */\n  VI = 'VI',\n  /** Vietnam */\n  VN = 'VN',\n  /** Vanuatu */\n  VU = 'VU',\n  /** Wallis and Futuna */\n  WF = 'WF',\n  /** Samoa */\n  WS = 'WS',\n  /** Kosovo */\n  XK = 'XK',\n  /** Yemen */\n  YE = 'YE',\n  /** Mayotte */\n  YT = 'YT',\n  /** South Africa */\n  ZA = 'ZA',\n  /** Zambia */\n  ZM = 'ZM',\n  /** Zimbabwe */\n  ZW = 'ZW'\n}\n\n/** Country selector by 3 digit ISO code */\nexport type CountrySelector = {\n  /** Country code in the list */\n  in?: InputMaybe<Array<CountryCode>>;\n  /** Country code is */\n  is?: InputMaybe<CountryCode>;\n  /** Country code not */\n  not?: InputMaybe<CountryCode>;\n  /** Country code not in the list */\n  notIn?: InputMaybe<Array<CountryCode>>;\n};\n\n/** Country */\nexport type CovidCountry = {\n  __typename?: 'CovidCountry';\n  /** Area, km2 */\n  areaKm2?: Maybe<Scalars['Float']>;\n  /** Continent name */\n  continent?: Maybe<Continent>;\n  /** Gross Domestic Product */\n  gdp?: Maybe<Scalars['Float']>;\n  /** ISO 2 letter code */\n  iso2?: Maybe<CountryCode>;\n  /** ISO 3 letter code */\n  iso3?: Maybe<Scalars['String']>;\n  /** ISO numeric code */\n  isoNumeric?: Maybe<Scalars['Int']>;\n  /** Location latitude */\n  latitude?: Maybe<Scalars['Float']>;\n  /** Location longitude */\n  longitude?: Maybe<Scalars['Float']>;\n  /** Country name */\n  name?: Maybe<Scalars['String']>;\n  /** Population density in thousands per km2 */\n  populationPerKm2?: Maybe<Scalars['Float']>;\n  /** Population total in thousands */\n  populationTotal?: Maybe<Scalars['Float']>;\n};\n\n/** Facts of Covid virus development */\nexport type CovidFact = {\n  __typename?: 'CovidFact';\n  /** Count of confirmed cases */\n  confirmed?: Maybe<Scalars['Int']>;\n  /** Country */\n  country?: Maybe<CovidCountry>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Count of death cases */\n  deaths?: Maybe<Scalars['Int']>;\n  /** Location */\n  location?: Maybe<CovidLocation>;\n  /** Count of recovered cases */\n  recovered?: Maybe<Scalars['Int']>;\n};\n\n\n/** Facts of Covid virus development */\nexport type CovidFactconfirmedArgs = {\n  continent?: InputMaybe<ContinentSelector>;\n  country?: InputMaybe<CountrySelector>;\n  date?: InputMaybe<DateSelector>;\n};\n\n\n/** Facts of Covid virus development */\nexport type CovidFactcountryArgs = {\n  continent?: InputMaybe<ContinentSelector>;\n  country?: InputMaybe<CountrySelector>;\n};\n\n\n/** Facts of Covid virus development */\nexport type CovidFactdeathsArgs = {\n  continent?: InputMaybe<ContinentSelector>;\n  country?: InputMaybe<CountrySelector>;\n  date?: InputMaybe<DateSelector>;\n};\n\n\n/** Facts of Covid virus development */\nexport type CovidFactrecoveredArgs = {\n  continent?: InputMaybe<ContinentSelector>;\n  country?: InputMaybe<CountrySelector>;\n  date?: InputMaybe<DateSelector>;\n};\n\n/** Covid History */\nexport type CovidHistory = {\n  __typename?: 'CovidHistory';\n  /** COVID daily facts */\n  facts?: Maybe<Array<CovidFact>>;\n};\n\n\n/** Covid History */\nexport type CovidHistoryfactsArgs = {\n  continent?: InputMaybe<ContinentSelector>;\n  country?: InputMaybe<CountrySelector>;\n  date?: InputMaybe<DateSelector>;\n  options?: InputMaybe<QueryOptions>;\n};\n\n/** Geo Location */\nexport type CovidLocation = {\n  __typename?: 'CovidLocation';\n  /** Admin center name */\n  adminCenter?: Maybe<Scalars['String']>;\n  /** FIPS code for USA */\n  fipsCode?: Maybe<Scalars['Int']>;\n  /** Location latitude */\n  latitude?: Maybe<Scalars['Float']>;\n  /** Location longitude */\n  longitude?: Maybe<Scalars['Float']>;\n  /** Location Country name */\n  name?: Maybe<Scalars['String']>;\n  /** Location Province / State name */\n  province?: Maybe<Scalars['String']>;\n};\n\n/** Crypto currency ( token, coin, currency ) */\nexport type Currency = {\n  __typename?: 'Currency';\n  /** Token Smart Contract Address */\n  address?: Maybe<Scalars['String']>;\n  /** Decimals */\n  decimals: Scalars['Int'];\n  /** Currency name */\n  name?: Maybe<Scalars['String']>;\n  /** Currency symbol */\n  symbol: Scalars['String'];\n  /** Token ID */\n  tokenId?: Maybe<Scalars['String']>;\n  /** Token Type */\n  tokenType?: Maybe<Scalars['String']>;\n};\n\n/** Currency selector */\nexport type CurrencySelector = {\n  /** Currency in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Currency is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Currency not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Currency not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Instruction Data */\nexport type Data = {\n  __typename?: 'Data';\n  base58: Scalars['String'];\n  hex: Scalars['String'];\n};\n\n/** Date */\nexport type Date = {\n  __typename?: 'Date';\n  /** String date representation with default format as YYYY-MM-DD */\n  date: Scalars['String'];\n  /** Day of month (1-31) */\n  dayOfMonth: Scalars['Int'];\n  /** Day of week  (Monday is 1, and Sunday is 7) */\n  dayOfWeek: Scalars['Int'];\n  /** Month number (1-12) */\n  month: Scalars['Int'];\n  /**\n   * Returns start of date interval ,\n   *     date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,\n   *   starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'\n   */\n  startOfInterval: Scalars['String'];\n  /** Year number */\n  year: Scalars['Int'];\n};\n\n\n/** Date */\nexport type DatedateArgs = {\n  format?: InputMaybe<Scalars['String']>;\n};\n\n\n/** Date */\nexport type DatestartOfIntervalArgs = {\n  format?: InputMaybe<Scalars['String']>;\n  interval?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  unit: DateInterval;\n};\n\nexport enum DateInterval {\n  /** Day */\n  day = 'day',\n  /** Month */\n  month = 'month',\n  /** Week */\n  week = 'week',\n  /** Year */\n  year = 'year'\n}\n\n/** Selecting the date in a range, list or just date */\nexport type DateSelector = {\n  /** After date */\n  after?: InputMaybe<Scalars['ISO8601DateTime']>;\n  /** Before date */\n  before?: InputMaybe<Scalars['ISO8601DateTime']>;\n  /** Range of dates */\n  between?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;\n  /** In dates */\n  in?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;\n  /** Date equals */\n  is?: InputMaybe<Scalars['ISO8601DateTime']>;\n  /** Date not equals */\n  not?: InputMaybe<Scalars['ISO8601DateTime']>;\n  /** Not in dates */\n  notIn?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;\n  /** Since date */\n  since?: InputMaybe<Scalars['ISO8601DateTime']>;\n  /** Till date */\n  till?: InputMaybe<Scalars['ISO8601DateTime']>;\n};\n\n/** Date and Time */\nexport type DateTime = {\n  __typename?: 'DateTime';\n  /** Day of month (1-31) */\n  dayOfMonth: Scalars['Int'];\n  /** Day of week  (Monday is 1, and Sunday is 7) */\n  dayOfWeek: Scalars['Int'];\n  /** Hour (0-23) */\n  hour: Scalars['Int'];\n  /** ISO8601 date time such as '2020-03-02T13:30:41+00:00' */\n  iso8601: Scalars['ISO8601DateTime'];\n  /** Minute (0-59) */\n  minute: Scalars['Int'];\n  /** Month number (1-12) */\n  month: Scalars['Int'];\n  /** Second (0-59) */\n  second: Scalars['Int'];\n  /** String date representation with default format as YYYY-MM-DD */\n  time: Scalars['String'];\n  /** Unix timestamp */\n  unixtime: Scalars['Int'];\n  /** Year number */\n  year: Scalars['Int'];\n};\n\n\n/** Date and Time */\nexport type DateTimetimeArgs = {\n  format?: InputMaybe<Scalars['String']>;\n};\n\n/** Selecting the time in a range, list or just time */\nexport type DateTimeSelector = {\n  /** After time */\n  after?: InputMaybe<Scalars['ISO8601DateTime']>;\n  /** Before time */\n  before?: InputMaybe<Scalars['ISO8601DateTime']>;\n  /** Range of time */\n  between?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;\n  /** In times */\n  in?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;\n  /** Time equals */\n  is?: InputMaybe<Scalars['ISO8601DateTime']>;\n  /** Time not equals */\n  not?: InputMaybe<Scalars['ISO8601DateTime']>;\n  /** Not in times */\n  notIn?: InputMaybe<Array<Scalars['ISO8601DateTime']>>;\n  /** Since time */\n  since?: InputMaybe<Scalars['ISO8601DateTime']>;\n  /** Till time */\n  till?: InputMaybe<Scalars['ISO8601DateTime']>;\n};\n\nexport enum DiemNetwork {\n  /** Diem Testnet */\n  diem_testnet = 'diem_testnet',\n  /** Libra Testnet */\n  libra_testnet = 'libra_testnet'\n}\n\n/** Elrond Chain */\nexport type Elrond = {\n  __typename?: 'Elrond';\n  /** Arguments of Smart Contract Calls and Events */\n  arguments?: Maybe<Array<ElrondArgument>>;\n  /** Information about validators of the block */\n  blockValidators?: Maybe<Array<ElrondBlockValidator>>;\n  /** Information about blocks */\n  blocks?: Maybe<Array<ElrondBlock>>;\n  /** Information about calls */\n  callResults?: Maybe<Array<ElrondCallResult>>;\n  /** Information about calls */\n  calls?: Maybe<Array<ElrondCall>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<ElrondCoinpath>>;\n  /** Information about miniblocks */\n  miniblocks?: Maybe<Array<ElrondMiniblock>>;\n  /** Information about notarized block */\n  notarizedBlock?: Maybe<Array<ElrondNotarizedBlock>>;\n  /** Information about transactions */\n  transactions?: Maybe<Array<ElrondTransaction>>;\n  /** Information about transactions */\n  transfers?: Maybe<Array<ElrondTransfer>>;\n};\n\n\n/** Elrond Chain */\nexport type ElrondargumentsArgs = {\n  any?: InputMaybe<Array<ElrondArgumentFilter>>;\n  argumentIndex?: InputMaybe<IntegerSelector>;\n  argumentValue?: InputMaybe<IntIdSelector>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  callDepth?: InputMaybe<IntegerSelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  options?: InputMaybe<QueryOptions>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  smartContractAddress?: InputMaybe<HashSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Elrond Chain */\nexport type ElrondblockValidatorsArgs = {\n  any?: InputMaybe<Array<ElrondBlockValidatorFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  validator?: InputMaybe<HashSelector>;\n};\n\n\n/** Elrond Chain */\nexport type ElrondblocksArgs = {\n  any?: InputMaybe<Array<ElrondBlockFilter>>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  options?: InputMaybe<QueryOptions>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<IntegerSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Elrond Chain */\nexport type ElrondcallResultsArgs = {\n  any?: InputMaybe<Array<ElrondCallResultFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  callResultData?: InputMaybe<StringSelector>;\n  callResultDataOperation?: InputMaybe<StringSelector>;\n  callResultGasLimit?: InputMaybe<FloatSelector>;\n  callResultGasPrice?: InputMaybe<FloatSelector>;\n  callResultHash?: InputMaybe<HashSelector>;\n  callResultIndex?: InputMaybe<IntegerSelector>;\n  callResultNonce?: InputMaybe<IntegerSelector>;\n  callResultReceiver?: InputMaybe<HashSelector>;\n  callResultRelayedValue?: InputMaybe<FloatSelector>;\n  callResultSender?: InputMaybe<HashSelector>;\n  callResultType?: InputMaybe<StringSelector>;\n  callResultValue?: InputMaybe<FloatSelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  options?: InputMaybe<QueryOptions>;\n  originTxHash?: InputMaybe<HashSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  previousTxHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  relayed?: InputMaybe<StringSelector>;\n  returnMessage?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Elrond Chain */\nexport type ElrondcallsArgs = {\n  any?: InputMaybe<Array<ElrondCallFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  callDepth?: InputMaybe<StringSelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  options?: InputMaybe<QueryOptions>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  smartContractAddress?: InputMaybe<HashSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Elrond Chain */\nexport type ElrondcoinpathArgs = {\n  currency?: InputMaybe<CurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<AddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CoinpathOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Elrond Chain */\nexport type ElrondminiblocksArgs = {\n  any?: InputMaybe<Array<ElrondMiniblockFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  options?: InputMaybe<QueryOptions>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  receiverBlockHash?: InputMaybe<HashSelector>;\n  receiverShard?: InputMaybe<BigIntIdSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Elrond Chain */\nexport type ElrondnotarizedBlockArgs = {\n  any?: InputMaybe<Array<ElrondNotarizedBlockFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  notarizedBlockHash?: InputMaybe<HashSelector>;\n  options?: InputMaybe<QueryOptions>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Elrond Chain */\nexport type ElrondtransactionsArgs = {\n  any?: InputMaybe<Array<ElrondTransactionFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  fee?: InputMaybe<FloatSelector>;\n  gasLimit?: InputMaybe<FloatSelector>;\n  gasPrice?: InputMaybe<FloatSelector>;\n  gasUsed?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  options?: InputMaybe<QueryOptions>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txNonce?: InputMaybe<IntegerSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  txValue?: InputMaybe<FloatSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Elrond Chain */\nexport type ElrondtransfersArgs = {\n  any?: InputMaybe<Array<ElrondTransferFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  currency?: InputMaybe<CurrencySelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  metadata?: InputMaybe<StringSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nftNonce?: InputMaybe<IntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  options?: InputMaybe<QueryOptions>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  transferReason?: InputMaybe<TransferReasonSelector>;\n  transferReceiver?: InputMaybe<AddressSelector>;\n  transferSender?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n/** Blockchain address hash */\nexport type ElrondAddressHash = {\n  __typename?: 'ElrondAddressHash';\n  /** String hex address representation */\n  hex: Scalars['String'];\n};\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgument = {\n  __typename?: 'ElrondArgument';\n  any?: Maybe<Scalars['String']>;\n  /** Information about arguments call */\n  call?: Maybe<CallElrond>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Index of the argument */\n  index?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Information about arguments miniblock */\n  miniblock?: Maybe<MiniblockElrond>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Information about arguments block */\n  senderBlock?: Maybe<ElrondBlockDimension>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Information about arguments transaction */\n  transaction?: Maybe<TransactionElrond>;\n  /** Value of the argument */\n  value?: Maybe<Scalars['String']>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumentanyArgs = {\n  of: ElrondArgumentsMeasureable;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumentcallArgs = {\n  callDepth?: InputMaybe<IntegerSelector>;\n  smartContractAddress?: InputMaybe<HashSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumentcountArgs = {\n  uniq?: InputMaybe<ElrondArgumentUniq>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumentcountBigIntArgs = {\n  uniq?: InputMaybe<ElrondArgumentUniq>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumentindexArgs = {\n  argumentIndex?: InputMaybe<IntIdSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumentmaximumArgs = {\n  get?: InputMaybe<ElrondArgumentsMeasureable>;\n  of: ElrondArgumentsMeasureable;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumentminiblockArgs = {\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumentminimumArgs = {\n  get?: InputMaybe<ElrondArgumentsMeasureable>;\n  of: ElrondArgumentsMeasureable;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumentsenderBlockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumenttransactionArgs = {\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  signature?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type ElrondArgumentvalueArgs = {\n  argumentValue?: InputMaybe<StringSelector>;\n};\n\nexport type ElrondArgumentFilter = {\n  argumentIndex?: InputMaybe<IntegerSelector>;\n  argumentValue?: InputMaybe<IntIdSelector>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  callDepth?: InputMaybe<IntegerSelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  smartContractAddress?: InputMaybe<HashSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\nexport enum ElrondArgumentUniq {\n  /** Unique number of arguments */\n  argument_index = 'argument_index',\n  /** Unique Number of block in the blockchains */\n  block_height = 'block_height',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Transaction Hash */\n  signature = 'signature',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum ElrondArgumentsMeasureable {\n  /** Argument Index */\n  argument_index = 'argument_index',\n  /** Argument Value */\n  argument_value = 'argument_value',\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Smart Contract call path */\n  call_depth = 'call_depth',\n  /** Data */\n  data = 'data',\n  /** Date */\n  date = 'date',\n  /** Gas Limit */\n  gas_limit = 'gas_limit',\n  /** Gas Price */\n  gas_price = 'gas_price',\n  /** Gas Used */\n  gas_used = 'gas_used',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** Hash of the miniblock */\n  miniblock_hash = 'miniblock_hash',\n  /** Hash of the miniblocks receiver block */\n  miniblock_receiver_block_hash = 'miniblock_receiver_block_hash',\n  /** Miniblock receiver shard */\n  miniblock_receiver_shard = 'miniblock_receiver_shard',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Smart Contract Address */\n  smart_contract_address = 'smart_contract_address',\n  /** Time */\n  time = 'time',\n  /** The block hash of this block`s parent */\n  transaction_count = 'transaction_count',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Receiver hash */\n  tx_receiver = 'tx_receiver',\n  /** Shard number of the receiver */\n  tx_receiver_shard = 'tx_receiver_shard',\n  /** Sender hash */\n  tx_sender = 'tx_sender',\n  /** Shard number of the sender */\n  tx_sender_shard = 'tx_sender_shard',\n  /** Transaction Signature */\n  tx_signature = 'tx_signature',\n  /** Value */\n  tx_value = 'tx_value',\n  /** Type of miniblock */\n  type = 'type'\n}\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlock = {\n  __typename?: 'ElrondBlock';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Epoch */\n  epoch?: Maybe<Scalars['Int']>;\n  /** Hash of the the block */\n  hash?: Maybe<Scalars['String']>;\n  /** Number of block in the blockchains */\n  height?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block Height */\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** The block hash of this block`s parent */\n  previousBlockHash?: Maybe<Scalars['String']>;\n  /** Proposer block hash */\n  proposer?: Maybe<ElrondAddressHash>;\n  /** Public Key Bitmap */\n  publicKeyBitmap?: Maybe<Scalars['String']>;\n  /** Round */\n  round?: Maybe<Scalars['BigInt']>;\n  /** Shard number of block */\n  shard?: Maybe<Scalars['String']>;\n  /** Size */\n  size?: Maybe<Scalars['Int']>;\n  /** Size Tx */\n  sizeTxs?: Maybe<Scalars['Int']>;\n  /** State root hash */\n  stateRootHash?: Maybe<Scalars['String']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Count of transactions in this block */\n  transactionCount?: Maybe<Scalars['BigInt']>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockanyArgs = {\n  of: ElrondBlocksMeasureable;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockcountArgs = {\n  uniq?: InputMaybe<ElrondBlockUniq>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockcountBigIntArgs = {\n  uniq?: InputMaybe<ElrondBlockUniq>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockepochArgs = {\n  epoch?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockhashArgs = {\n  hash?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockmaximumArgs = {\n  get?: InputMaybe<ElrondBlocksMeasureable>;\n  of: ElrondBlocksMeasureable;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockminimumArgs = {\n  get?: InputMaybe<ElrondBlocksMeasureable>;\n  of: ElrondBlocksMeasureable;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlocknonceArgs = {\n  nonce?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockpreviousBlockHashArgs = {\n  previousBlockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockproposerArgs = {\n  proposer?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockpublicKeyBitmapArgs = {\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockroundArgs = {\n  round?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockshardArgs = {\n  shard?: InputMaybe<BigIntIdSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlocksizeArgs = {\n  size?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlocksizeTxsArgs = {\n  sizeTxs?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlockstateRootHashArgs = {\n  stateRootHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Elrond  blockchain */\nexport type ElrondBlocktransactionCountArgs = {\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n/** Information about block */\nexport type ElrondBlockDimension = {\n  __typename?: 'ElrondBlockDimension';\n  /** Epoch */\n  epoch?: Maybe<Scalars['Int']>;\n  /** Hash of the block */\n  hash?: Maybe<Scalars['String']>;\n  /** Number of block in the blockchains */\n  height?: Maybe<Scalars['BigInt']>;\n  /** Block Height */\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** The block hash of this block`s parent */\n  previousBlockHash?: Maybe<Scalars['String']>;\n  /** Proposer block hash */\n  proposer?: Maybe<ElrondAddressHash>;\n  /** Public Key Bitmap */\n  publicKeyBitmap?: Maybe<Scalars['String']>;\n  /** Round */\n  round?: Maybe<Scalars['BigInt']>;\n  /** Shard number of block */\n  shard?: Maybe<Scalars['String']>;\n  /** Size */\n  size?: Maybe<Scalars['Int']>;\n  /** Size Tx */\n  sizeTxs?: Maybe<Scalars['Int']>;\n  /** State root hash */\n  stateRootHash?: Maybe<Scalars['String']>;\n  /** Count of transactions in this block */\n  transactionCount?: Maybe<Scalars['BigInt']>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionepochArgs = {\n  epoch?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionhashArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionnonceArgs = {\n  blockNonce?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionpreviousBlockHashArgs = {\n  previousBlockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionproposerArgs = {\n  proposer?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionpublicKeyBitmapArgs = {\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionroundArgs = {\n  round?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionshardArgs = {\n  shard?: InputMaybe<IntIdSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionsizeArgs = {\n  size?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionsizeTxsArgs = {\n  sizeTxs?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensionstateRootHashArgs = {\n  stateRootHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about block */\nexport type ElrondBlockDimensiontransactionCountArgs = {\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\nexport type ElrondBlockFilter = {\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<IntegerSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\nexport enum ElrondBlockUniq {\n  /** Unique Number of Shards in the blockchains */\n  block_shard = 'block_shard',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Number of block in the blockchains */\n  height = 'height',\n  /** Unique time */\n  times = 'times'\n}\n\n/** BlockValidators in Elrond  blockchain */\nexport type ElrondBlockValidator = {\n  __typename?: 'ElrondBlockValidator';\n  any?: Maybe<Scalars['String']>;\n  /** Information about blocks notarized block */\n  block?: Maybe<ElrondBlockDimension>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Hash of validator */\n  validator?: Maybe<ElrondAddressHash>;\n};\n\n\n/** BlockValidators in Elrond  blockchain */\nexport type ElrondBlockValidatoranyArgs = {\n  of: ElrondBlockValidatorsMeasureable;\n};\n\n\n/** BlockValidators in Elrond  blockchain */\nexport type ElrondBlockValidatorblockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** BlockValidators in Elrond  blockchain */\nexport type ElrondBlockValidatorcountArgs = {\n  uniq?: InputMaybe<ElrondBlockValidatorUniq>;\n};\n\n\n/** BlockValidators in Elrond  blockchain */\nexport type ElrondBlockValidatorcountBigIntArgs = {\n  uniq?: InputMaybe<ElrondBlockValidatorUniq>;\n};\n\n\n/** BlockValidators in Elrond  blockchain */\nexport type ElrondBlockValidatormaximumArgs = {\n  get?: InputMaybe<ElrondBlockValidatorsMeasureable>;\n  of: ElrondBlockValidatorsMeasureable;\n};\n\n\n/** BlockValidators in Elrond  blockchain */\nexport type ElrondBlockValidatorminimumArgs = {\n  get?: InputMaybe<ElrondBlockValidatorsMeasureable>;\n  of: ElrondBlockValidatorsMeasureable;\n};\n\n\n/** BlockValidators in Elrond  blockchain */\nexport type ElrondBlockValidatorvalidatorArgs = {\n  validator?: InputMaybe<HashSelector>;\n};\n\nexport type ElrondBlockValidatorFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  validator?: InputMaybe<HashSelector>;\n};\n\nexport enum ElrondBlockValidatorUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Number of block in the blockchains */\n  height = 'height',\n  /** Unique time */\n  times = 'times',\n  /** Unique number of validators */\n  validators = 'validators'\n}\n\nexport enum ElrondBlockValidatorsMeasureable {\n  /** Date */\n  date = 'date',\n  /** Block epoch */\n  epoch = 'epoch',\n  /** Hash of the the block */\n  hash = 'hash',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** Block nonce */\n  nonce = 'nonce',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Block proposer */\n  proposer = 'proposer',\n  /** Block public key bitmap */\n  public_key_bitmap = 'public_key_bitmap',\n  /** Block round */\n  round = 'round',\n  /** Shard number of block */\n  shard = 'shard',\n  /** Block size */\n  size = 'size',\n  /** Block size txs */\n  size_txs = 'size_txs',\n  /** State root hash */\n  state_root_hash = 'state_root_hash',\n  /** Time */\n  time = 'time',\n  /** Count of transactions in this block */\n  transaction_count = 'transaction_count',\n  /** Hash of the validator */\n  validator = 'validator'\n}\n\nexport enum ElrondBlocksMeasureable {\n  /** Date */\n  date = 'date',\n  /** Block epoch */\n  epoch = 'epoch',\n  /** Hash of the the block */\n  hash = 'hash',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** Block nonce */\n  nonce = 'nonce',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Block proposer */\n  proposer = 'proposer',\n  /** Block public key bitmap */\n  public_key_bitmap = 'public_key_bitmap',\n  /** Block round */\n  round = 'round',\n  /** Shard number of block */\n  shard = 'shard',\n  /** Block size */\n  size = 'size',\n  /** Block size txs */\n  size_txs = 'size_txs',\n  /** State root hash */\n  state_root_hash = 'state_root_hash',\n  /** Time */\n  time = 'time',\n  /** Count of transactions in this block */\n  transaction_count = 'transaction_count'\n}\n\n/** Calls in Elrond blockchain */\nexport type ElrondCall = {\n  __typename?: 'ElrondCall';\n  any?: Maybe<Scalars['String']>;\n  /**\n   * Depth of the call. Empty string for external call, then counted\n   *         as 0...N, and the next layer is added through '-'. For example 0-3-9.\n   */\n  callDepth?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Information about calls miniblock */\n  miniblock?: Maybe<MiniblockElrond>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Information about calls block */\n  senderBlock?: Maybe<ElrondBlockDimension>;\n  /** Contract method invoked */\n  smartContractAddress?: Maybe<Address>;\n  /** Contract method invoked */\n  smartContractMethod?: Maybe<Method>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Information about calls transaction */\n  transaction?: Maybe<TransactionElrond>;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCallanyArgs = {\n  of: ElrondCallsMeasureable;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCallcallDepthArgs = {\n  callDepth?: InputMaybe<StringSelector>;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCallcountArgs = {\n  uniq?: InputMaybe<ElrondCallsUni>;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCallcountBigIntArgs = {\n  uniq?: InputMaybe<ElrondCallsUni>;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCallmaximumArgs = {\n  get?: InputMaybe<ElrondCallsMeasureable>;\n  of: ElrondCallsMeasureable;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCallminiblockArgs = {\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCallminimumArgs = {\n  get?: InputMaybe<ElrondCallsMeasureable>;\n  of: ElrondCallsMeasureable;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCallsenderBlockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCallsmartContractAddressArgs = {\n  smartContractAddress?: InputMaybe<HashSelector>;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCallsmartContractMethodArgs = {\n  smartContractMethod?: InputMaybe<MethodSelector>;\n};\n\n\n/** Calls in Elrond blockchain */\nexport type ElrondCalltransactionArgs = {\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  signature?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n};\n\nexport type ElrondCallFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  callDepth?: InputMaybe<StringSelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  smartContractAddress?: InputMaybe<HashSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResult = {\n  __typename?: 'ElrondCallResult';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Call result data */\n  data?: Maybe<Scalars['String']>;\n  /** Call result data operation */\n  dataOperation?: Maybe<Scalars['String']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Call result gas limit */\n  gasLimit?: Maybe<Scalars['BigInt']>;\n  /** Call result gas price */\n  gasPrice?: Maybe<Scalars['BigInt']>;\n  /** Hash of the call result */\n  hash?: Maybe<Scalars['String']>;\n  /** Call result index */\n  index?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Information about calls miniblock */\n  miniblock?: Maybe<MiniblockElrond>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Nonce of the call result */\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** Hash of the origin transaction */\n  originTxHash?: Maybe<Scalars['String']>;\n  /** Hash of the previous transaction */\n  previousTxHash?: Maybe<Scalars['String']>;\n  /** Call result receiver */\n  receiver?: Maybe<Address>;\n  /** Call result relayed */\n  relayed?: Maybe<Scalars['String']>;\n  relayedValue?: Maybe<Scalars['Float']>;\n  /** Call result return message */\n  returnMessage?: Maybe<Scalars['String']>;\n  /** Call result sender */\n  sender?: Maybe<Address>;\n  /** Information about calls block */\n  senderBlock?: Maybe<ElrondBlockDimension>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Information about calls transaction */\n  transaction?: Maybe<TransactionElrond>;\n  /** Call result type */\n  type?: Maybe<Scalars['String']>;\n  value?: Maybe<Scalars['Float']>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultanyArgs = {\n  of: ElrondCallResultsMeasureable;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultcountArgs = {\n  uniq?: InputMaybe<ElrondCallResultUniq>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultcountBigIntArgs = {\n  uniq?: InputMaybe<ElrondCallResultUniq>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultdataArgs = {\n  callResultData?: InputMaybe<StringSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultdataOperationArgs = {\n  callResultDataOperation?: InputMaybe<StringSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultgasLimitArgs = {\n  callResultGasLimit?: InputMaybe<IntegerSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultgasPriceArgs = {\n  callResultGasPrice?: InputMaybe<IntegerSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResulthashArgs = {\n  callResultHash?: InputMaybe<HashSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultindexArgs = {\n  callResultIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultmaximumArgs = {\n  get?: InputMaybe<ElrondCallResultsMeasureable>;\n  of: ElrondCallResultsMeasureable;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultminiblockArgs = {\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultminimumArgs = {\n  get?: InputMaybe<ElrondCallResultsMeasureable>;\n  of: ElrondCallResultsMeasureable;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultnonceArgs = {\n  callResultNonce?: InputMaybe<IntegerSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultoriginTxHashArgs = {\n  originTxHash?: InputMaybe<HashSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultpreviousTxHashArgs = {\n  previousTxHash?: InputMaybe<HashSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultreceiverArgs = {\n  callResultReceiver?: InputMaybe<HashSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultrelayedArgs = {\n  relayed?: InputMaybe<StringSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultrelayedValueArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  callResultData?: InputMaybe<StringSelector>;\n  callResultDataOperation?: InputMaybe<StringSelector>;\n  callResultGasLimit?: InputMaybe<FloatSelector>;\n  callResultGasPrice?: InputMaybe<FloatSelector>;\n  callResultHash?: InputMaybe<HashSelector>;\n  callResultIndex?: InputMaybe<IntegerSelector>;\n  callResultNonce?: InputMaybe<IntegerSelector>;\n  callResultReceiver?: InputMaybe<HashSelector>;\n  callResultRelayedValue?: InputMaybe<FloatSelector>;\n  callResultSender?: InputMaybe<HashSelector>;\n  callResultType?: InputMaybe<StringSelector>;\n  callResultValue?: InputMaybe<FloatSelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  index?: InputMaybe<IntegerSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  originTxHash?: InputMaybe<HashSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  previousTxHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  relayed?: InputMaybe<StringSelector>;\n  returnMessage?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultreturnMessageArgs = {\n  returnMessage?: InputMaybe<StringSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultsenderArgs = {\n  callResultSender?: InputMaybe<HashSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultsenderBlockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResulttransactionArgs = {\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  signature?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResulttypeArgs = {\n  callResultType?: InputMaybe<StringSelector>;\n};\n\n\n/** CallResults in Elrond blockchain */\nexport type ElrondCallResultvalueArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  callResultData?: InputMaybe<StringSelector>;\n  callResultDataOperation?: InputMaybe<StringSelector>;\n  callResultGasLimit?: InputMaybe<FloatSelector>;\n  callResultGasPrice?: InputMaybe<FloatSelector>;\n  callResultHash?: InputMaybe<HashSelector>;\n  callResultIndex?: InputMaybe<IntegerSelector>;\n  callResultNonce?: InputMaybe<IntegerSelector>;\n  callResultReceiver?: InputMaybe<HashSelector>;\n  callResultRelayedValue?: InputMaybe<FloatSelector>;\n  callResultSender?: InputMaybe<HashSelector>;\n  callResultType?: InputMaybe<StringSelector>;\n  callResultValue?: InputMaybe<FloatSelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  index?: InputMaybe<IntegerSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  originTxHash?: InputMaybe<HashSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  previousTxHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  relayed?: InputMaybe<StringSelector>;\n  returnMessage?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\nexport type ElrondCallResultFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  callResultData?: InputMaybe<StringSelector>;\n  callResultDataOperation?: InputMaybe<StringSelector>;\n  callResultGasLimit?: InputMaybe<FloatSelector>;\n  callResultGasPrice?: InputMaybe<FloatSelector>;\n  callResultHash?: InputMaybe<HashSelector>;\n  callResultIndex?: InputMaybe<IntegerSelector>;\n  callResultNonce?: InputMaybe<IntegerSelector>;\n  callResultReceiver?: InputMaybe<HashSelector>;\n  callResultRelayedValue?: InputMaybe<FloatSelector>;\n  callResultSender?: InputMaybe<HashSelector>;\n  callResultType?: InputMaybe<StringSelector>;\n  callResultValue?: InputMaybe<FloatSelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  originTxHash?: InputMaybe<HashSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  previousTxHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  relayed?: InputMaybe<StringSelector>;\n  returnMessage?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\nexport enum ElrondCallResultUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Number of block in the blockchains */\n  height = 'height',\n  /** Unique Number of call results */\n  index = 'index',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum ElrondCallResultsMeasureable {\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Data of the call result */\n  call_result_data = 'call_result_data',\n  /** Hash of the call result */\n  call_result_hash = 'call_result_hash',\n  /** Index of the call result */\n  call_result_index = 'call_result_index',\n  /** Receiver of the call result */\n  call_result_receiver = 'call_result_receiver',\n  /** Sender of the call result */\n  call_result_sender = 'call_result_sender',\n  /** Data */\n  data = 'data',\n  /** Date */\n  date = 'date',\n  /** Gas Limit */\n  gas_limit = 'gas_limit',\n  /** Gas Price */\n  gas_price = 'gas_price',\n  /** Gas Used */\n  gas_used = 'gas_used',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** Hash of the miniblock */\n  miniblock_hash = 'miniblock_hash',\n  /** Hash of the miniblocks receiver block */\n  miniblock_receiver_block_hash = 'miniblock_receiver_block_hash',\n  /** Miniblock receiver shard */\n  miniblock_receiver_shard = 'miniblock_receiver_shard',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Previous transaction hash of the call result */\n  previous_tx_hash = 'previous_tx_hash',\n  /** Time */\n  time = 'time',\n  /** The block hash of this block`s parent */\n  transaction_count = 'transaction_count',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Receiver hash */\n  tx_receiver = 'tx_receiver',\n  /** Shard number of the receiver */\n  tx_receiver_shard = 'tx_receiver_shard',\n  /** Sender hash */\n  tx_sender = 'tx_sender',\n  /** Shard number of the sender */\n  tx_sender_shard = 'tx_sender_shard',\n  /** Value */\n  tx_value = 'tx_value',\n  /** Type of miniblock */\n  type = 'type'\n}\n\nexport enum ElrondCallsMeasureable {\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Call depth */\n  call_depth = 'call_depth',\n  /** Data */\n  data = 'data',\n  /** Date */\n  date = 'date',\n  /** Gas Limit */\n  gas_limit = 'gas_limit',\n  /** Gas Price */\n  gas_price = 'gas_price',\n  /** Gas Used */\n  gas_used = 'gas_used',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** Hash of the miniblock */\n  miniblock_hash = 'miniblock_hash',\n  /** Hash of the miniblocks receiver block */\n  miniblock_receiver_block_hash = 'miniblock_receiver_block_hash',\n  /** Miniblock receiver shard */\n  miniblock_receiver_shard = 'miniblock_receiver_shard',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Smart Contract Method Signature */\n  signature = 'signature',\n  /** Smart Contract Method Signature Hash */\n  signature_hash = 'signature_hash',\n  /** Smart Contract Method Name */\n  signature_name = 'signature_name',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** The block hash of this block`s parent */\n  transaction_count = 'transaction_count',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Receiver hash */\n  tx_receiver = 'tx_receiver',\n  /** Shard number of the receiver */\n  tx_receiver_shard = 'tx_receiver_shard',\n  /** Sender hash */\n  tx_sender = 'tx_sender',\n  /** Shard number of the sender */\n  tx_sender_shard = 'tx_sender_shard',\n  /** Value */\n  tx_value = 'tx_value',\n  /** Type of miniblock */\n  type = 'type'\n}\n\nexport enum ElrondCallsUni {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Number of block in the blockchains */\n  height = 'height',\n  /** Unique Number of smart contract methods */\n  smart_contract_methods = 'smart_contract_methods',\n  /** Unique Number of smart contract */\n  smart_contracts = 'smart_contracts',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Elrond Coinpath */\nexport type ElrondCoinpath = {\n  __typename?: 'ElrondCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<Address>;\n  /** Sender address */\n  sender?: Maybe<Address>;\n  /** Transaction of transfer happened */\n  transaction?: Maybe<ElrondTransactionValueDimension>;\n};\n\n\n/** Elrond Coinpath */\nexport type ElrondCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Elrond Coinpath */\nexport type ElrondCoinpathanyArgs = {\n  of: ElrondCoinpathMeasureable;\n};\n\n\n/** Elrond Coinpath */\nexport type ElrondCoinpathmaximumArgs = {\n  get?: InputMaybe<ElrondCoinpathMeasureable>;\n  of: ElrondCoinpathMeasureable;\n};\n\n\n/** Elrond Coinpath */\nexport type ElrondCoinpathminimumArgs = {\n  get?: InputMaybe<ElrondCoinpathMeasureable>;\n  of: ElrondCoinpathMeasureable;\n};\n\nexport enum ElrondCoinpathMeasureable {\n  /** Block */\n  block = 'block',\n  /** Depth */\n  depth = 'depth',\n  /** Receiver */\n  receiver = 'receiver',\n  /** Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Version */\n  tx_hash = 'tx_hash'\n}\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblock = {\n  __typename?: 'ElrondMiniblock';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Miniblock hash */\n  hash?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Hash of the receiver block */\n  receiverBlockHash?: Maybe<Scalars['String']>;\n  /** Number of the receiver shard */\n  receiverShard?: Maybe<Scalars['String']>;\n  /** Information about miniblocks block */\n  senderBlock?: Maybe<ElrondBlockDimension>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Miniblock type */\n  type?: Maybe<Scalars['String']>;\n};\n\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblockanyArgs = {\n  of: ElrondMiniblocksMeasureable;\n};\n\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblockcountArgs = {\n  uniq?: InputMaybe<ElrondMiniblockUniq>;\n};\n\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblockcountBigIntArgs = {\n  uniq?: InputMaybe<ElrondMiniblockUniq>;\n};\n\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblockhashArgs = {\n  miniblockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblockmaximumArgs = {\n  get?: InputMaybe<ElrondMiniblocksMeasureable>;\n  of: ElrondMiniblocksMeasureable;\n};\n\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblockminimumArgs = {\n  get?: InputMaybe<ElrondMiniblocksMeasureable>;\n  of: ElrondMiniblocksMeasureable;\n};\n\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblockreceiverBlockHashArgs = {\n  receiverBlockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblockreceiverShardArgs = {\n  receiverShard?: InputMaybe<BigIntIdSelector>;\n};\n\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblocksenderBlockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Miniblocks in Elrond  blockchain */\nexport type ElrondMiniblocktypeArgs = {\n  type?: InputMaybe<StringSelector>;\n};\n\nexport type ElrondMiniblockFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  receiverBlockHash?: InputMaybe<HashSelector>;\n  receiverShard?: InputMaybe<BigIntIdSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\nexport enum ElrondMiniblockUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Number of block in the blockchains */\n  height = 'height',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum ElrondMiniblocksMeasureable {\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Hash of the miniblock */\n  hash = 'hash',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Hash of the miniblocks receiver block */\n  receiver_block_hash = 'receiver_block_hash',\n  /** Miniblock receiver shard */\n  receiver_shard = 'receiver_shard',\n  /** Time */\n  time = 'time',\n  /** Count of transactions */\n  transaction_count = 'transaction_count',\n  /** Type of miniblock */\n  type = 'type'\n}\n\nexport enum ElrondNetwork {\n  /** Elrond mainnet */\n  elrond = 'elrond'\n}\n\n/** NotarizedBlocks in Elrond blockchain */\nexport type ElrondNotarizedBlock = {\n  __typename?: 'ElrondNotarizedBlock';\n  any?: Maybe<Scalars['String']>;\n  /** Information about blocks notarized block */\n  block?: Maybe<ElrondBlockDimension>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Hash of the notarized block */\n  notarizedBlockHash?: Maybe<Scalars['String']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n};\n\n\n/** NotarizedBlocks in Elrond blockchain */\nexport type ElrondNotarizedBlockanyArgs = {\n  of: ElrondNotarizedBlocksMeasureable;\n};\n\n\n/** NotarizedBlocks in Elrond blockchain */\nexport type ElrondNotarizedBlockblockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** NotarizedBlocks in Elrond blockchain */\nexport type ElrondNotarizedBlockcountArgs = {\n  uniq?: InputMaybe<ElrondNotarizedBlockUniq>;\n};\n\n\n/** NotarizedBlocks in Elrond blockchain */\nexport type ElrondNotarizedBlockcountBigIntArgs = {\n  uniq?: InputMaybe<ElrondNotarizedBlockUniq>;\n};\n\n\n/** NotarizedBlocks in Elrond blockchain */\nexport type ElrondNotarizedBlockmaximumArgs = {\n  get?: InputMaybe<ElrondNotarizedBlocksMeasureable>;\n  of: ElrondNotarizedBlocksMeasureable;\n};\n\n\n/** NotarizedBlocks in Elrond blockchain */\nexport type ElrondNotarizedBlockminimumArgs = {\n  get?: InputMaybe<ElrondNotarizedBlocksMeasureable>;\n  of: ElrondNotarizedBlocksMeasureable;\n};\n\n\n/** NotarizedBlocks in Elrond blockchain */\nexport type ElrondNotarizedBlocknotarizedBlockHashArgs = {\n  notarizedBlockHash?: InputMaybe<HashSelector>;\n};\n\nexport type ElrondNotarizedBlockFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  notarizedBlockHash?: InputMaybe<HashSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\nexport enum ElrondNotarizedBlockUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Number of block in the blockchains */\n  height = 'height',\n  /** Unique hash of notarized block */\n  notarized_block_hash = 'notarized_block_hash',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum ElrondNotarizedBlocksMeasureable {\n  /** Date */\n  date = 'date',\n  /** Block epoch */\n  epoch = 'epoch',\n  /** Hash of the the block */\n  hash = 'hash',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** Block nonce */\n  nonce = 'nonce',\n  /** Notarized block hash */\n  notarized_block_hash = 'notarized_block_hash',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Block proposer */\n  proposer = 'proposer',\n  /** Block public key bitmap */\n  public_key_bitmap = 'public_key_bitmap',\n  /** Block round */\n  round = 'round',\n  /** Shard number of block */\n  shard = 'shard',\n  /** Block size */\n  size = 'size',\n  /** Block size txs */\n  size_txs = 'size_txs',\n  /** State root hash */\n  state_root_hash = 'state_root_hash',\n  /** Time */\n  time = 'time',\n  /** Count of transactions in this block */\n  transaction_count = 'transaction_count'\n}\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransaction = {\n  __typename?: 'ElrondTransaction';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Data */\n  data?: Maybe<Scalars['String']>;\n  /** Data operation */\n  dataOperation?: Maybe<Scalars['String']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  fee?: Maybe<Scalars['Float']>;\n  /** Number of gas limit */\n  gasLimit?: Maybe<Scalars['BigInt']>;\n  /** Number of gas price */\n  gasPrice?: Maybe<Scalars['BigInt']>;\n  /** Number of gas used */\n  gasUsed?: Maybe<Scalars['BigInt']>;\n  /** Transaction hash */\n  hash?: Maybe<Scalars['String']>;\n  /** Transaction index */\n  index?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Information about transactions miniblock */\n  miniblock?: Maybe<MiniblockElrond>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transaction nonce */\n  nonce?: Maybe<Scalars['Int']>;\n  /** TX  receiver */\n  receiver?: Maybe<Address>;\n  /** Shard number of receiver */\n  receiverShard?: Maybe<Scalars['BigInt']>;\n  /** Hash of the sender */\n  sender?: Maybe<Address>;\n  /** Information about transactions block */\n  senderBlock?: Maybe<ElrondBlockDimension>;\n  /** Shard number of sender */\n  senderShard?: Maybe<Scalars['BigInt']>;\n  /** Signature */\n  signature?: Maybe<Scalars['String']>;\n  /** Tx Status */\n  status?: Maybe<Scalars['String']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  value?: Maybe<Scalars['Float']>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionanyArgs = {\n  of: ElrondTransactionsMeasureable;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactioncountArgs = {\n  uniq?: InputMaybe<ElrondTransactionUniq>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactioncountBigIntArgs = {\n  uniq?: InputMaybe<ElrondTransactionUniq>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactiondataArgs = {\n  data?: InputMaybe<StringSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactiondataOperationArgs = {\n  dataOperation?: InputMaybe<StringSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionfeeArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  fee?: InputMaybe<FloatSelector>;\n  gasLimit?: InputMaybe<FloatSelector>;\n  gasPrice?: InputMaybe<FloatSelector>;\n  gasUsed?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txNonce?: InputMaybe<IntegerSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  txValue?: InputMaybe<FloatSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactiongasLimitArgs = {\n  gasLimit?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactiongasPriceArgs = {\n  gasPrice?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactiongasUsedArgs = {\n  gasUsed?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionhashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionindexArgs = {\n  txIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionmaximumArgs = {\n  get?: InputMaybe<ElrondTransactionsMeasureable>;\n  of: ElrondTransactionsMeasureable;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionminiblockArgs = {\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionminimumArgs = {\n  get?: InputMaybe<ElrondTransactionsMeasureable>;\n  of: ElrondTransactionsMeasureable;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionnonceArgs = {\n  txNonce?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionreceiverArgs = {\n  txReceiver?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionreceiverShardArgs = {\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionsenderArgs = {\n  txSender?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionsenderBlockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionsenderShardArgs = {\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionsignatureArgs = {\n  signature?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionstatusArgs = {\n  status?: InputMaybe<StringSelector>;\n};\n\n\n/** Transactions in Elrond blockchain */\nexport type ElrondTransactionvalueArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  fee?: InputMaybe<FloatSelector>;\n  gasLimit?: InputMaybe<FloatSelector>;\n  gasPrice?: InputMaybe<FloatSelector>;\n  gasUsed?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txNonce?: InputMaybe<IntegerSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  txValue?: InputMaybe<FloatSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\nexport type ElrondTransactionFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  fee?: InputMaybe<FloatSelector>;\n  gasLimit?: InputMaybe<FloatSelector>;\n  gasPrice?: InputMaybe<FloatSelector>;\n  gasUsed?: InputMaybe<FloatSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<IntegerSelector>;\n  txNonce?: InputMaybe<IntegerSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  txValue?: InputMaybe<FloatSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\nexport enum ElrondTransactionUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Number of block in the blockchains */\n  height = 'height',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Blockchain transaction with value */\nexport type ElrondTransactionValueDimension = {\n  __typename?: 'ElrondTransactionValueDimension';\n  /** Transaction hash */\n  hash: Scalars['String'];\n  /** Transaction value */\n  value: Scalars['Float'];\n};\n\nexport enum ElrondTransactionsMeasureable {\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Data */\n  data = 'data',\n  /** Date */\n  date = 'date',\n  /** Gas Limit */\n  gas_limit = 'gas_limit',\n  /** Gas Price */\n  gas_price = 'gas_price',\n  /** Gas Used */\n  gas_used = 'gas_used',\n  /** Transaction hash */\n  hash = 'hash',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** Hash of the miniblock */\n  miniblock_hash = 'miniblock_hash',\n  /** Hash of the miniblocks receiver block */\n  miniblock_receiver_block_hash = 'miniblock_receiver_block_hash',\n  /** Miniblock receiver shard */\n  miniblock_receiver_shard = 'miniblock_receiver_shard',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Time */\n  time = 'time',\n  /** The block hash of this block`s parent */\n  transaction_count = 'transaction_count',\n  /** Receiver hash */\n  tx_receiver = 'tx_receiver',\n  /** Shard number of the receiver */\n  tx_receiver_shard = 'tx_receiver_shard',\n  /** Sender hash */\n  tx_sender = 'tx_sender',\n  /** Shard number of the sender */\n  tx_sender_shard = 'tx_sender_shard',\n  /** Type of miniblock */\n  type = 'type',\n  /** Value */\n  value = 'value'\n}\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransfer = {\n  __typename?: 'ElrondTransfer';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Metadata */\n  metadata?: Maybe<Scalars['String']>;\n  /** Information about arguments miniblock */\n  miniblock?: Maybe<MiniblockElrond>;\n  minimum?: Maybe<Scalars['String']>;\n  /** NFT nonce */\n  nftNonce?: Maybe<Scalars['String']>;\n  /** How the money was transferred */\n  reason?: Maybe<Scalars['String']>;\n  /** Receiver account address */\n  receiver?: Maybe<Address>;\n  /** Sender account address */\n  sender?: Maybe<Address>;\n  /** Information about arguments block */\n  senderBlock?: Maybe<ElrondBlockDimension>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Information about arguments transaction */\n  transaction?: Maybe<TransactionElrond>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransferamountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<CurrencySelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  metadata?: InputMaybe<StringSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nftNonce?: InputMaybe<IntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  transferReason?: InputMaybe<TransferReasonSelector>;\n  transferReceiver?: InputMaybe<AddressSelector>;\n  transferSender?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransferanyArgs = {\n  of: ElrondTransfersMeasureable;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransfercountArgs = {\n  uniq?: InputMaybe<ElrondTransferUniq>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransfercountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  currency?: InputMaybe<CurrencySelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  metadata?: InputMaybe<StringSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nftNonce?: InputMaybe<IntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  transferReason?: InputMaybe<TransferReasonSelector>;\n  transferReceiver?: InputMaybe<AddressSelector>;\n  transferSender?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n  uniq?: InputMaybe<ElrondTransferUniq>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransfercurrencyArgs = {\n  currency?: InputMaybe<CurrencySelector>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransfermaximumArgs = {\n  get?: InputMaybe<ElrondTransfersMeasureable>;\n  of: ElrondTransfersMeasureable;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransfermetadataArgs = {\n  metadata?: InputMaybe<StringSelector>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransferminiblockArgs = {\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransferminimumArgs = {\n  get?: InputMaybe<ElrondTransfersMeasureable>;\n  of: ElrondTransfersMeasureable;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransfernftNonceArgs = {\n  nftNonce?: InputMaybe<IntIdSelector>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransferreasonArgs = {\n  transferReason?: InputMaybe<TransferReasonSelector>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransferreceiverArgs = {\n  transferReceiver?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransfersenderArgs = {\n  transferSender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransfersenderBlockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transfers of Smart Contract Calls and Events */\nexport type ElrondTransfertransactionArgs = {\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  signature?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n};\n\nexport type ElrondTransferFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockNonce?: InputMaybe<IntegerSelector>;\n  currency?: InputMaybe<CurrencySelector>;\n  data?: InputMaybe<StringSelector>;\n  dataOperation?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  epoch?: InputMaybe<IntegerSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  metadata?: InputMaybe<StringSelector>;\n  miniblockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n  miniblockReceiverShard?: InputMaybe<BigIntIdSelector>;\n  nftNonce?: InputMaybe<IntIdSelector>;\n  nonce?: InputMaybe<IntegerSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  proposer?: InputMaybe<HashSelector>;\n  publicKeyBitmap?: InputMaybe<StringSelector>;\n  round?: InputMaybe<IntegerSelector>;\n  shard?: InputMaybe<BigIntIdSelector>;\n  signature?: InputMaybe<HashSelector>;\n  size?: InputMaybe<IntegerSelector>;\n  sizeTxs?: InputMaybe<IntegerSelector>;\n  stateRootHash?: InputMaybe<HashSelector>;\n  status?: InputMaybe<StringSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n  transferReason?: InputMaybe<TransferReasonSelector>;\n  transferReceiver?: InputMaybe<AddressSelector>;\n  transferSender?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txReceiver?: InputMaybe<HashSelector>;\n  txReceiverShard?: InputMaybe<BigIntIdSelector>;\n  txSender?: InputMaybe<HashSelector>;\n  txSenderShard?: InputMaybe<BigIntIdSelector>;\n  type?: InputMaybe<StringSelector>;\n};\n\nexport enum ElrondTransferUniq {\n  /** Unique Number of block in the blockchains */\n  block_height = 'block_height',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Transaction Hash */\n  signature = 'signature',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum ElrondTransfersMeasureable {\n  /** Transfer Amount */\n  amount = 'amount',\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Data */\n  data = 'data',\n  /** Date */\n  date = 'date',\n  /** Gas Limit */\n  gas_limit = 'gas_limit',\n  /** Gas Price */\n  gas_price = 'gas_price',\n  /** Gas Used */\n  gas_used = 'gas_used',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** Hash of the miniblock */\n  miniblock_hash = 'miniblock_hash',\n  /** Hash of the miniblocks receiver block */\n  miniblock_receiver_block_hash = 'miniblock_receiver_block_hash',\n  /** Miniblock receiver shard */\n  miniblock_receiver_shard = 'miniblock_receiver_shard',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Receiver */\n  receiver = 'receiver',\n  /** Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** The block hash of this block`s parent */\n  transaction_count = 'transaction_count',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Receiver hash */\n  tx_receiver = 'tx_receiver',\n  /** Shard number of the receiver */\n  tx_receiver_shard = 'tx_receiver_shard',\n  /** Sender hash */\n  tx_sender = 'tx_sender',\n  /** Shard number of the sender */\n  tx_sender_shard = 'tx_sender_shard',\n  /** Value */\n  tx_value = 'tx_value',\n  /** Type of miniblock */\n  type = 'type'\n}\n\n/** Entity */\nexport type Entity = {\n  __typename?: 'Entity';\n  /** Entity ID */\n  id: Scalars['String'];\n  /** Entity number */\n  num: Scalars['Int'];\n  /** Entity realm ID */\n  realmId: Scalars['Int'];\n  /** Entity shard ID */\n  shardId: Scalars['Int'];\n  /** Entity Type */\n  type: Scalars['String'];\n};\n\n\n/** Entity */\nexport type EntityidArgs = {\n  entityId?: InputMaybe<Scalars['String']>;\n};\n\n/** Selector of entity ID for NFT  tokens */\nexport type EntitySelector = {\n  /** EntityID in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** EntityID is */\n  is?: InputMaybe<Scalars['String']>;\n  /** EntityID not */\n  not?: InputMaybe<Scalars['String']>;\n  /** EntityID not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\nexport enum EntityTypeEnum {\n  /** account */\n  account = 'account',\n  /** contract */\n  contract = 'contract',\n  /** file */\n  file = 'file',\n  /** schedule */\n  schedule = 'schedule',\n  /** token */\n  token = 'token',\n  /** topic */\n  topic = 'topic'\n}\n\n/** Select by entity type */\nexport type EntityTypeSelector = {\n  /** Type in the list */\n  in?: InputMaybe<Array<EntityTypeEnum>>;\n  /** Type is */\n  is?: InputMaybe<EntityTypeEnum>;\n  /** Type not */\n  not?: InputMaybe<EntityTypeEnum>;\n  /** Type not in the list */\n  notIn?: InputMaybe<Array<EntityTypeEnum>>;\n};\n\n/** EOS Chain */\nexport type Eos = {\n  __typename?: 'Eos';\n  /** Basic information about address ( or smart contract ) */\n  address: Array<EosAddressInfo>;\n  /** Blockchain Blocks */\n  blocks?: Maybe<Array<EosBlocks>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<EosCoinpath>>;\n  /** Smart Contract Calls */\n  smartContractCalls?: Maybe<Array<EosSmartContractCalls>>;\n  /** Blockchain Transactions */\n  transactions?: Maybe<Array<EosTransactions>>;\n  /** Currency Transfers */\n  transfers?: Maybe<Array<EosTransfers>>;\n};\n\n\n/** EOS Chain */\nexport type EosaddressArgs = {\n  address: Array<AddressSelectorIn>;\n};\n\n\n/** EOS Chain */\nexport type EosblocksArgs = {\n  any?: InputMaybe<Array<EosBlockFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  proposer?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** EOS Chain */\nexport type EoscoinpathArgs = {\n  currency?: InputMaybe<EosCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<AddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CoinpathOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** EOS Chain */\nexport type EossmartContractCallsArgs = {\n  any?: InputMaybe<Array<EosSmartContractCallFilter>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** EOS Chain */\nexport type EostransactionsArgs = {\n  any?: InputMaybe<Array<EosTransactionFilter>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** EOS Chain */\nexport type EostransfersArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<EosTransferFilter>>;\n  currency?: InputMaybe<EosCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n/** Address detailed information for EOS network */\nexport type EosAddressInfo = {\n  __typename?: 'EosAddressInfo';\n  /** Address */\n  address?: Maybe<Scalars['String']>;\n  /** Annotations ( tags ), if exists */\n  annotation?: Maybe<Scalars['String']>;\n  /** Smart Contract if exists on the address */\n  smartContract?: Maybe<EosSmartContractInfo>;\n};\n\nexport type EosBlockFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  proposer?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n/** Blocks in EOS blockchain */\nexport type EosBlocks = {\n  __typename?: 'EosBlocks';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Block hash */\n  hash: Scalars['String'];\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block producer */\n  producer?: Maybe<Address>;\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n};\n\n\n/** Blocks in EOS blockchain */\nexport type EosBlocksanyArgs = {\n  of: EosBlocksMeasureable;\n};\n\n\n/** Blocks in EOS blockchain */\nexport type EosBlockscountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  proposer?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<EosBlocksUniq>;\n};\n\n\n/** Blocks in EOS blockchain */\nexport type EosBlockscountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  proposer?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<EosBlocksUniq>;\n};\n\n\n/** Blocks in EOS blockchain */\nexport type EosBlockshashArgs = {\n  blockHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Blocks in EOS blockchain */\nexport type EosBlocksheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Blocks in EOS blockchain */\nexport type EosBlocksmaximumArgs = {\n  get?: InputMaybe<EosBlocksMeasureable>;\n  of: EosBlocksMeasureable;\n};\n\n\n/** Blocks in EOS blockchain */\nexport type EosBlocksminimumArgs = {\n  get?: InputMaybe<EosBlocksMeasureable>;\n  of: EosBlocksMeasureable;\n};\n\n\n/** Blocks in EOS blockchain */\nexport type EosBlocksproducerArgs = {\n  producer?: InputMaybe<AddressSelector>;\n};\n\n\n/** Blocks in EOS blockchain */\nexport type EosBlockstimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport enum EosBlocksMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Block Proposer */\n  proposer = 'proposer',\n  /** Time */\n  time = 'time'\n}\n\nexport enum EosBlocksUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique proposer count */\n  proposers = 'proposers'\n}\n\nexport enum EosCallsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Call depth */\n  call_depth = 'call_depth',\n  /** Date */\n  date = 'date',\n  /** Smart Contract Method Signature */\n  signature = 'signature',\n  /** Smart Contract Method Signature Hash */\n  signature_hash = 'signature_hash',\n  /** Smart Contract Method Name */\n  signature_name = 'signature_name',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** Action From */\n  tx_from = 'tx_from',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Sender */\n  tx_sender = 'tx_sender',\n  /** Action To */\n  tx_to = 'tx_to'\n}\n\n/** Coinpath */\nexport type EosCoinpath = {\n  __typename?: 'EosCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<EosAddressInfo>;\n  /** Sender address */\n  sender?: Maybe<EosAddressInfo>;\n  /** Transaction of transfer happened */\n  transaction?: Maybe<TransactionHashValue>;\n};\n\n\n/** Coinpath */\nexport type EosCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Coinpath */\nexport type EosCoinpathanyArgs = {\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type EosCoinpathmaximumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type EosCoinpathminimumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n/**\n * Currency selector in EOS blockchain.\n * Token identified by address of contract ( eosio.token for main EOS token )\n */\nexport type EosCurrencySelector = {\n  /** Currency in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Currency is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Currency not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Currency not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\nexport enum EosNetwork {\n  /** EOS mainnet */\n  eos = 'eos'\n}\n\n/** Eos smart contract */\nexport type EosSmartContract = {\n  __typename?: 'EosSmartContract';\n  /** Smart Contract Address */\n  address: Address;\n  /** Smart Contract Type */\n  contractType?: Maybe<SmartContractType>;\n  /** Token implemented in this smart contract */\n  currency?: Maybe<Currency>;\n  /** Smart Contract Protocol Type */\n  protocolType?: Maybe<Scalars['String']>;\n};\n\nexport type EosSmartContractCallFilter = {\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n/** Smart Contract Calls */\nexport type EosSmartContractCalls = {\n  __typename?: 'EosSmartContractCalls';\n  /** Actors */\n  actors?: Maybe<Scalars['String']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */\n  callDepth?: Maybe<Scalars['String']>;\n  /** Console */\n  console?: Maybe<Scalars['String']>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Error Code */\n  errorCode?: Maybe<Scalars['Int']>;\n  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */\n  external?: Maybe<Scalars['Boolean']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Permissions */\n  permissions?: Maybe<Scalars['String']>;\n  /** Receivers */\n  receivers?: Maybe<Scalars['String']>;\n  /** True if call scheduled */\n  scheduled?: Maybe<Scalars['Boolean']>;\n  /** Smart contract being called */\n  smartContract?: Maybe<EosSmartContract>;\n  /** Contract method invoked */\n  smartContractMethod?: Maybe<Method>;\n  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Action from address */\n  txFrom?: Maybe<Address>;\n  /** Transaction hash where transfer happened */\n  txHash?: Maybe<Scalars['String']>;\n  /** Action to address */\n  txTo?: Maybe<Address>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallsanyArgs = {\n  of: EosCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallscountArgs = {\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallscountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallserrorCodeArgs = {\n  errorCode?: InputMaybe<IntIdSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallsexternalArgs = {\n  external?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallsmaximumArgs = {\n  get?: InputMaybe<EosCallsMeasureable>;\n  of: EosCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallsminimumArgs = {\n  get?: InputMaybe<EosCallsMeasureable>;\n  of: EosCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallsscheduledArgs = {\n  scheduled?: InputMaybe<Array<Scalars['Boolean']>>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallssmartContractArgs = {\n  smartContractAddress?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallssmartContractMethodArgs = {\n  smartContractMethod?: InputMaybe<MethodSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallssuccessArgs = {\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallstxFromArgs = {\n  txFrom?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallstxHashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type EosSmartContractCallstxToArgs = {\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n/** Blockchain smart contract */\nexport type EosSmartContractInfo = {\n  __typename?: 'EosSmartContractInfo';\n  /** Smart Contract Type */\n  contractType?: Maybe<SmartContractType>;\n  /** Token implemented in this smart contract */\n  currency?: Maybe<Currency>;\n  /** Smart Contract Protocol Type */\n  protocolType?: Maybe<Scalars['String']>;\n};\n\nexport type EosTransactionFilter = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n/** Transactions in EOS blockchain */\nexport type EosTransactions = {\n  __typename?: 'EosTransactions';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  cpuUsageUs?: Maybe<Scalars['Int']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0 based */\n  index?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  netUsageWords?: Maybe<Scalars['Int']>;\n  /** Success */\n  scheduled?: Maybe<Scalars['Boolean']>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionsanyArgs = {\n  of: EosTransactionsMeasureable;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionscountArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  uniq?: InputMaybe<EosTransactionsUniq>;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionscountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  uniq?: InputMaybe<EosTransactionsUniq>;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionscpuUsageUsArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionshashArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionsindexArgs = {\n  txIndex?: InputMaybe<Array<TxIndexSelector>>;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionsmaximumArgs = {\n  get?: InputMaybe<EosTransactionsMeasureable>;\n  of: EosTransactionsMeasureable;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionsminimumArgs = {\n  get?: InputMaybe<EosTransactionsMeasureable>;\n  of: EosTransactionsMeasureable;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionsnetUsageWordsArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionsscheduledArgs = {\n  scheduled?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transactions in EOS blockchain */\nexport type EosTransactionssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport enum EosTransactionsMeasureable {\n  /** Block */\n  block = 'block',\n  /** CPU Usage */\n  cpu_usage_us = 'cpu_usage_us',\n  /** Date */\n  date = 'date',\n  /** Net Usage */\n  net_usage_words = 'net_usage_words',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\nexport enum EosTransactionsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates'\n}\n\nexport type EosTransferFilter = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<EosCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransfers = {\n  __typename?: 'EosTransfers';\n  /** Actors */\n  actors?: Maybe<Scalars['String']>;\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Entity identifier ( for ERC-721 NFT tokens ) */\n  entityId?: Maybe<Scalars['String']>;\n  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */\n  external?: Maybe<Scalars['Boolean']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Memo */\n  memo?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transfer receiver */\n  receiver?: Maybe<Address>;\n  /** Transfer sender */\n  sender?: Maybe<Address>;\n  /** Transfer succeeded */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Action from address */\n  txFrom?: Maybe<Address>;\n  /** Transaction hash where transfer happened */\n  txHash?: Maybe<Scalars['String']>;\n  /** Action to address */\n  txTo?: Maybe<Address>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransfersamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<EosCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransfersanyArgs = {\n  of: EosTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransfersblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransferscountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<EosCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransferscountBigIntArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<EosCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransferscurrencyArgs = {\n  currency?: InputMaybe<EosCurrencySelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransfersentityIdArgs = {\n  entityId?: InputMaybe<EntitySelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransfersexternalArgs = {\n  external?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransfersmaximumArgs = {\n  get?: InputMaybe<EosTransfersMeasureable>;\n  of: EosTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransfersminimumArgs = {\n  get?: InputMaybe<EosTransfersMeasureable>;\n  of: EosTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransfersreceiverArgs = {\n  receiver?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransferssenderArgs = {\n  sender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransferssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransferstxFromArgs = {\n  txFrom?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransferstxHashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EosTransferstxToArgs = {\n  txTo?: InputMaybe<AddressSelector>;\n};\n\nexport enum EosTransfersMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Token address */\n  currency_address = 'currency_address',\n  /** Currency symbol */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** Receiver */\n  receiver = 'receiver',\n  /** Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\n/** Ethereum Chain */\nexport type Ethereum = {\n  __typename?: 'Ethereum';\n  /** Basic information about address ( or smart contract ) */\n  address: Array<EthereumAddressInfoWithBalance>;\n  /** Arguments of Smart Contract Calls and Events */\n  arguments?: Maybe<Array<EthereumArguments>>;\n  /** Blockchain Blocks */\n  blocks?: Maybe<Array<EthereumBlocks>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<EthereumCoinpath>>;\n  /** Trades on Ethereum DEX Smart Contracts */\n  dexTrades?: Maybe<Array<EthereumDexTrades>>;\n  /** Smart Contract Calls */\n  smartContractCalls?: Maybe<Array<EthereumSmartContractCalls>>;\n  /** Smart Contract Events */\n  smartContractEvents?: Maybe<Array<EthereumSmartContractEvent>>;\n  /** Blockchain Transactions */\n  transactions?: Maybe<Array<EthereumTransactions>>;\n  /** Currency Transfers */\n  transfers?: Maybe<Array<EthereumTransfers>>;\n};\n\n\n/** Ethereum Chain */\nexport type EthereumaddressArgs = {\n  address: Array<EthereumAddressSelectorIn>;\n};\n\n\n/** Ethereum Chain */\nexport type EthereumargumentsArgs = {\n  any?: InputMaybe<Array<EthereumArgumentFilter>>;\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  reference?: InputMaybe<Array<EthereumAddressSelector>>;\n  signatureType?: InputMaybe<SignatureTypeSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Ethereum Chain */\nexport type EthereumblocksArgs = {\n  any?: InputMaybe<Array<EthereumBlockFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  options?: InputMaybe<QueryOptions>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Ethereum Chain */\nexport type EthereumcoinpathArgs = {\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<EthereumAddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CoinpathOptions>;\n  receiver?: InputMaybe<EthereumAddressSelector>;\n  sender?: InputMaybe<EthereumAddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Ethereum Chain */\nexport type EthereumdexTradesArgs = {\n  any?: InputMaybe<Array<EthereumDexTradeFilter>>;\n  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  options?: InputMaybe<QueryOptions>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  taker?: InputMaybe<Array<EthereumAddressSelector>>;\n  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Ethereum Chain */\nexport type EthereumsmartContractCallsArgs = {\n  any?: InputMaybe<Array<EthereumSmartContractCallFilter>>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Ethereum Chain */\nexport type EthereumsmartContractEventsArgs = {\n  any?: InputMaybe<Array<EthereumSmartContractEventFilter>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Ethereum Chain */\nexport type EthereumtransactionsArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<EthereumTransactionFilter>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  gasValue?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Ethereum Chain */\nexport type EthereumtransfersArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<EthereumTransferFilter>>;\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<Array<EthereumAddressSelector>>;\n  sender?: InputMaybe<Array<EthereumAddressSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n/** Ethereum v 2.0 Baecon Chain */\nexport type Ethereum2 = {\n  __typename?: 'Ethereum2';\n  /** Attestations in block */\n  attestations?: Maybe<Array<Ethereum2Attestation>>;\n  /** Attester Slashings */\n  attesterSlashings?: Maybe<Array<Ethereum2AttesterSlashing>>;\n  /** Blockchain Blocks */\n  blocks?: Maybe<Array<Ethereum2Blocks>>;\n  /** Attestations of blocks */\n  deposits?: Maybe<Array<Ethereum2Deposit>>;\n  /** Proposer Slashings */\n  proposerSlashings?: Maybe<Array<Ethereum2ProposerSlashing>>;\n  /** Voluntary Exits */\n  voluntaryExits?: Maybe<Array<Ethereum2VoluntaryExit>>;\n};\n\n\n/** Ethereum v 2.0 Baecon Chain */\nexport type Ethereum2attestationsArgs = {\n  any?: InputMaybe<Array<Ethereum2Filter>>;\n  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;\n  attestationSlot?: InputMaybe<Array<IntegerSelector>>;\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  committeeIndex?: InputMaybe<Array<IntegerSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Ethereum v 2.0 Baecon Chain */\nexport type Ethereum2attesterSlashingsArgs = {\n  any?: InputMaybe<Array<Ethereum2Filter>>;\n  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;\n  attestationSlot?: InputMaybe<Array<IntegerSelector>>;\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Ethereum v 2.0 Baecon Chain */\nexport type Ethereum2blocksArgs = {\n  any?: InputMaybe<Array<Ethereum2Filter>>;\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Ethereum v 2.0 Baecon Chain */\nexport type Ethereum2depositsArgs = {\n  any?: InputMaybe<Array<Ethereum2Filter>>;\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Ethereum v 2.0 Baecon Chain */\nexport type Ethereum2proposerSlashingsArgs = {\n  any?: InputMaybe<Array<Ethereum2Filter>>;\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  slashingEpoch?: InputMaybe<Array<IntegerSelector>>;\n  slashingProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  slashingSlot?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Ethereum v 2.0 Baecon Chain */\nexport type Ethereum2voluntaryExitsArgs = {\n  any?: InputMaybe<Array<Ethereum2Filter>>;\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n  voluntaryExitEpoch?: InputMaybe<Array<IntegerSelector>>;\n};\n\n/** Attestations in Ethereum v2.0 blockchain */\nexport type Ethereum2Attestation = {\n  __typename?: 'Ethereum2Attestation';\n  aggregationBits: Scalars['String'];\n  any?: Maybe<Scalars['String']>;\n  attestation: Ethereum2AttestationInfo;\n  /** Attestation Index (0 based ) in block */\n  attestationIndex: Scalars['Int'];\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Block root hash */\n  blockRoot: Scalars['String'];\n  /** Committee index for attestation */\n  committeeIndex: Scalars['Int'];\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Block Eth1 information */\n  eth1: Ethereum2Eth1Info;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block parent hash */\n  parentRoot: Scalars['String'];\n  /** Block proposer */\n  proposer?: Maybe<Ethereum2ValidatorInfo>;\n  /** Block state root hash */\n  stateRoot: Scalars['String'];\n  /** Validator */\n  validator: Ethereum2ValidatorInfo;\n  /** Sequential index of validator in committee ( 0-based) */\n  validatorInCommitteeIndex: Scalars['Int'];\n};\n\n\n/** Attestations in Ethereum v2.0 blockchain */\nexport type Ethereum2AttestationanyArgs = {\n  of: Ethereum2AttestationsMeasureable;\n};\n\n\n/** Attestations in Ethereum v2.0 blockchain */\nexport type Ethereum2AttestationblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Attestations in Ethereum v2.0 blockchain */\nexport type Ethereum2AttestationblockRootArgs = {\n  blockRootHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Attestations in Ethereum v2.0 blockchain */\nexport type Ethereum2AttestationcountArgs = {\n  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;\n  attestationSlot?: InputMaybe<Array<IntegerSelector>>;\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  committeeIndex?: InputMaybe<Array<IntegerSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2AttestationsUniq>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Attestations in Ethereum v2.0 blockchain */\nexport type Ethereum2AttestationcountBigIntArgs = {\n  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;\n  attestationSlot?: InputMaybe<Array<IntegerSelector>>;\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  committeeIndex?: InputMaybe<Array<IntegerSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2AttestationsUniq>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Attestations in Ethereum v2.0 blockchain */\nexport type Ethereum2AttestationmaximumArgs = {\n  get?: InputMaybe<Ethereum2AttestationsMeasureable>;\n  of: Ethereum2AttestationsMeasureable;\n};\n\n\n/** Attestations in Ethereum v2.0 blockchain */\nexport type Ethereum2AttestationminimumArgs = {\n  get?: InputMaybe<Ethereum2AttestationsMeasureable>;\n  of: Ethereum2AttestationsMeasureable;\n};\n\n\n/** Attestations in Ethereum v2.0 blockchain */\nexport type Ethereum2AttestationproposerArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\n/** AttestationFieldInfo for Ethereum v 2.0 network */\nexport type Ethereum2AttestationFieldInfo = {\n  __typename?: 'Ethereum2AttestationFieldInfo';\n  epoch: Scalars['Int'];\n  /** Root Hash */\n  root: Scalars['String'];\n};\n\n/** AttestationInfo for Ethereum v 2.0 network */\nexport type Ethereum2AttestationInfo = {\n  __typename?: 'Ethereum2AttestationInfo';\n  beaconBlockRoot: Scalars['String'];\n  epoch: Scalars['Int'];\n  signature: Scalars['String'];\n  slot: Scalars['Int'];\n  source: Ethereum2AttestationFieldInfo;\n  target: Ethereum2AttestationFieldInfo;\n};\n\nexport enum Ethereum2AttestationsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block Proposer */\n  block_proposer = 'block_proposer',\n  /** Block hash */\n  block_root_hash = 'block_root_hash',\n  /** Committee Index */\n  committee = 'committee',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Validator index */\n  validator = 'validator'\n}\n\nexport enum Ethereum2AttestationsUniq {\n  /** Unique attestation epochs */\n  attestation_epochs = 'attestation_epochs',\n  /** Unique attestation slots */\n  attestation_slots = 'attestation_slots',\n  /** Unique attestations */\n  attestations = 'attestations',\n  /** Unique block proposers */\n  block_proposers = 'block_proposers',\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique commitees */\n  committees = 'committees',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique validators */\n  validators = 'validators'\n}\n\n/** Attester Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2AttesterSlashing = {\n  __typename?: 'Ethereum2AttesterSlashing';\n  any?: Maybe<Scalars['String']>;\n  attestation: Ethereum2AttestationInfo;\n  /** Attestation slashing sequential number */\n  attestationOrder: Scalars['Int'];\n  /** Attester Slashing Index (0 based ) in block */\n  attesterSlashingIndex: Scalars['Int'];\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Block root hash */\n  blockRoot: Scalars['String'];\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Block Eth1 information */\n  eth1: Ethereum2Eth1Info;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block parent hash */\n  parentRoot: Scalars['String'];\n  /** Block proposer */\n  proposer?: Maybe<Ethereum2ValidatorInfo>;\n  /** Block state root hash */\n  stateRoot: Scalars['String'];\n  /** Validator */\n  validator: Ethereum2ValidatorInfo;\n  /** Validator index in slashing sequential numbern */\n  validatorInAttestationIndex: Scalars['Int'];\n};\n\n\n/** Attester Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2AttesterSlashinganyArgs = {\n  of: Ethereum2AttesterSlashingMeasureable;\n};\n\n\n/** Attester Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2AttesterSlashingblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Attester Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2AttesterSlashingblockRootArgs = {\n  blockRootHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Attester Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2AttesterSlashingcountArgs = {\n  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;\n  attestationSlot?: InputMaybe<Array<IntegerSelector>>;\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2AttesterSlashingsUniq>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Attester Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2AttesterSlashingcountBigIntArgs = {\n  attestationEpoch?: InputMaybe<Array<IntegerSelector>>;\n  attestationSlot?: InputMaybe<Array<IntegerSelector>>;\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2AttesterSlashingsUniq>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Attester Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2AttesterSlashingmaximumArgs = {\n  get?: InputMaybe<Ethereum2AttesterSlashingMeasureable>;\n  of: Ethereum2AttesterSlashingMeasureable;\n};\n\n\n/** Attester Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2AttesterSlashingminimumArgs = {\n  get?: InputMaybe<Ethereum2AttesterSlashingMeasureable>;\n  of: Ethereum2AttesterSlashingMeasureable;\n};\n\n\n/** Attester Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2AttesterSlashingproposerArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\nexport enum Ethereum2AttesterSlashingMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block Proposer */\n  block_proposer = 'block_proposer',\n  /** Block hash */\n  block_root_hash = 'block_root_hash',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Validator index */\n  validator = 'validator'\n}\n\nexport enum Ethereum2AttesterSlashingsUniq {\n  /** Unique slashing epochs */\n  attestation_epochs = 'attestation_epochs',\n  /** Unique slashing slots */\n  attestation_slots = 'attestation_slots',\n  /** Unique block proposers */\n  block_proposers = 'block_proposers',\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique validators */\n  validators = 'validators'\n}\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2Blocks = {\n  __typename?: 'Ethereum2Blocks';\n  any?: Maybe<Scalars['String']>;\n  attestationsCount?: Maybe<Scalars['Int']>;\n  attestationsCountBigInt?: Maybe<Scalars['BigInt']>;\n  attesterSlashingsCount?: Maybe<Scalars['Int']>;\n  attesterSlashingsCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Block root hash */\n  blockRoot: Scalars['String'];\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  depositsCount?: Maybe<Scalars['Int']>;\n  depositsCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Block Eth1 information */\n  eth1: Ethereum2Eth1Info;\n  /** Graffiti */\n  graffiti: Scalars['String'];\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block parent hash */\n  parentRoot: Scalars['String'];\n  /** Block proposer */\n  proposer?: Maybe<Ethereum2ValidatorInfo>;\n  proposerSlashingsCount?: Maybe<Scalars['Int']>;\n  proposerSlashingsCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Randao Reveal */\n  randaoReveal: Scalars['String'];\n  /** Block signature */\n  signature: Scalars['String'];\n  /** Block state root hash */\n  stateRoot: Scalars['String'];\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n  voluntaryExitsCount?: Maybe<Scalars['Int']>;\n  voluntaryExitsCountBigInt?: Maybe<Scalars['BigInt']>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksanyArgs = {\n  of: Ethereum2BlocksMeasureable;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksattestationsCountArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksattestationsCountBigIntArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksattesterSlashingsCountArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksattesterSlashingsCountBigIntArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksblockRootArgs = {\n  blockRootHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlockscountArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2BlocksUniq>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlockscountBigIntArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2BlocksUniq>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksdepositsCountArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksdepositsCountBigIntArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksmaximumArgs = {\n  get?: InputMaybe<Ethereum2BlocksMeasureable>;\n  of: Ethereum2BlocksMeasureable;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksminimumArgs = {\n  get?: InputMaybe<Ethereum2BlocksMeasureable>;\n  of: Ethereum2BlocksMeasureable;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksproposerArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksproposerSlashingsCountArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksproposerSlashingsCountBigIntArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlockstimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksvoluntaryExitsCountArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum v2.0 blockchain */\nexport type Ethereum2BlocksvoluntaryExitsCountBigIntArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport enum Ethereum2BlocksMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block Miner */\n  block_proposer = 'block_proposer',\n  /** Block hash */\n  block_root_hash = 'block_root_hash',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time'\n}\n\nexport enum Ethereum2BlocksUniq {\n  /** Unique proposers */\n  block_proposers = 'block_proposers',\n  /** Unique date count */\n  dates = 'dates'\n}\n\n/** Deposit in Ethereum v2.0 blockchain */\nexport type Ethereum2Deposit = {\n  __typename?: 'Ethereum2Deposit';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Block root hash */\n  blockRoot: Scalars['String'];\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Deposit Index (0 based ) in block */\n  depositIndex: Scalars['Int'];\n  /** Block Eth1 information */\n  eth1: Ethereum2Eth1Info;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block parent hash */\n  parentRoot: Scalars['String'];\n  proof: Scalars['String'];\n  /** Block proposer */\n  proposer?: Maybe<Ethereum2ValidatorInfo>;\n  signature: Scalars['String'];\n  /** Block state root hash */\n  stateRoot: Scalars['String'];\n  /** Validator */\n  validator: Ethereum2ValidatorInfo;\n};\n\n\n/** Deposit in Ethereum v2.0 blockchain */\nexport type Ethereum2DepositamountArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Deposit in Ethereum v2.0 blockchain */\nexport type Ethereum2DepositanyArgs = {\n  of: Ethereum2DepositsMeasureable;\n};\n\n\n/** Deposit in Ethereum v2.0 blockchain */\nexport type Ethereum2DepositblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Deposit in Ethereum v2.0 blockchain */\nexport type Ethereum2DepositblockRootArgs = {\n  blockRootHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Deposit in Ethereum v2.0 blockchain */\nexport type Ethereum2DepositcountArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2DepositsUniq>;\n};\n\n\n/** Deposit in Ethereum v2.0 blockchain */\nexport type Ethereum2DepositcountBigIntArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2DepositsUniq>;\n};\n\n\n/** Deposit in Ethereum v2.0 blockchain */\nexport type Ethereum2DepositmaximumArgs = {\n  get?: InputMaybe<Ethereum2DepositsMeasureable>;\n  of: Ethereum2DepositsMeasureable;\n};\n\n\n/** Deposit in Ethereum v2.0 blockchain */\nexport type Ethereum2DepositminimumArgs = {\n  get?: InputMaybe<Ethereum2DepositsMeasureable>;\n  of: Ethereum2DepositsMeasureable;\n};\n\n\n/** Deposit in Ethereum v2.0 blockchain */\nexport type Ethereum2DepositproposerArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\nexport enum Ethereum2DepositsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block Proposer */\n  block_proposer = 'block_proposer',\n  /** Block hash */\n  block_root_hash = 'block_root_hash',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Validator index */\n  validator = 'validator'\n}\n\nexport enum Ethereum2DepositsUniq {\n  /** Unique block proposers */\n  block_proposers = 'block_proposers',\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique validators */\n  validators = 'validators'\n}\n\n/** Eth1 attributes for Ethereum v 2.0 network */\nexport type Ethereum2Eth1Info = {\n  __typename?: 'Ethereum2Eth1Info';\n  /** Block Eth1 block hash */\n  blockHash: Scalars['String'];\n  /** Block Eth1 deposit count */\n  depositCount: Scalars['Int'];\n  /** Block Eth1 deposit root hash */\n  depositRoot: Scalars['String'];\n};\n\nexport type Ethereum2Filter = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport enum Ethereum2Network {\n  /** Beacon Chain Ethereum 2.0 */\n  eth2 = 'eth2',\n  /** Medalla Ethereum 2.0 Beacon Testnet */\n  medalla = 'medalla'\n}\n\n/** Proposer Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2ProposerSlashing = {\n  __typename?: 'Ethereum2ProposerSlashing';\n  any?: Maybe<Scalars['String']>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Block root hash */\n  blockRoot: Scalars['String'];\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Block Eth1 information */\n  eth1: Ethereum2Eth1Info;\n  /** Header slashing sequential numbern */\n  headerOrder: Scalars['Int'];\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block parent hash */\n  parentRoot: Scalars['String'];\n  /** Block proposer */\n  proposer?: Maybe<Ethereum2ValidatorInfo>;\n  /** Proposer Slashing Index (0 based ) in block */\n  proposerSlashingIndex: Scalars['Int'];\n  slashing: Ethereum2SlashingInfo;\n  /** Block state root hash */\n  stateRoot: Scalars['String'];\n};\n\n\n/** Proposer Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2ProposerSlashinganyArgs = {\n  of: Ethereum2ProposerSlashingMeasureable;\n};\n\n\n/** Proposer Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2ProposerSlashingblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Proposer Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2ProposerSlashingblockRootArgs = {\n  blockRootHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Proposer Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2ProposerSlashingcountArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  slashingEpoch?: InputMaybe<Array<IntegerSelector>>;\n  slashingProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  slashingSlot?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2ProposerSlashingsUniq>;\n};\n\n\n/** Proposer Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2ProposerSlashingcountBigIntArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  slashingEpoch?: InputMaybe<Array<IntegerSelector>>;\n  slashingProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  slashingSlot?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2ProposerSlashingsUniq>;\n};\n\n\n/** Proposer Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2ProposerSlashingmaximumArgs = {\n  get?: InputMaybe<Ethereum2ProposerSlashingMeasureable>;\n  of: Ethereum2ProposerSlashingMeasureable;\n};\n\n\n/** Proposer Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2ProposerSlashingminimumArgs = {\n  get?: InputMaybe<Ethereum2ProposerSlashingMeasureable>;\n  of: Ethereum2ProposerSlashingMeasureable;\n};\n\n\n/** Proposer Slashing in Ethereum v2.0 blockchain */\nexport type Ethereum2ProposerSlashingproposerArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\nexport enum Ethereum2ProposerSlashingMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block Proposer */\n  block_proposer = 'block_proposer',\n  /** Block hash */\n  block_root_hash = 'block_root_hash',\n  /** Date */\n  date = 'date',\n  /** Slashed Proposer */\n  proposer = 'proposer',\n  /** Time */\n  time = 'time'\n}\n\nexport enum Ethereum2ProposerSlashingsUniq {\n  /** Unique block proposers */\n  block_proposers = 'block_proposers',\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique slashing epochs */\n  slashing_epochs = 'slashing_epochs',\n  /** Unique slashing proposers */\n  slashing_proposers = 'slashing_proposers',\n  /** Unique slashing slots */\n  slashing_slots = 'slashing_slots'\n}\n\n/** SlashingInfo for Ethereum v 2.0 network */\nexport type Ethereum2SlashingInfo = {\n  __typename?: 'Ethereum2SlashingInfo';\n  /** Block body hash */\n  bodyRoot: Scalars['String'];\n  epoch: Scalars['Int'];\n  /** Block parent hash */\n  parentRoot: Scalars['String'];\n  /** Block proposer */\n  proposer?: Maybe<Ethereum2ValidatorInfo>;\n  signature: Scalars['String'];\n  slot: Scalars['Int'];\n  /** Block state root hash */\n  stateRoot: Scalars['String'];\n};\n\n/** Validator attributes for Ethereum v 2.0 network */\nexport type Ethereum2ValidatorInfo = {\n  __typename?: 'Ethereum2ValidatorInfo';\n  /** Validator Index as Integer */\n  index: Scalars['Int'];\n  /** Validator Pub Key */\n  pubkey: Scalars['String'];\n  /** Validator Withdrawal */\n  withdrawalCredentials: Scalars['String'];\n};\n\n/** Voluntary Exit in Ethereum v2.0 blockchain */\nexport type Ethereum2VoluntaryExit = {\n  __typename?: 'Ethereum2VoluntaryExit';\n  any?: Maybe<Scalars['String']>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Block root hash */\n  blockRoot: Scalars['String'];\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Block Eth1 information */\n  eth1: Ethereum2Eth1Info;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block parent hash */\n  parentRoot: Scalars['String'];\n  /** Block proposer */\n  proposer?: Maybe<Ethereum2ValidatorInfo>;\n  /** Signature */\n  signature: Scalars['String'];\n  /** Block state root hash */\n  stateRoot: Scalars['String'];\n  /** Validator */\n  validator: Ethereum2ValidatorInfo;\n  voluntaryExitEpoch: Scalars['Int'];\n  /** Voluntary Exit Index (0 based ) in block */\n  voluntaryExitIndex: Scalars['Int'];\n};\n\n\n/** Voluntary Exit in Ethereum v2.0 blockchain */\nexport type Ethereum2VoluntaryExitanyArgs = {\n  of: Ethereum2VoluntaryExitsMeasureable;\n};\n\n\n/** Voluntary Exit in Ethereum v2.0 blockchain */\nexport type Ethereum2VoluntaryExitblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Voluntary Exit in Ethereum v2.0 blockchain */\nexport type Ethereum2VoluntaryExitblockRootArgs = {\n  blockRootHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Voluntary Exit in Ethereum v2.0 blockchain */\nexport type Ethereum2VoluntaryExitcountArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2VoluntaryExitsUniq>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n  voluntaryExitEpoch?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Voluntary Exit in Ethereum v2.0 blockchain */\nexport type Ethereum2VoluntaryExitcountBigIntArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n  blockRootHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<Ethereum2VoluntaryExitsUniq>;\n  validatorIndex?: InputMaybe<Array<IntegerSelector>>;\n  voluntaryExitEpoch?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Voluntary Exit in Ethereum v2.0 blockchain */\nexport type Ethereum2VoluntaryExitmaximumArgs = {\n  get?: InputMaybe<Ethereum2VoluntaryExitsMeasureable>;\n  of: Ethereum2VoluntaryExitsMeasureable;\n};\n\n\n/** Voluntary Exit in Ethereum v2.0 blockchain */\nexport type Ethereum2VoluntaryExitminimumArgs = {\n  get?: InputMaybe<Ethereum2VoluntaryExitsMeasureable>;\n  of: Ethereum2VoluntaryExitsMeasureable;\n};\n\n\n/** Voluntary Exit in Ethereum v2.0 blockchain */\nexport type Ethereum2VoluntaryExitproposerArgs = {\n  blockProposerIndex?: InputMaybe<Array<IntegerSelector>>;\n};\n\nexport enum Ethereum2VoluntaryExitsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block Proposer */\n  block_proposer = 'block_proposer',\n  /** Block hash */\n  block_root_hash = 'block_root_hash',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Validator index */\n  validator = 'validator'\n}\n\nexport enum Ethereum2VoluntaryExitsUniq {\n  /** Unique block proposers */\n  block_proposers = 'block_proposers',\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique validators */\n  validators = 'validators'\n}\n\n/** Address detailed information for Ethereum network */\nexport type EthereumAddressInfo = {\n  __typename?: 'EthereumAddressInfo';\n  /** Address */\n  address?: Maybe<Scalars['String']>;\n  /** Annotations ( tags ), if exists */\n  annotation?: Maybe<Scalars['String']>;\n  /** Smart Contract if exists on the address */\n  smartContract?: Maybe<EthereumSmartContractInfo>;\n};\n\n/** Blockchain address */\nexport type EthereumAddressInfoWithBalance = {\n  __typename?: 'EthereumAddressInfoWithBalance';\n  /** Address */\n  address?: Maybe<Scalars['String']>;\n  /** Annotations ( tags ), if exists */\n  annotation?: Maybe<Scalars['String']>;\n  /** DEPRECATED Current address balance */\n  balance?: Maybe<Scalars['Float']>;\n  /** DEPRECATED Balances by currencies for the address */\n  balances?: Maybe<Array<EthereumBalance>>;\n  /** Smart Contract if exists on the address */\n  smartContract?: Maybe<EthereumSmartContractInfoWithAttributes>;\n};\n\n\n/** Blockchain address */\nexport type EthereumAddressInfoWithBalancebalancesArgs = {\n  currency?: InputMaybe<EthereumCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelectorRange>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n/**\n * Address should start from 0x and contain hex digits.\n *   If digits are case sensitive, address is checked against checksum according to EIP-55.\n */\nexport type EthereumAddressSelector = {\n  /** In the list of Addresses */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Equal to Address */\n  is?: InputMaybe<Scalars['String']>;\n  /** Not Equal to Address */\n  not?: InputMaybe<Scalars['String']>;\n  /** Not in the list of Addresses */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/**\n * Address should start from 0x and contain hex digits.\n *   If digits are case sensitive, address is checked against checksum according to EIP-55.\n */\nexport type EthereumAddressSelectorIn = {\n  /** In the list of Addresses */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Equal to Address */\n  is?: InputMaybe<Scalars['String']>;\n};\n\nexport type EthereumArgumentFilter = {\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  reference?: InputMaybe<Array<EthereumAddressSelector>>;\n  signatureType?: InputMaybe<SignatureTypeSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArguments = {\n  __typename?: 'EthereumArguments';\n  any?: Maybe<Scalars['String']>;\n  /** Method or event argument */\n  argument?: Maybe<ArgumentName>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */\n  callDepth?: Maybe<Scalars['String']>;\n  /** Caller of the method invocation ( tx sender or another smart contract ) */\n  caller?: Maybe<EthereumAddressInfo>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */\n  external?: Maybe<Scalars['Boolean']>;\n  /** Sequential index of value in array ( multi-dimensional) */\n  index: Scalars['String'];\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  number?: Maybe<Scalars['Float']>;\n  /** Address value of method or event argument */\n  reference?: Maybe<EthereumAddressInfo>;\n  /** Smart contract being called */\n  smartContract?: Maybe<EthereumSmartContract>;\n  /** Contract method or event */\n  smartContractSignature?: Maybe<Signature>;\n  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Transaction where call happened */\n  transaction?: Maybe<EthereumTransactionInfo>;\n  /** The Value of method or event argument */\n  value?: Maybe<ArgumentValue>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentsanyArgs = {\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;\n  as?: InputMaybe<EthereumArgumentsConvertable>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  of: EthereumArgumentsMeasureable;\n  reference?: InputMaybe<Array<EthereumAddressSelector>>;\n  signatureType?: InputMaybe<SignatureTypeSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentsargumentArgs = {\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  argumentType?: InputMaybe<Scalars['String']>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentscallerArgs = {\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentscountArgs = {\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  reference?: InputMaybe<Array<EthereumAddressSelector>>;\n  signatureType?: InputMaybe<SignatureTypeSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<SmartContractArgumentsUniq>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentscountBigIntArgs = {\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  reference?: InputMaybe<Array<EthereumAddressSelector>>;\n  signatureType?: InputMaybe<SignatureTypeSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<SmartContractArgumentsUniq>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentsexternalArgs = {\n  external?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentsmaximumArgs = {\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;\n  as?: InputMaybe<EthereumArgumentsConvertable>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  get?: InputMaybe<EthereumArgumentsMeasureable>;\n  height?: InputMaybe<BlockSelector>;\n  of: EthereumArgumentsMeasureable;\n  reference?: InputMaybe<Array<EthereumAddressSelector>>;\n  signatureType?: InputMaybe<SignatureTypeSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentsminimumArgs = {\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;\n  as?: InputMaybe<EthereumArgumentsConvertable>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  get?: InputMaybe<EthereumArgumentsMeasureable>;\n  height?: InputMaybe<BlockSelector>;\n  of: EthereumArgumentsMeasureable;\n  reference?: InputMaybe<Array<EthereumAddressSelector>>;\n  signatureType?: InputMaybe<SignatureTypeSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentsnumberArgs = {\n  argument?: InputMaybe<Array<ArgumentSelector>>;\n  argumentType?: InputMaybe<Array<ArgumentTypeSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  reference?: InputMaybe<Array<EthereumAddressSelector>>;\n  signatureType?: InputMaybe<SignatureTypeSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentsreferenceArgs = {\n  reference?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentssmartContractArgs = {\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentssmartContractSignatureArgs = {\n  signatureType?: InputMaybe<SignatureTypeSelector>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentssuccessArgs = {\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentstransactionArgs = {\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type EthereumArgumentsvalueArgs = {\n  value?: InputMaybe<Array<ArgumentValueSelector>>;\n};\n\nexport enum EthereumArgumentsConvertable {\n  /** Token name */\n  token_name = 'token_name',\n  /** Token symbol */\n  token_symbol = 'token_symbol'\n}\n\nexport enum EthereumArgumentsMeasureable {\n  /** Argument */\n  argument = 'argument',\n  /** Argument index */\n  argument_index = 'argument_index',\n  /** Argument type */\n  argument_type = 'argument_type',\n  /** Argument value */\n  argument_value = 'argument_value',\n  /** Block */\n  block = 'block',\n  /** Call depth */\n  call_depth = 'call_depth',\n  /** Caller */\n  caller = 'caller',\n  /** Date */\n  date = 'date',\n  /** Smart Contract Method Signature */\n  signature = 'signature',\n  /** Smart Contract Method Signature Hash */\n  signature_hash = 'signature_hash',\n  /** Smart Contract Method Name */\n  signature_name = 'signature_name',\n  /** Smart Contract Method Signature */\n  signature_type = 'signature_type',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\n/** Balance in a currency */\nexport type EthereumBalance = {\n  __typename?: 'EthereumBalance';\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** History of balance changes by currencies for the address */\n  history?: Maybe<Array<EthereumBalanceChange>>;\n  value?: Maybe<Scalars['Float']>;\n};\n\n\n/** Balance in a currency */\nexport type EthereumBalancehistoryArgs = {\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  height?: InputMaybe<BlockSelectorRange>;\n};\n\n/** Change of balance in a currency */\nexport type EthereumBalanceChange = {\n  __typename?: 'EthereumBalanceChange';\n  /** Block number (height) in blockchain */\n  block: Scalars['Int'];\n  /** Block timestamp */\n  timestamp?: Maybe<Scalars['ISO8601DateTime']>;\n  /** Transfer amount ( positive inbound, negative outbound) */\n  transferAmount?: Maybe<Scalars['Float']>;\n  value?: Maybe<Scalars['Float']>;\n};\n\nexport type EthereumBlockFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlocks = {\n  __typename?: 'EthereumBlocks';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  difficulty?: Maybe<Scalars['Float']>;\n  /** Block hash */\n  hash: Scalars['String'];\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  maximum?: Maybe<Scalars['String']>;\n  /** Block miner */\n  miner?: Maybe<EthereumAddressInfo>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Block nonce */\n  nonce: Scalars['Int'];\n  /** Parent block hash */\n  parentHash: Scalars['String'];\n  reward?: Maybe<Scalars['Float']>;\n  /** Currency of reward */\n  rewardCurrency?: Maybe<Currency>;\n  size?: Maybe<Scalars['Int']>;\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n  totalDifficulty?: Maybe<Scalars['Float']>;\n  transactionCount?: Maybe<Scalars['Int']>;\n  transactionCountBigInt?: Maybe<Scalars['BigInt']>;\n  uncleCount?: Maybe<Scalars['Int']>;\n  uncleCountBigInt?: Maybe<Scalars['BigInt']>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlocksanyArgs = {\n  of: EthereumBlocksMeasureable;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlockscountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n  uniq?: InputMaybe<EthereumBlocksUniq>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlockscountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n  uniq?: InputMaybe<EthereumBlocksUniq>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlocksdifficultyArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlockshashArgs = {\n  blockHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlocksheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlocksmaximumArgs = {\n  get?: InputMaybe<EthereumBlocksMeasureable>;\n  of: EthereumBlocksMeasureable;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlocksminerArgs = {\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlocksminimumArgs = {\n  get?: InputMaybe<EthereumBlocksMeasureable>;\n  of: EthereumBlocksMeasureable;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlocksrewardArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlockssizeArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlockstimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlockstotalDifficultyArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlockstransactionCountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlockstransactionCountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlocksuncleCountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\n\n/** Blocks in Ethereum blockchain */\nexport type EthereumBlocksuncleCountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockReward?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<EthereumAddressSelector>>;\n  size?: InputMaybe<Array<IntegerSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionCount?: InputMaybe<Array<IntegerSelector>>;\n  uncleCount?: InputMaybe<Array<IntegerSelector>>;\n};\n\nexport enum EthereumBlocksMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Block Reward */\n  block_reward = 'block_reward',\n  /** Date */\n  date = 'date',\n  /** Block Miner */\n  miner = 'miner',\n  /** Time */\n  time = 'time'\n}\n\nexport enum EthereumBlocksUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique miner count */\n  miners = 'miners'\n}\n\nexport enum EthereumCallsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Call depth */\n  call_depth = 'call_depth',\n  /** Caller */\n  caller = 'caller',\n  /** Date */\n  date = 'date',\n  /** Smart Contract Method Signature */\n  signature = 'signature',\n  /** Smart Contract Method Signature Hash */\n  signature_hash = 'signature_hash',\n  /** Smart Contract Method Name */\n  signature_name = 'signature_name',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\n/** Coinpath */\nexport type EthereumCoinpath = {\n  __typename?: 'EthereumCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<EthereumAddressInfo>;\n  /** Sender address */\n  sender?: Maybe<EthereumAddressInfo>;\n  /** Transaction of transfer happened */\n  transaction?: Maybe<TransactionHashValue>;\n  /** Attributes of transaction included in Coinpath result */\n  transactions?: Maybe<Array<CoinpathEntry>>;\n};\n\n\n/** Coinpath */\nexport type EthereumCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Coinpath */\nexport type EthereumCoinpathanyArgs = {\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type EthereumCoinpathmaximumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type EthereumCoinpathminimumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n/**\n * Currency selector in Ethereum blockchain.\n *   Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.\n *   You can specify currency symbol or smart contract address. Symbols ETH/ETC are reserved for native currencies in Ethereum mainnet and classic.\n *   Ethereum Smart contract address should start from 0x and contain 40 hex digits.\n *   If digits are case sensitive, address is checked against checksum according to EIP-55.\n */\nexport type EthereumCurrencySelector = {\n  /** Currency in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Currency is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Currency not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Currency not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Ethereum DEX attributes */\nexport type EthereumDex = {\n  __typename?: 'EthereumDex';\n  /** Address for DEX exchange identification */\n  address: Address;\n  /** Full name ( name for known, Protocol for unknown ) */\n  fullName: Scalars['String'];\n  /** Full name ( name for known, Protocol / address for unknown ) */\n  fullNameWithId: Scalars['String'];\n  /** Name for known exchanges */\n  name?: Maybe<Scalars['String']>;\n};\n\nexport type EthereumDexTradeFilter = {\n  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  taker?: InputMaybe<Array<EthereumAddressSelector>>;\n  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTrades = {\n  __typename?: 'EthereumDexTrades';\n  /** Trader (maker or taker) */\n  address?: Maybe<EthereumAddressInfo>;\n  any?: Maybe<Scalars['String']>;\n  baseAmount?: Maybe<Scalars['Float']>;\n  /** Base currency */\n  baseCurrency?: Maybe<Currency>;\n  /** Block in the blockchain */\n  block?: Maybe<BlockExtended>;\n  buyAmount?: Maybe<Scalars['Float']>;\n  /** Maker buys this currency */\n  buyCurrency?: Maybe<Currency>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Identification of admin / manager / factory of smart contract, executing trades */\n  exchange?: Maybe<EthereumDex>;\n  gas?: Maybe<Scalars['Float']>;\n  /** Gas price in Gwei */\n  gasPrice: Scalars['Float'];\n  gasValue?: Maybe<Scalars['Float']>;\n  /** Trade 'maker' side */\n  maker?: Maybe<EthereumAddressInfo>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  price?: Maybe<Scalars['Float']>;\n  /** Protocol name of the smart contract */\n  protocol?: Maybe<Scalars['String']>;\n  quoteAmount?: Maybe<Scalars['Float']>;\n  /** Quote currency */\n  quoteCurrency?: Maybe<Currency>;\n  quotePrice?: Maybe<Scalars['Float']>;\n  sellAmount?: Maybe<Scalars['Float']>;\n  /** Maker sells this currency */\n  sellCurrency?: Maybe<Currency>;\n  /** Side of trade ( SELL / BUY ) */\n  side?: Maybe<TradeSide>;\n  /** Smart contract being called */\n  smartContract?: Maybe<EthereumSmartContract>;\n  /** Trade 'taker' side */\n  taker?: Maybe<EthereumAddressInfo>;\n  /** Time interval */\n  timeInterval?: Maybe<TimeInterval>;\n  tradeAmount?: Maybe<Scalars['Float']>;\n  /** Index of trade in transaction, used to separate trades in transaction */\n  tradeIndex?: Maybe<Scalars['String']>;\n  /** Transaction of DexTrade */\n  transaction?: Maybe<EthereumTransactionInfoExtended>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesaddressArgs = {\n  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesanyArgs = {\n  of: EthereumDexTradesMeasureable;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesbaseAmountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesbaseCurrencyArgs = {\n  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesbuyAmountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesbuyCurrencyArgs = {\n  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradescountArgs = {\n  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  taker?: InputMaybe<Array<EthereumAddressSelector>>;\n  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n  uniq?: InputMaybe<EthereumDexTradesUniq>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradescountBigIntArgs = {\n  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  taker?: InputMaybe<Array<EthereumAddressSelector>>;\n  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n  uniq?: InputMaybe<EthereumDexTradesUniq>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesexchangeArgs = {\n  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesgasArgs = {\n  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  taker?: InputMaybe<Array<EthereumAddressSelector>>;\n  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesgasPriceArgs = {\n  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  taker?: InputMaybe<Array<EthereumAddressSelector>>;\n  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesgasValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesmakerArgs = {\n  maker?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesmaximumArgs = {\n  get?: InputMaybe<EthereumDexTradesMeasureable>;\n  of: EthereumDexTradesMeasureable;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesminimumArgs = {\n  get?: InputMaybe<EthereumDexTradesMeasureable>;\n  of: EthereumDexTradesMeasureable;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradespriceArgs = {\n  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  calculate?: InputMaybe<PriceAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  taker?: InputMaybe<Array<EthereumAddressSelector>>;\n  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesprotocolArgs = {\n  protocol?: InputMaybe<Array<StringSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesquoteAmountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesquoteCurrencyArgs = {\n  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradesquotePriceArgs = {\n  baseCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  calculate?: InputMaybe<PriceAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<EthereumAddressSelector>>;\n  makerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  taker?: InputMaybe<Array<EthereumAddressSelector>>;\n  takerSmartContractType?: InputMaybe<Array<SmartContractTypeSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradessellAmountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradessellCurrencyArgs = {\n  sellCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradessmartContractArgs = {\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradestakerArgs = {\n  taker?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradestradeAmountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in: BaseCurrencyEnum;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradestradeIndexArgs = {\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type EthereumDexTradestransactionArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\nexport enum EthereumDexTradesMeasureable {\n  /** Block */\n  block = 'block',\n  /** Buy Amount */\n  buy_amount = 'buy_amount',\n  /** Buy Token address */\n  buy_currency_address = 'buy_currency_address',\n  /** Buy Currency symbol */\n  buy_currency_symbol = 'buy_currency_symbol',\n  /** Date */\n  date = 'date',\n  /** Maker */\n  maker = 'maker',\n  /** Price */\n  price = 'price',\n  /** Quote Price */\n  quote_price = 'quote_price',\n  /** Sell Amount */\n  sell_amount = 'sell_amount',\n  /** Sell Token address */\n  sell_currency_address = 'sell_currency_address',\n  /** Sell Currency symbol */\n  sell_currency_symbol = 'sell_currency_symbol',\n  /** Taker */\n  taker = 'taker',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\nexport enum EthereumDexTradesUniq {\n  /** Unique makers & takers count */\n  address = 'address',\n  /** Base currencies count */\n  base_currency = 'base_currency',\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Buy currencies count */\n  buy_currency = 'buy_currency',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique makers count */\n  makers = 'makers',\n  /** Unique protocols count */\n  protocols = 'protocols',\n  /** Quote currencies count */\n  quote_currency = 'quote_currency',\n  /** Sell currencies count */\n  sell_currency = 'sell_currency',\n  /** Unique TX senders count */\n  senders = 'senders',\n  /** Unique smart contract count */\n  smart_contracts = 'smart_contracts',\n  /** Unique makers count */\n  takers = 'takers',\n  /** Unique transactions count */\n  txs = 'txs'\n}\n\nexport enum EthereumEventsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Smart Contract Event Signature */\n  signature = 'signature',\n  /** Smart Contract Event Signature Hash */\n  signature_hash = 'signature_hash',\n  /** Smart Contract Event Name */\n  signature_name = 'signature_name',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\nexport enum EthereumNetwork {\n  /** Binance Smart Chain Mainnet */\n  bsc = 'bsc',\n  /** Binance Smart Chain Testnet */\n  bsc_testnet = 'bsc_testnet',\n  /** Celo Alfajores Testnet */\n  celo_alfajores = 'celo_alfajores',\n  /** Celo Baklava Testnet */\n  celo_baklava = 'celo_baklava',\n  /** Celo RC1 */\n  celo_rc1 = 'celo_rc1',\n  /** Ethereum Classic */\n  ethclassic = 'ethclassic',\n  /** Ethereum Classic ( no reorg from block 10904146) */\n  ethclassic_reorg = 'ethclassic_reorg',\n  /** Ethereum Mainnet */\n  ethereum = 'ethereum',\n  /** Goerli Ethereum Testnet */\n  goerli = 'goerli',\n  /** Klaytn Mainnet */\n  klaytn = 'klaytn',\n  /** Matic (Polygon) Mainnet */\n  matic = 'matic',\n  /** Velas Mainnet */\n  velas = 'velas',\n  /** Velas Testnet */\n  velas_testnet = 'velas_testnet'\n}\n\n/** Ethereum smart contract */\nexport type EthereumSmartContract = {\n  __typename?: 'EthereumSmartContract';\n  /** Smart Contract Address */\n  address: Address;\n  /** Smart Contract Type */\n  contractType?: Maybe<SmartContractType>;\n  /** Token implemented in this smart contract */\n  currency?: Maybe<Currency>;\n  /** Smart Contract Protocol Type */\n  protocolType?: Maybe<Scalars['String']>;\n};\n\nexport type EthereumSmartContractCallFilter = {\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCalls = {\n  __typename?: 'EthereumSmartContractCalls';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Call arguments */\n  arguments?: Maybe<Array<ArgumentNameValue>>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */\n  callDepth?: Maybe<Scalars['String']>;\n  /** Caller of the method invocation ( tx sender or another smart contract ) */\n  caller?: Maybe<EthereumAddressInfo>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */\n  external?: Maybe<Scalars['Boolean']>;\n  /** Gas used for transaction in external call, or by methd in internal call */\n  gasValue?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Smart contract being called */\n  smartContract?: Maybe<EthereumSmartContract>;\n  /** Contract method invoked */\n  smartContractMethod?: Maybe<Method>;\n  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Transaction where call happened */\n  transaction?: Maybe<EthereumTransactionInfo>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallsamountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallsanyArgs = {\n  of: EthereumCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallscallerArgs = {\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallscountArgs = {\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallscountBigIntArgs = {\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallsexternalArgs = {\n  external?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallsgasValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  caller?: InputMaybe<Array<EthereumAddressSelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallsmaximumArgs = {\n  get?: InputMaybe<EthereumCallsMeasureable>;\n  of: EthereumCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallsminimumArgs = {\n  get?: InputMaybe<EthereumCallsMeasureable>;\n  of: EthereumCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallssmartContractArgs = {\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallssmartContractMethodArgs = {\n  smartContractMethod?: InputMaybe<MethodSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallssuccessArgs = {\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n};\n\n\n/** Smart Contract Calls */\nexport type EthereumSmartContractCallstransactionArgs = {\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n/** Smart Contract Events */\nexport type EthereumSmartContractEvent = {\n  __typename?: 'EthereumSmartContractEvent';\n  any?: Maybe<Scalars['String']>;\n  /** Event arguments */\n  arguments?: Maybe<Array<ArgumentNameValue>>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Event index */\n  eventIndex?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Smart contract being called */\n  smartContract?: Maybe<EthereumSmartContract>;\n  /** Contract event logged */\n  smartContractEvent?: Maybe<Event>;\n  /** Transaction where event happened */\n  transaction?: Maybe<EthereumTransactionInfo>;\n};\n\n\n/** Smart Contract Events */\nexport type EthereumSmartContractEventanyArgs = {\n  of: EthereumEventsMeasureable;\n};\n\n\n/** Smart Contract Events */\nexport type EthereumSmartContractEventblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type EthereumSmartContractEventcountArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Events */\nexport type EthereumSmartContractEventcountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Events */\nexport type EthereumSmartContractEventmaximumArgs = {\n  get?: InputMaybe<EthereumEventsMeasureable>;\n  of: EthereumEventsMeasureable;\n};\n\n\n/** Smart Contract Events */\nexport type EthereumSmartContractEventminimumArgs = {\n  get?: InputMaybe<EthereumEventsMeasureable>;\n  of: EthereumEventsMeasureable;\n};\n\n\n/** Smart Contract Events */\nexport type EthereumSmartContractEventsmartContractArgs = {\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Smart Contract Events */\nexport type EthereumSmartContractEventsmartContractEventArgs = {\n  smartContractEvent?: InputMaybe<EventSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type EthereumSmartContractEventtransactionArgs = {\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\nexport type EthereumSmartContractEventFilter = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<Array<EthereumAddressSelector>>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  smartContractType?: InputMaybe<SmartContractTypeSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n/** Blockchain smart contract */\nexport type EthereumSmartContractInfo = {\n  __typename?: 'EthereumSmartContractInfo';\n  /** Smart Contract Type */\n  contractType?: Maybe<SmartContractType>;\n  /** Token implemented in this smart contract */\n  currency?: Maybe<Currency>;\n  /** Smart Contract Protocol Type */\n  protocolType?: Maybe<Scalars['String']>;\n};\n\n/** Blockchain smart contract */\nexport type EthereumSmartContractInfoWithAttributes = {\n  __typename?: 'EthereumSmartContractInfoWithAttributes';\n  /** Attributes from readonly methods */\n  attributes?: Maybe<Array<SmartContractReadonlyAttribute>>;\n  /** Smart Contract Type */\n  contractType?: Maybe<SmartContractType>;\n  /** Token implemented in this smart contract */\n  currency?: Maybe<Currency>;\n  /** Smart Contract Protocol Type */\n  protocolType?: Maybe<Scalars['String']>;\n};\n\nexport type EthereumTransactionFilter = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  gasValue?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n/** Blockchain transaction info */\nexport type EthereumTransactionInfo = {\n  __typename?: 'EthereumTransactionInfo';\n  /** Gas consumed */\n  gas: Scalars['Int'];\n  /** Gas price in Gwei */\n  gasPrice: Scalars['Float'];\n  /** Gas value cost */\n  gasValue: Scalars['Float'];\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction from address */\n  txFrom: EthereumAddressInfo;\n};\n\n/** Blockchain Transaction Extended info */\nexport type EthereumTransactionInfoExtended = {\n  __typename?: 'EthereumTransactionInfoExtended';\n  /** Gas consumed */\n  gas: Scalars['Int'];\n  /** Gas price in Gwei */\n  gasPrice: Scalars['Float'];\n  /** Gas value cost */\n  gasValue: Scalars['Float'];\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0 based */\n  index?: Maybe<Scalars['Int']>;\n  /** Transaction nonce */\n  nonce?: Maybe<Scalars['Int']>;\n  /** Transaction receiver */\n  to?: Maybe<EthereumAddressInfo>;\n  /** Transaction from address */\n  txFrom: EthereumAddressInfo;\n};\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactions = {\n  __typename?: 'EthereumTransactions';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Created smart contract */\n  creates?: Maybe<EthereumAddressInfo>;\n  /** Currency of amount */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Error message if any */\n  error?: Maybe<Scalars['String']>;\n  gas?: Maybe<Scalars['Float']>;\n  /** Currency of gas */\n  gasCurrency?: Maybe<Currency>;\n  /** Gas price in Gwei */\n  gasPrice: Scalars['Float'];\n  gasValue?: Maybe<Scalars['Float']>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0 based */\n  index?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transaction nonce */\n  nonce?: Maybe<Scalars['Int']>;\n  /** Transaction sender */\n  sender?: Maybe<EthereumAddressInfo>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Transaction receiver */\n  to?: Maybe<EthereumAddressInfo>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionsamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  gasValue?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionsanyArgs = {\n  of: EthereumTransactionsMeasureable;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionscountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  gasValue?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n  uniq?: InputMaybe<EthereumTransactionsUniq>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionscountBigIntArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  gasValue?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n  uniq?: InputMaybe<EthereumTransactionsUniq>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionscreatesArgs = {\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionsgasArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  gasValue?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionsgasCurrencyArgs = {\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionsgasPriceArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  gasValue?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionsgasValueArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  gasValue?: InputMaybe<Array<AmountSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txCreates?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionshashArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionsindexArgs = {\n  txIndex?: InputMaybe<Array<TxIndexSelector>>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionsmaximumArgs = {\n  get?: InputMaybe<EthereumTransactionsMeasureable>;\n  of: EthereumTransactionsMeasureable;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionsminimumArgs = {\n  get?: InputMaybe<EthereumTransactionsMeasureable>;\n  of: EthereumTransactionsMeasureable;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionssenderArgs = {\n  txSender?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transactions in Ethereum blockchain */\nexport type EthereumTransactionstoArgs = {\n  txTo?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\nexport enum EthereumTransactionsMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Gas used */\n  gas = 'gas',\n  /** Gas price */\n  gas_price = 'gas_price',\n  /** Gas value */\n  gas_value = 'gas_value',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction Sender */\n  tx_sender = 'tx_sender'\n}\n\nexport enum EthereumTransactionsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique TX receivers count */\n  receivers = 'receivers',\n  /** Unique TX senders count */\n  senders = 'senders'\n}\n\nexport type EthereumTransferFilter = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<Array<EthereumAddressSelector>>;\n  sender?: InputMaybe<Array<EthereumAddressSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransfers = {\n  __typename?: 'EthereumTransfers';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Entity identifier ( for ERC-721 NFT tokens ) */\n  entityId?: Maybe<Scalars['String']>;\n  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */\n  external?: Maybe<Scalars['Boolean']>;\n  gasValue?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transfer receiver */\n  receiver?: Maybe<EthereumAddressInfo>;\n  /** Transfer sender */\n  sender?: Maybe<EthereumAddressInfo>;\n  /** Success flag */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Transaction where transfer happened */\n  transaction?: Maybe<EthereumTransactionInfo>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransfersamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  receiver?: InputMaybe<Array<EthereumAddressSelector>>;\n  sender?: InputMaybe<Array<EthereumAddressSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransfersanyArgs = {\n  of: EthereumTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransfersblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransferscountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<Array<EthereumAddressSelector>>;\n  sender?: InputMaybe<Array<EthereumAddressSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransferscountBigIntArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<Array<EthereumAddressSelector>>;\n  sender?: InputMaybe<Array<EthereumAddressSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransferscurrencyArgs = {\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransfersentityIdArgs = {\n  entityId?: InputMaybe<EntitySelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransfersexternalArgs = {\n  external?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransfersgasValueArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<EthereumCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  receiver?: InputMaybe<Array<EthereumAddressSelector>>;\n  sender?: InputMaybe<Array<EthereumAddressSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransfersmaximumArgs = {\n  get?: InputMaybe<EthereumTransfersMeasureable>;\n  of: EthereumTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransfersminimumArgs = {\n  get?: InputMaybe<EthereumTransfersMeasureable>;\n  of: EthereumTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransfersreceiverArgs = {\n  receiver?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransferssenderArgs = {\n  sender?: InputMaybe<Array<EthereumAddressSelector>>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransferssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type EthereumTransferstransactionArgs = {\n  txFrom?: InputMaybe<Array<EthereumAddressSelector>>;\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\nexport enum EthereumTransfersMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Token address */\n  currency_address = 'currency_address',\n  /** Currency symbol */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** Entity ID */\n  entity_id = 'entity_id',\n  /** Receiver */\n  receiver = 'receiver',\n  /** Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\n/** Smart contract event */\nexport type Event = {\n  __typename?: 'Event';\n  /** Name */\n  name?: Maybe<Scalars['String']>;\n  /** Signature */\n  signature?: Maybe<Scalars['String']>;\n  /** Signature Hash */\n  signatureHash: Scalars['String'];\n};\n\n/** Smart contract event. In selector you can use the name, signature or hex hash */\nexport type EventSelector = {\n  /** Event signature in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Event signature is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Event signature not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Event signature not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Filecoin */\nexport type Filecoin = {\n  __typename?: 'Filecoin';\n  /** Filecoin Network Blocks */\n  blocks?: Maybe<Array<FilecoinBlock>>;\n  /** Filecoin Network Calls */\n  calls?: Maybe<Array<FilecoinCalls>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<FilecoinCoinpath>>;\n  /** Filecoin Network Messages ( blocks, transfers, ... ) */\n  messages?: Maybe<Array<FilecoinMessages>>;\n  /** Filecoin Network Currency Transfers */\n  transfers?: Maybe<Array<FilecoinTransfers>>;\n};\n\n\n/** Filecoin */\nexport type FilecoinblocksArgs = {\n  any?: InputMaybe<Array<FilecoinBlockFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Filecoin */\nexport type FilecoincallsArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  any?: InputMaybe<Array<FilecoinCallFilter>>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  messageMethod?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Filecoin */\nexport type FilecoincoinpathArgs = {\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<AddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CoinpathOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Filecoin */\nexport type FilecoinmessagesArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  any?: InputMaybe<Array<FilecoinMessageFilter>>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Filecoin */\nexport type FilecointransfersArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  any?: InputMaybe<Array<FilecoinTransferFilter>>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  messageMethod?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transferType?: InputMaybe<TransferTypeSelector>;\n};\n\n/** Block */\nexport type FilecoinBlock = {\n  __typename?: 'FilecoinBlock';\n  any?: Maybe<Scalars['String']>;\n  blockSig?: Maybe<NameWithId>;\n  blsAggregate?: Maybe<NameWithId>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  electionProof?: Maybe<Scalars['String']>;\n  forkSignalling?: Maybe<Scalars['BigInt']>;\n  /** Block hash */\n  hash: Scalars['String'];\n  /** Block round in blockchain */\n  height: Scalars['Int'];\n  /** Block index on height */\n  index?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  messageCount?: Maybe<Scalars['Int']>;\n  messageCountBigInt?: Maybe<Scalars['BigInt']>;\n  messages?: Maybe<Scalars['String']>;\n  /** Miner */\n  miner?: Maybe<Address>;\n  minerTips?: Maybe<Scalars['Float']>;\n  minimum?: Maybe<Scalars['String']>;\n  parentMessageReceipts?: Maybe<Scalars['String']>;\n  parentStateRoot?: Maybe<Scalars['String']>;\n  parentWeight?: Maybe<Scalars['BigInt']>;\n  reward?: Maybe<Scalars['Float']>;\n  ticket?: Maybe<Scalars['String']>;\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n  totalReward?: Maybe<Scalars['Float']>;\n  winCount?: Maybe<Scalars['Int']>;\n  winCountBigInt?: Maybe<Scalars['BigInt']>;\n  wincount?: Maybe<Scalars['Int']>;\n};\n\n\n/** Block */\nexport type FilecoinBlockanyArgs = {\n  of: FilecoinBlocksMeasureable;\n};\n\n\n/** Block */\nexport type FilecoinBlockcountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<FilecoinBlockUniq>;\n};\n\n\n/** Block */\nexport type FilecoinBlockcountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<FilecoinBlockUniq>;\n};\n\n\n/** Block */\nexport type FilecoinBlockhashArgs = {\n  blockHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Block */\nexport type FilecoinBlockheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Block */\nexport type FilecoinBlockindexArgs = {\n  blockIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block */\nexport type FilecoinBlockmaximumArgs = {\n  get?: InputMaybe<FilecoinBlocksMeasureable>;\n  of: FilecoinBlocksMeasureable;\n};\n\n\n/** Block */\nexport type FilecoinBlockmessageCountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type FilecoinBlockmessageCountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type FilecoinBlockminerArgs = {\n  miner?: InputMaybe<AddressSelector>;\n};\n\n\n/** Block */\nexport type FilecoinBlockminerTipsArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type FilecoinBlockminimumArgs = {\n  get?: InputMaybe<FilecoinBlocksMeasureable>;\n  of: FilecoinBlocksMeasureable;\n};\n\n\n/** Block */\nexport type FilecoinBlockrewardArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type FilecoinBlocktimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type FilecoinBlocktotalRewardArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type FilecoinBlockwinCountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type FilecoinBlockwinCountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport type FilecoinBlockFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  blockIndex?: InputMaybe<IntegerSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport enum FilecoinBlockUniq {\n  /** Unique block count */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique block height count */\n  heights = 'heights',\n  /** Miner */\n  miners = 'miners'\n}\n\nexport enum FilecoinBlocksMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Block Miner */\n  miner = 'miner',\n  /** Time */\n  time = 'time'\n}\n\nexport type FilecoinCallFilter = {\n  amount?: InputMaybe<AmountSelector>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  messageMethod?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCalls = {\n  __typename?: 'FilecoinCalls';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer Message is included */\n  block?: Maybe<Block>;\n  /** Call hash */\n  callHash?: Maybe<Scalars['String']>;\n  /** Call hash */\n  callPath?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  exitCode?: Maybe<Scalars['BigInt']>;\n  gas?: Maybe<Scalars['Int']>;\n  gasFeeCap?: Maybe<Scalars['BigInt']>;\n  gasLimit?: Maybe<Scalars['BigInt']>;\n  gasPremium?: Maybe<Scalars['Float']>;\n  /** Message hash */\n  hash?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Message Method */\n  messageMethod?: Maybe<NameWithId>;\n  /** Method */\n  method?: Maybe<NameWithId>;\n  minedBlock?: Maybe<FilecoinMinedBlock>;\n  minimum?: Maybe<Scalars['String']>;\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** Message receiver */\n  receiver?: Maybe<AddressWithAccount>;\n  returnValue?: Maybe<Scalars['String']>;\n  /** Message sender */\n  sender?: Maybe<AddressWithAccount>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallsamountArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  messageMethod?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallsanyArgs = {\n  of: FilecoinCallsMeasureable;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallscountArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  messageMethod?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<FilecoinMessagesUniq>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallscountBigIntArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  messageMethod?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<FilecoinMessagesUniq>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallsgasArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallshashArgs = {\n  hash?: InputMaybe<HashSelector>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallsmaximumArgs = {\n  get?: InputMaybe<FilecoinCallsMeasureable>;\n  of: FilecoinCallsMeasureable;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallsmessageMethodArgs = {\n  messageMethod?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallsmethodArgs = {\n  method?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallsminimumArgs = {\n  get?: InputMaybe<FilecoinCallsMeasureable>;\n  of: FilecoinCallsMeasureable;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallsreceiverArgs = {\n  receiver?: InputMaybe<AddressSelector>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallssenderArgs = {\n  sender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Calls in Filecoin blockchain */\nexport type FilecoinCallssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport enum FilecoinCallsMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Gas used */\n  gas = 'gas',\n  /** Gas limit */\n  gas_limit = 'gas_limit',\n  /** Gas value */\n  gas_value = 'gas_value',\n  /** Message hash */\n  message_hash = 'message_hash',\n  /** Time */\n  time = 'time'\n}\n\n/** Coinpath */\nexport type FilecoinCoinpath = {\n  __typename?: 'FilecoinCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Message of transfer happened */\n  message?: Maybe<TransactionHashValue>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<Address>;\n  /** Sender address */\n  sender?: Maybe<Address>;\n};\n\n\n/** Coinpath */\nexport type FilecoinCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Coinpath */\nexport type FilecoinCoinpathanyArgs = {\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type FilecoinCoinpathmaximumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type FilecoinCoinpathminimumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\nexport type FilecoinMessageFilter = {\n  amount?: InputMaybe<AmountSelector>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessages = {\n  __typename?: 'FilecoinMessages';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  baseFeeBurn?: Maybe<Scalars['Float']>;\n  /** Block where transfer Message is included */\n  block?: Maybe<Block>;\n  burned?: Maybe<Scalars['Float']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  exitCode?: Maybe<Scalars['BigInt']>;\n  gas?: Maybe<Scalars['Int']>;\n  gasFeeCap?: Maybe<Scalars['BigInt']>;\n  gasLimit?: Maybe<Scalars['BigInt']>;\n  gasPremium?: Maybe<Scalars['Float']>;\n  /** Message hash */\n  hash?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Method */\n  method?: Maybe<NameWithId>;\n  minedBlock?: Maybe<FilecoinMinedBlock>;\n  minerPenalty?: Maybe<Scalars['Float']>;\n  minerTip?: Maybe<Scalars['Float']>;\n  minimum?: Maybe<Scalars['String']>;\n  nonce?: Maybe<Scalars['BigInt']>;\n  overEstimationBurn?: Maybe<Scalars['Float']>;\n  /** Message receiver */\n  receiver?: Maybe<AddressWithAccount>;\n  refund?: Maybe<Scalars['Float']>;\n  returnValue?: Maybe<Scalars['String']>;\n  /** Message sender */\n  sender?: Maybe<AddressWithAccount>;\n  signature?: Maybe<Scalars['String']>;\n  signatureType?: Maybe<Scalars['String']>;\n  /** Signed Message hash */\n  signedHash?: Maybe<Scalars['String']>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  totalCost?: Maybe<Scalars['Float']>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesamountArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesanyArgs = {\n  of: FilecoinMessagesMeasureable;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesbaseFeeBurnArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesburnedArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagescountArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<FilecoinMessagesUniq>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagescountBigIntArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<FilecoinMessagesUniq>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesgasArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessageshashArgs = {\n  hash?: InputMaybe<HashSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesmaximumArgs = {\n  get?: InputMaybe<FilecoinMessagesMeasureable>;\n  of: FilecoinMessagesMeasureable;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesmethodArgs = {\n  method?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesminerPenaltyArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesminerTipArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesminimumArgs = {\n  get?: InputMaybe<FilecoinMessagesMeasureable>;\n  of: FilecoinMessagesMeasureable;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesoverEstimationBurnArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesreceiverArgs = {\n  receiver?: InputMaybe<AddressSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagesrefundArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagessenderArgs = {\n  sender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagessuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Messages in Filecoin blockchain */\nexport type FilecoinMessagestotalCostArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  index?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport enum FilecoinMessagesMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Gas used */\n  gas = 'gas',\n  /** Gas limit */\n  gas_limit = 'gas_limit',\n  /** Gas value */\n  gas_value = 'gas_value',\n  /** Message hash */\n  message_hash = 'message_hash',\n  /** Time */\n  time = 'time'\n}\n\nexport enum FilecoinMessagesUniq {\n  /** Unique block heights */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Message receivers */\n  receivers = 'receivers',\n  /** Unique Message senders */\n  senders = 'senders'\n}\n\n/** Filecoin Mined Block */\nexport type FilecoinMinedBlock = {\n  __typename?: 'FilecoinMinedBlock';\n  /** Hash */\n  hash?: Maybe<Scalars['String']>;\n  /** Index on height */\n  index?: Maybe<Scalars['Int']>;\n  /** Miner */\n  miner?: Maybe<Address>;\n};\n\nexport enum FilecoinNetwork {\n  /** Filecoin Mainnet */\n  filecoin = 'filecoin'\n}\n\nexport type FilecoinTransferFilter = {\n  amount?: InputMaybe<AmountSelector>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  messageMethod?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transferType?: InputMaybe<TransferTypeSelector>;\n};\n\nexport enum FilecoinTransferType {\n  /** Burn */\n  burn = 'burn',\n  /** Genesis */\n  genesis = 'genesis',\n  /** Miner Tip */\n  miner = 'miner',\n  /** Rebalance */\n  rebalance = 'rebalance',\n  /** Reward */\n  reward = 'reward',\n  /** Send (transfer) */\n  send = 'send'\n}\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransfers = {\n  __typename?: 'FilecoinTransfers';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer Transfer is included */\n  block?: Maybe<BlockExtended>;\n  /** Call hash */\n  callHash?: Maybe<Scalars['String']>;\n  /** Call hash */\n  callPath?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Message hash */\n  hash?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Message Method */\n  messageMethod?: Maybe<NameWithId>;\n  /** Method */\n  method?: Maybe<NameWithId>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transfer receiver */\n  receiver?: Maybe<Address>;\n  /** Transfer sender */\n  sender?: Maybe<Address>;\n  /** Transfer timestamp */\n  timestamp?: Maybe<DateTime>;\n  /** Type of transfer */\n  transferType?: Maybe<FilecoinTransferType>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransfersamountArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  messageMethod?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transferType?: InputMaybe<TransferTypeSelector>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransfersanyArgs = {\n  of: FilecoinTransfersMeasureable;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransfersblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransferscountArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  messageMethod?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transferType?: InputMaybe<TransferTypeSelector>;\n  uniq?: InputMaybe<FilecoinMessagesUniq>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransferscountBigIntArgs = {\n  amount?: InputMaybe<AmountSelector>;\n  date?: InputMaybe<DateSelector>;\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  messageMethod?: InputMaybe<IntegerSelector>;\n  method?: InputMaybe<IntegerSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transferType?: InputMaybe<TransferTypeSelector>;\n  uniq?: InputMaybe<FilecoinMessagesUniq>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransfershashArgs = {\n  hash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransfersmaximumArgs = {\n  get?: InputMaybe<FilecoinTransfersMeasureable>;\n  of: FilecoinTransfersMeasureable;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransfersmessageMethodArgs = {\n  messageMethod?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransfersmethodArgs = {\n  method?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransfersminimumArgs = {\n  get?: InputMaybe<FilecoinTransfersMeasureable>;\n  of: FilecoinTransfersMeasureable;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransfersreceiverArgs = {\n  receiver?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransferssenderArgs = {\n  sender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransferstimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transfers in Filecoin blockchain */\nexport type FilecoinTransferstransferTypeArgs = {\n  transferType?: InputMaybe<TransferTypeSelector>;\n};\n\nexport enum FilecoinTransfersMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Gas used */\n  gas = 'gas',\n  /** Gas limit */\n  gas_limit = 'gas_limit',\n  /** Gas value */\n  gas_value = 'gas_value',\n  /** Time */\n  time = 'time',\n  /** Transfer hash */\n  tx_hash = 'tx_hash',\n  /** Value */\n  value = 'value'\n}\n\n/** Select by number */\nexport type FloatSelector = {\n  /** in range */\n  between?: InputMaybe<Array<Scalars['Float']>>;\n  /** greater than */\n  gt?: InputMaybe<Scalars['Float']>;\n  /** greater or equal than */\n  gteq?: InputMaybe<Scalars['Float']>;\n  /** in the list */\n  in?: InputMaybe<Array<Scalars['Float']>>;\n  /** is */\n  is?: InputMaybe<Scalars['Float']>;\n  /** less than */\n  lt?: InputMaybe<Scalars['Float']>;\n  /** less or equal than */\n  lteq?: InputMaybe<Scalars['Float']>;\n  /** not */\n  not?: InputMaybe<Scalars['Float']>;\n  /** not in the list */\n  notIn?: InputMaybe<Array<Scalars['Float']>>;\n};\n\nexport enum FlowDirection {\n  /** Inbound transfers */\n  inbound = 'inbound',\n  /** Outbound transfers */\n  outbound = 'outbound'\n}\n\n/** Harmony Chain */\nexport type Harmony = {\n  __typename?: 'Harmony';\n  /** Arguments of Smart Contract Calls and Events */\n  arguments?: Maybe<Array<HarmonyArguments>>;\n  /** Harmony Blocks */\n  blocks?: Maybe<Array<HarmonyBlocks>>;\n  /** Smart Contract Calls */\n  smartContractCalls?: Maybe<Array<HarmonySmartContractCalls>>;\n  /** Smart Contract Events */\n  smartContractEvents?: Maybe<Array<HarmonySmartContractEvents>>;\n  /** Harmony Staking Transactions */\n  stakingTransactions?: Maybe<Array<HarmonyStakingTransactions>>;\n  /** Harmony Transactions */\n  transactions?: Maybe<Array<HarmonyTransactions>>;\n  /** Harmony Transfers */\n  transfers?: Maybe<Array<HarmonyTransfers>>;\n};\n\n\n/** Harmony Chain */\nexport type HarmonyargumentsArgs = {\n  any?: InputMaybe<Array<HarmonyArgumentsFilter>>;\n  argument?: InputMaybe<StringSelector>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<HashSelector>;\n  sender?: InputMaybe<HashSelector>;\n  smartContractAddress?: InputMaybe<HashSelector>;\n  smartContractId?: InputMaybe<IntegerSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Harmony Chain */\nexport type HarmonyblocksArgs = {\n  any?: InputMaybe<Array<HarmonyBlocksFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<HashSelector>;\n  options?: InputMaybe<QueryOptions>;\n  perentHash?: InputMaybe<HashSelector>;\n  stakingTransactionsCount?: InputMaybe<HashSelector>;\n  transactionCount?: InputMaybe<HashSelector>;\n  unclesCount?: InputMaybe<HashSelector>;\n  viewId?: InputMaybe<HashSelector>;\n};\n\n\n/** Harmony Chain */\nexport type HarmonysmartContractCallsArgs = {\n  any?: InputMaybe<Array<HarmonySmartContractCallsFilter>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Harmony Chain */\nexport type HarmonysmartContractEventsArgs = {\n  any?: InputMaybe<Array<HarmonySmartContractEventsFilter>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Harmony Chain */\nexport type HarmonystakingTransactionsArgs = {\n  any?: InputMaybe<Array<HarmonyStakingTransactionsFilter>>;\n  date?: InputMaybe<DateSelector>;\n  delegatorAddress?: InputMaybe<HashSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  status?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<StakingTransactionsTypeSelector>;\n  validatorAddress?: InputMaybe<HashSelector>;\n};\n\n\n/** Harmony Chain */\nexport type HarmonytransactionsArgs = {\n  any?: InputMaybe<Array<HarmonyTransactionsFilter>>;\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  reciever?: InputMaybe<HashSelector>;\n  sender?: InputMaybe<HashSelector>;\n  status?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Harmony Chain */\nexport type HarmonytransfersArgs = {\n  any?: InputMaybe<Array<HarmonyTransfersFilter>>;\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  sender?: InputMaybe<HashSelector>;\n  status?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArguments = {\n  __typename?: 'HarmonyArguments';\n  /** Value */\n  address?: Maybe<Scalars['String']>;\n  any?: Maybe<Scalars['String']>;\n  /** Argument Index */\n  argIndex?: Maybe<Scalars['String']>;\n  /** Argument Type */\n  argType?: Maybe<Scalars['String']>;\n  /** Argument */\n  argument?: Maybe<Scalars['String']>;\n  /** Transaction hash */\n  blockHash?: Maybe<Scalars['String']>;\n  /** Call Path */\n  callPath?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Epoch */\n  epoch?: Maybe<Scalars['BigInt']>;\n  /** Hash of the block where this transaction was in */\n  ledger?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** The number of transactions made by the sender prior to this one. */\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** Value */\n  number?: Maybe<Scalars['String']>;\n  /** Address of the receiver */\n  receiver?: Maybe<Scalars['String']>;\n  /** Address of the sender */\n  sender?: Maybe<Scalars['String']>;\n  /** ShardID */\n  shardId?: Maybe<Scalars['BigInt']>;\n  /** Signature ID */\n  signatureId?: Maybe<Scalars['BigInt']>;\n  /** Address of the smart contract */\n  smartContractAddress?: Maybe<Scalars['String']>;\n  /** Id of the smart contract */\n  smartContractId?: Maybe<Scalars['BigInt']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Value */\n  value?: Maybe<Scalars['String']>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentsanyArgs = {\n  of: HarmonyArgumentsMeasureable;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentsargumentArgs = {\n  argument?: InputMaybe<Scalars['String']>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentsblockHashArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentscountArgs = {\n  uniq?: InputMaybe<HarmonyArgumentsUniq>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentsledgerArgs = {\n  ledger?: InputMaybe<BlockSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentsmaximumArgs = {\n  get?: InputMaybe<HarmonyArgumentsMeasureable>;\n  of: HarmonyArgumentsMeasureable;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentsminimumArgs = {\n  get?: InputMaybe<HarmonyArgumentsMeasureable>;\n  of: HarmonyArgumentsMeasureable;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentsreceiverArgs = {\n  receiver?: InputMaybe<HashSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentssenderArgs = {\n  sender?: InputMaybe<HashSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentssmartContractAddressArgs = {\n  smartContractAddress?: InputMaybe<HashSelector>;\n};\n\n\n/** Arguments of Smart Contract Calls and Events */\nexport type HarmonyArgumentssmartContractIdArgs = {\n  smartContractAddress?: InputMaybe<IntegerSelector>;\n};\n\nexport type HarmonyArgumentsFilter = {\n  argument?: InputMaybe<StringSelector>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<HashSelector>;\n  sender?: InputMaybe<HashSelector>;\n  smartContractAddress?: InputMaybe<HashSelector>;\n  smartContractId?: InputMaybe<IntegerSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport enum HarmonyArgumentsMeasureable {\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Address of  the receive */\n  receiver = 'receiver',\n  /** Address of the sender */\n  sender = 'sender',\n  /** Signature */\n  signature = 'signature',\n  /** Hash of the signature */\n  signature_hash = 'signature_hash',\n  /** Name of the signature */\n  signature_name = 'signature_name',\n  /** Address of the smart contract */\n  smart_contract_address = 'smart_contract_address',\n  /** Id of the smart contract */\n  smart_contract_id = 'smart_contract_id',\n  /** Time */\n  time = 'time'\n}\n\nexport enum HarmonyArgumentsUniq {\n  /** Unique block hash count */\n  block_hash = 'block_hash',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique ledger count */\n  ledger = 'ledger',\n  /** Unique address of the receiver */\n  receiver = 'receiver',\n  /** Unique address of the sender */\n  sender = 'sender',\n  /** Unique smart contract address */\n  smart_contract_address = 'smart_contract_address',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocks = {\n  __typename?: 'HarmonyBlocks';\n  any?: Maybe<Scalars['String']>;\n  /** Transaction hash */\n  blockHash?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Difficulty */\n  difficulty?: Maybe<Scalars['String']>;\n  /** Epoch */\n  epoch?: Maybe<Scalars['BigInt']>;\n  /** The extra data field of this block */\n  extraData?: Maybe<Scalars['String']>;\n  /** Gas limit */\n  gasLimit?: Maybe<Scalars['BigInt']>;\n  /** Gas used */\n  gasUsed?: Maybe<Scalars['String']>;\n  /** Hash of the block where this transaction was in */\n  ledger?: Maybe<Scalars['BigInt']>;\n  /** The bloom filter for the logs of the block. null when its pending block */\n  logsBloom?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Transaction hash */\n  miner?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Mix Hash */\n  mixHash?: Maybe<Scalars['String']>;\n  /** Nonce */\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** Parent hash */\n  parentHash?: Maybe<Scalars['String']>;\n  /** Receipts Root */\n  receiptsRoot?: Maybe<Scalars['String']>;\n  /** ShardID */\n  shardId?: Maybe<Scalars['BigInt']>;\n  /** Integer the size of this block in bytes */\n  size?: Maybe<Scalars['BigInt']>;\n  /** Staking Transaction Count */\n  stakingTransactionsCount?: Maybe<Scalars['BigInt']>;\n  /** The root of the final state trie of the block */\n  stateRoot?: Maybe<Scalars['String']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Transaction Count */\n  transactionCount?: Maybe<Scalars['BigInt']>;\n  /** The root of the transaction trie of the block */\n  transactionsRoot?: Maybe<Scalars['String']>;\n  /** Count of ucles hashes */\n  unclesCount?: Maybe<Scalars['BigInt']>;\n  /** View ID */\n  viewId?: Maybe<Scalars['String']>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocksanyArgs = {\n  of: HarmonyBlocksMeasureable;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocksblockHashArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlockscountArgs = {\n  uniq?: InputMaybe<HarmonyBlocksUniq>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlockscountBigIntArgs = {\n  uniq?: InputMaybe<HarmonyBlocksUniq>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocksledgerArgs = {\n  ledger?: InputMaybe<BlockSelector>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocksmaximumArgs = {\n  get?: InputMaybe<HarmonyBlocksMeasureable>;\n  of: HarmonyBlocksMeasureable;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocksminerArgs = {\n  miner?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocksminimumArgs = {\n  get?: InputMaybe<HarmonyBlocksMeasureable>;\n  of: HarmonyBlocksMeasureable;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocksparentHashArgs = {\n  parentHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlockssizeArgs = {\n  size?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocksstakingTransactionsCountArgs = {\n  stakingTransactionsCount?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlockstransactionCountArgs = {\n  transactionCount?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocksunclesCountArgs = {\n  unclesCount?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Harmony blockchain */\nexport type HarmonyBlocksviewIdArgs = {\n  viewId?: InputMaybe<HashSelector>;\n};\n\nexport type HarmonyBlocksFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  miner?: InputMaybe<HashSelector>;\n  perentHash?: InputMaybe<HashSelector>;\n  stakingTransactionsCount?: InputMaybe<HashSelector>;\n  transactionCount?: InputMaybe<HashSelector>;\n  unclesCount?: InputMaybe<HashSelector>;\n  viewId?: InputMaybe<HashSelector>;\n};\n\nexport enum HarmonyBlocksMeasureable {\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Gas limit */\n  gas_limit = 'gas_limit',\n  /** Gas Used */\n  gas_used = 'gas_used',\n  /** Parent hash */\n  paret_hash = 'paret_hash',\n  /** Time */\n  time = 'time'\n}\n\nexport enum HarmonyBlocksUniq {\n  /** Unique block hash count */\n  block_hash = 'block_hash',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique ledger count */\n  ledger = 'ledger',\n  /** Unique miner count */\n  miner = 'miner',\n  /** Unique mix hash count */\n  mix_hash = 'mix_hash',\n  /** Unique parent hash count */\n  parent_hash = 'parent_hash',\n  /** Unique receipts root count */\n  receipts_root = 'receipts_root',\n  /** Unique state root count */\n  state_root = 'state_root',\n  /** Unique time */\n  times = 'times',\n  /** Unique transactions root count */\n  transactions_root = 'transactions_root'\n}\n\nexport enum HarmonyEventsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Smart Contract Method Signature */\n  signature = 'signature',\n  /** Smart Contract Method Signature Hash */\n  signature_hash = 'signature_hash',\n  /** Smart Contract Method Name */\n  signature_name = 'signature_name',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** Action From */\n  tx_from = 'tx_from',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Action To */\n  tx_to = 'tx_to'\n}\n\nexport enum HarmonyNetwork {\n  /** Harmony Mainnat */\n  harmony = 'harmony',\n  /** Harmony Testnet */\n  harmony_testnet = 'harmony_testnet'\n}\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCalls = {\n  __typename?: 'HarmonySmartContractCalls';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */\n  callPath?: Maybe<Scalars['String']>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** External call executed explicitly by caller. Internal calls executed by smart contracts. */\n  external?: Maybe<Scalars['Boolean']>;\n  gas?: Maybe<Scalars['Int']>;\n  /** Gas unit price */\n  gasPrice: Scalars['Float'];\n  gasValue?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Nonce */\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** Contract method invoked */\n  smartContractMethod?: Maybe<Method>;\n  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Action from address */\n  txFrom?: Maybe<Address>;\n  /** Transaction hash where transfer happened */\n  txHash?: Maybe<Scalars['String']>;\n  /** Transaction Sender */\n  txSender?: Maybe<Address>;\n  /** Action to address */\n  txTo?: Maybe<Address>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallsamountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallsanyArgs = {\n  of: HarmonySmartContractCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallscountArgs = {\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<HarmonySmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallscountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<HarmonySmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallsexternalArgs = {\n  external?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallsgasArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallsgasPriceArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallsgasValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallsmaximumArgs = {\n  get?: InputMaybe<HarmonySmartContractCallsMeasureable>;\n  of: HarmonySmartContractCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallsminimumArgs = {\n  get?: InputMaybe<HarmonySmartContractCallsMeasureable>;\n  of: HarmonySmartContractCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallsnonceArgs = {\n  nonce?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallssmartContractMethodArgs = {\n  smartContractMethod?: InputMaybe<MethodSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallssuccessArgs = {\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallstxFromArgs = {\n  txFrom?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallstxHashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallstxSenderArgs = {\n  txSender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type HarmonySmartContractCallstxToArgs = {\n  txTo?: InputMaybe<AddressSelector>;\n};\n\nexport type HarmonySmartContractCallsFilter = {\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\nexport enum HarmonySmartContractCallsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Call depth */\n  call_depth = 'call_depth',\n  /** Date */\n  date = 'date',\n  /** Smart Contract Method Signature */\n  signature = 'signature',\n  /** Smart Contract Method Signature Hash */\n  signature_hash = 'signature_hash',\n  /** Smart Contract Method Name */\n  signature_name = 'signature_name',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** Action From */\n  tx_from = 'tx_from',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Action To */\n  tx_to = 'tx_to'\n}\n\nexport enum HarmonySmartContractCallsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique smart contract methods count */\n  smart_contract_methods = 'smart_contract_methods',\n  /** Unique smart contracts count */\n  smart_contracts = 'smart_contracts',\n  /** Unique transaction senders */\n  tx_from = 'tx_from',\n  /** Unique callers count */\n  tx_to = 'tx_to',\n  /** Unique transactions count */\n  txs = 'txs'\n}\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEvents = {\n  __typename?: 'HarmonySmartContractEvents';\n  any?: Maybe<Scalars['String']>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Transaction hash where transfer happened */\n  epoch?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** The number of transactions made by the sender prior to this one. */\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** Contract method invoked */\n  smartContractEvent?: Maybe<Event>;\n  /** Action from address */\n  txFrom?: Maybe<Address>;\n  /** Transaction hash where transfer happened */\n  txHash?: Maybe<Scalars['String']>;\n  /** Action to address */\n  txTo?: Maybe<Address>;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventsanyArgs = {\n  of: HarmonyEventsMeasureable;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventscountArgs = {\n  uniq?: InputMaybe<SmartContractEventsUniq>;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventscountBigIntArgs = {\n  uniq?: InputMaybe<SmartContractEventsUniq>;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventsepochArgs = {\n  epoch?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventsmaximumArgs = {\n  get?: InputMaybe<HarmonyEventsMeasureable>;\n  of: HarmonyEventsMeasureable;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventsminimumArgs = {\n  get?: InputMaybe<HarmonyEventsMeasureable>;\n  of: HarmonyEventsMeasureable;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventsnonceArgs = {\n  nonce?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventssmartContractEventArgs = {\n  smartContractEvent?: InputMaybe<EventSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventstxFromArgs = {\n  txFrom?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventstxHashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type HarmonySmartContractEventstxToArgs = {\n  txTo?: InputMaybe<AddressSelector>;\n};\n\nexport type HarmonySmartContractEventsFilter = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactions = {\n  __typename?: 'HarmonyStakingTransactions';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Data */\n  data?: Maybe<Scalars['String']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Delegator Address */\n  delegatorAddress?: Maybe<Scalars['String']>;\n  /** Epoch */\n  epoch?: Maybe<Scalars['BigInt']>;\n  /** Gas provided by the sender */\n  gas?: Maybe<Scalars['BigInt']>;\n  /** Gas price provided by the sender */\n  gasPrice?: Maybe<Scalars['String']>;\n  /** Hash of the block where this transaction was in */\n  ledger?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** The number of transactions made by the sender prior to this one */\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** ShardID */\n  shardId?: Maybe<Scalars['BigInt']>;\n  /** Status */\n  status?: Maybe<Scalars['Boolean']>;\n  /** Successful of not */\n  success?: Maybe<Scalars['Boolean']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Transaction hash */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Transaction type */\n  transactionType?: Maybe<Scalars['String']>;\n  /** Validator Address */\n  validatorAddress?: Maybe<Scalars['String']>;\n  /** Value transferred in ATTO */\n  value?: Maybe<Scalars['String']>;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionsanyArgs = {\n  of: HarmonyStakingTransactionsMeasureable;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionscountArgs = {\n  uniq?: InputMaybe<HarmonyStakingTransactionsUniq>;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionscountBigIntArgs = {\n  uniq?: InputMaybe<HarmonyStakingTransactionsUniq>;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionsdelegatorAddressArgs = {\n  delegatorAddress?: InputMaybe<HashSelector>;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionsledgerArgs = {\n  ledger?: InputMaybe<BlockSelector>;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionsmaximumArgs = {\n  get?: InputMaybe<HarmonyStakingTransactionsMeasureable>;\n  of: HarmonyStakingTransactionsMeasureable;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionsminimumArgs = {\n  get?: InputMaybe<HarmonyStakingTransactionsMeasureable>;\n  of: HarmonyStakingTransactionsMeasureable;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionsstatusArgs = {\n  status?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionstransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionstransactionTypeArgs = {\n  transactionType?: InputMaybe<StakingTransactionsTypeSelector>;\n};\n\n\n/** StakingTransactions in Harmony blockchain */\nexport type HarmonyStakingTransactionsvalidatorAddressArgs = {\n  validatorAddress?: InputMaybe<HashSelector>;\n};\n\nexport type HarmonyStakingTransactionsFilter = {\n  date?: InputMaybe<DateSelector>;\n  delegatorAddress?: InputMaybe<HashSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  status?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<StakingTransactionsTypeSelector>;\n  validatorAddress?: InputMaybe<HashSelector>;\n};\n\nexport enum HarmonyStakingTransactionsMeasureable {\n  /** Date */\n  date = 'date',\n  /** Deligator Address */\n  deligator_address = 'deligator_address',\n  /** Gas provided by the sender */\n  gas = 'gas',\n  /** Gas price provided by the sender */\n  gasPrice = 'gasPrice',\n  /** Gas price provided by the sender */\n  gas_price = 'gas_price',\n  /** Time */\n  time = 'time',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Validator Address */\n  validator_address = 'validator_address',\n  /** Value transferred in ATTO */\n  value = 'value'\n}\n\nexport enum HarmonyStakingTransactionsUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique delegator validator */\n  delegator_address = 'delegator_address',\n  /** Unique block */\n  ledger = 'ledger',\n  /** Unique time */\n  times = 'times',\n  /** Unique address validator */\n  validator_address = 'validator_address'\n}\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactions = {\n  __typename?: 'HarmonyTransactions';\n  any?: Maybe<Scalars['String']>;\n  /** Hash of the block */\n  blockHash?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Transaction creates */\n  creates?: Maybe<Scalars['String']>;\n  /** Data */\n  data?: Maybe<Scalars['String']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Epoch */\n  epoch?: Maybe<Scalars['BigInt']>;\n  /** Gas provided by the sender */\n  gas?: Maybe<Scalars['BigInt']>;\n  /** Gas price provided by the sender */\n  gasPrice?: Maybe<Scalars['String']>;\n  /** Gas value provided by the sender */\n  gasValue?: Maybe<Scalars['String']>;\n  /** Hash of the block where this transaction was in */\n  ledger?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** The number of transactions made by the sender prior to this one */\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** Address of the reciever */\n  reciever?: Maybe<Scalars['String']>;\n  /** Address of the sender */\n  sender?: Maybe<Scalars['String']>;\n  /** ShardID */\n  shardId?: Maybe<Scalars['BigInt']>;\n  /** Status */\n  status?: Maybe<Scalars['Boolean']>;\n  /** Successful of not */\n  success?: Maybe<Scalars['Boolean']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Integer of the transactions index position in the block. null when its pending. */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Index of the transaction */\n  transactionIndex?: Maybe<Scalars['Int']>;\n  /** Value transferred in ATTO */\n  value?: Maybe<Scalars['String']>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionsanyArgs = {\n  of: HarmonyTransactionsMeasureable;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionsblockHashArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionscountArgs = {\n  uniq?: InputMaybe<HarmonyTransactionsUniq>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionscountBigIntArgs = {\n  uniq?: InputMaybe<HarmonyTransactionsUniq>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionscreatesArgs = {\n  creates?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionsledgerArgs = {\n  ledger?: InputMaybe<BlockSelector>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionsmaximumArgs = {\n  get?: InputMaybe<HarmonyTransactionsMeasureable>;\n  of: HarmonyTransactionsMeasureable;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionsminimumArgs = {\n  get?: InputMaybe<HarmonyTransactionsMeasureable>;\n  of: HarmonyTransactionsMeasureable;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionsrecieverArgs = {\n  reciever?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionssenderArgs = {\n  sender?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionsstatusArgs = {\n  status?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionstransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Harmony blockchain */\nexport type HarmonyTransactionstransactionIndexArgs = {\n  transactionIndex?: InputMaybe<HashSelector>;\n};\n\nexport type HarmonyTransactionsFilter = {\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  reciever?: InputMaybe<HashSelector>;\n  sender?: InputMaybe<HashSelector>;\n  status?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\nexport enum HarmonyTransactionsMeasureable {\n  /** Date */\n  date = 'date',\n  /** Gas provided by the sender */\n  gas = 'gas',\n  /** Gas price provided by the sender */\n  gasPrice = 'gasPrice',\n  /** Gas value provided by the sender */\n  gasValue = 'gasValue',\n  /** Gas price provided by the sender */\n  gas_price = 'gas_price',\n  /** Deligator Address */\n  reciever = 'reciever',\n  /** Validator Address */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Value transferred in ATTO */\n  value = 'value'\n}\n\nexport enum HarmonyTransactionsUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique block */\n  ledger = 'ledger',\n  /** Unique reciever */\n  reciever = 'reciever',\n  /** Unique sender */\n  sender = 'sender',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransfers = {\n  __typename?: 'HarmonyTransfers';\n  any?: Maybe<Scalars['String']>;\n  /** Hash of the block */\n  blockHash?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Data */\n  data?: Maybe<Scalars['String']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Epoch */\n  epoch?: Maybe<Scalars['BigInt']>;\n  /** External */\n  external?: Maybe<Scalars['Boolean']>;\n  /** Gas provided by the sender */\n  gas?: Maybe<Scalars['BigInt']>;\n  /** Gas price provided by the sender */\n  gasPrice?: Maybe<Scalars['String']>;\n  /** Gas value provided by the sender */\n  gasValue?: Maybe<Scalars['String']>;\n  /** Hash of the block where this transaction was in */\n  ledger?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** The number of transactions made by the sender prior to this one */\n  nonce?: Maybe<Scalars['BigInt']>;\n  /** Address of the sender */\n  sender?: Maybe<Scalars['String']>;\n  /** ShardID */\n  shardId?: Maybe<Scalars['BigInt']>;\n  /** Status */\n  status?: Maybe<Scalars['Boolean']>;\n  /** Successful of not */\n  success?: Maybe<Scalars['Boolean']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Integer of the transactions index position in the block. null when its pending. */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Index of the transaction */\n  transactionIndex?: Maybe<Scalars['Int']>;\n  /** Address of the payer */\n  transferFrom?: Maybe<Scalars['String']>;\n  /** Address of the receiver */\n  transferTo?: Maybe<Scalars['String']>;\n  /** Value transferred in ATTO */\n  value?: Maybe<Scalars['String']>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransfersanyArgs = {\n  of: HarmonyTransfersMeasureable;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransfersblockHashArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransferscountArgs = {\n  uniq?: InputMaybe<HarmonyTransfersUniq>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransferscountBigIntArgs = {\n  uniq?: InputMaybe<HarmonyTransfersUniq>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransfersexternalArgs = {\n  external?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransfersledgerArgs = {\n  ledger?: InputMaybe<BlockSelector>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransfersmaximumArgs = {\n  get?: InputMaybe<HarmonyTransfersMeasureable>;\n  of: HarmonyTransfersMeasureable;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransfersminimumArgs = {\n  get?: InputMaybe<HarmonyTransfersMeasureable>;\n  of: HarmonyTransfersMeasureable;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransferssenderArgs = {\n  sender?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransfersstatusArgs = {\n  status?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransferssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransferstransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransferstransactionIndexArgs = {\n  transactionIndex?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransferstransferFromArgs = {\n  transferFrom?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Harmony blockchain */\nexport type HarmonyTransferstransferToArgs = {\n  transferTo?: InputMaybe<HashSelector>;\n};\n\nexport type HarmonyTransfersFilter = {\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  sender?: InputMaybe<HashSelector>;\n  status?: InputMaybe<Scalars['Boolean']>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\nexport enum HarmonyTransfersMeasureable {\n  /** Date */\n  date = 'date',\n  /** Gas provided by the sender */\n  gas = 'gas',\n  /** Gas price provided by the sender */\n  gasPrice = 'gasPrice',\n  /** Gas value provided by the sender */\n  gasValue = 'gasValue',\n  /** Gas price provided by the sender */\n  gas_price = 'gas_price',\n  /** Validator Address */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Value transferred in ATTO */\n  value = 'value'\n}\n\nexport enum HarmonyTransfersUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique block */\n  ledger = 'ledger',\n  /** Unique sender */\n  sender = 'sender',\n  /** Unique time */\n  times = 'times',\n  /** Unique transfer from */\n  transfer_from = 'transfer_from',\n  /** Unique transfer to */\n  transfer_to = 'transfer_to'\n}\n\n/** Select by hash */\nexport type HashSelector = {\n  /** Hash in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Hash is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Hash not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Hash not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Hedera Chain */\nexport type Hedera = {\n  __typename?: 'Hedera';\n  /** Blockchain Arguments */\n  arguments?: Maybe<Array<HederaArgument>>;\n  /** Blockhain Calls */\n  calls?: Maybe<Array<HederaCall>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<HederaCoinpath>>;\n  /** Blockhain Inputs */\n  inputs?: Maybe<Array<HederaInput>>;\n  /** Blockhain Messages */\n  messages?: Maybe<Array<HederaMessage>>;\n  /** Blockchain Outputs */\n  outputs?: Maybe<Array<HederaOutput>>;\n  /** Blockchain Transactions */\n  transactions?: Maybe<Array<HederaTransaction>>;\n};\n\n\n/** Hedera Chain */\nexport type HederaargumentsArgs = {\n  any?: InputMaybe<Array<HederaArgumentFilter>>;\n  date?: InputMaybe<DateSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Hedera Chain */\nexport type HederacallsArgs = {\n  any?: InputMaybe<Array<HederaCallFilter>>;\n  callInput?: InputMaybe<HashSelector>;\n  callResult?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Hedera Chain */\nexport type HederacoinpathArgs = {\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<AddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CoinpathOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Hedera Chain */\nexport type HederainputsArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<HederaInputFilter>>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\n\n/** Hedera Chain */\nexport type HederamessagesArgs = {\n  any?: InputMaybe<Array<HederaMessageFilter>>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionRunningHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Hedera Chain */\nexport type HederaoutputsArgs = {\n  any?: InputMaybe<Array<HederaOutputFilter>>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\n\n/** Hedera Chain */\nexport type HederatransactionsArgs = {\n  any?: InputMaybe<Array<HederaTransactionFilter>>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgument = {\n  __typename?: 'HederaArgument';\n  any?: Maybe<Scalars['String']>;\n  /** Argument type */\n  argtype?: Maybe<Scalars['String']>;\n  /** Argument */\n  argument?: Maybe<Scalars['String']>;\n  chargedTxFee?: Maybe<Scalars['BigInt']>;\n  consensusTimestamp?: Maybe<Timestamp>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Currency of transfer */\n  feeCurrency?: Maybe<Currency>;\n  initialBalance?: Maybe<Scalars['Float']>;\n  maxFee?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  memo?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /**\n   * Used to reference a specific\n   *       account of the node the transaction is being sent to\n   */\n  nodeAccount?: Maybe<Account>;\n  /**\n   * Used to\n   *       reference a specific account in transactions\n   */\n  payerAccount?: Maybe<Account>;\n  /** Transaction result */\n  result?: Maybe<TransactionResult>;\n  /** Smart contract */\n  smartContractEntity?: Maybe<Account>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  transactionBytes?: Maybe<Scalars['String']>;\n  transactionFee?: Maybe<Scalars['Float']>;\n  /** Transaction hash where transfer happened */\n  transactionHash?: Maybe<Scalars['String']>;\n  transactionValidDurationInSec?: Maybe<Scalars['Int']>;\n  validStart?: Maybe<Timestamp>;\n  /** Value */\n  value?: Maybe<Scalars['String']>;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumentanyArgs = {\n  of: HederaArgumentsMeasureable;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumentcountArgs = {\n  uniq?: InputMaybe<HederaArgumentsUniq>;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumentcountBigIntArgs = {\n  uniq?: InputMaybe<HederaArgumentsUniq>;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumentinitialBalanceArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumentmaxFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumentmaximumArgs = {\n  get?: InputMaybe<HederaArgumentsMeasureable>;\n  of: HederaArgumentsMeasureable;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumentminimumArgs = {\n  get?: InputMaybe<HederaArgumentsMeasureable>;\n  of: HederaArgumentsMeasureable;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumentresultArgs = {\n  result?: InputMaybe<HashSelector>;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumentsuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumenttransactionFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumenttransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Arguments in Hedera blockchain */\nexport type HederaArgumentvalidStartArgs = {\n  nanoseconds?: InputMaybe<Scalars['BigInt']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport type HederaArgumentFilter = {\n  date?: InputMaybe<DateSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\nexport enum HederaArgumentsMeasureable {\n  /** Date */\n  date = 'date',\n  /** Max Fee */\n  max_fee = 'max_fee',\n  /** Time */\n  time = 'time',\n  /** Charged Fee */\n  transaction_fee = 'transaction_fee',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Valid duration */\n  valid_duration = 'valid_duration',\n  /** Valid start */\n  valid_start = 'valid_start'\n}\n\nexport enum HederaArgumentsUniq {\n  /** Unique consensus time */\n  consensus_times = 'consensus_times',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique initial balance */\n  initial_balance = 'initial_balance',\n  /** Unique node account */\n  node_account = 'node_account',\n  /** Unique payer account */\n  payer_account = 'payer_account',\n  /** Unique node account */\n  smart_contract_entity = 'smart_contract_entity',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Calls in Hedera blockchain */\nexport type HederaCall = {\n  __typename?: 'HederaCall';\n  any?: Maybe<Scalars['String']>;\n  /** Call input */\n  callInput?: Maybe<Scalars['String']>;\n  /** Call input */\n  callResult?: Maybe<Scalars['String']>;\n  chargedTxFee?: Maybe<Scalars['BigInt']>;\n  consensusTimestamp?: Maybe<Timestamp>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Currency of transfer */\n  feeCurrency?: Maybe<Currency>;\n  gas?: Maybe<Scalars['Int']>;\n  initialBalance?: Maybe<Scalars['Float']>;\n  maxFee?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  memo?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /**\n   * Used to reference a specific\n   *       account of the node the transaction is being sent to\n   */\n  nodeAccount?: Maybe<Account>;\n  /**\n   * Used to\n   *       reference a specific account in transactions\n   */\n  payerAccount?: Maybe<Account>;\n  /** Transaction result */\n  result?: Maybe<TransactionResult>;\n  /** Smart contract */\n  smartContractEntity?: Maybe<Account>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  transactionBytes?: Maybe<Scalars['String']>;\n  transactionFee?: Maybe<Scalars['Float']>;\n  /** Transaction hash where transfer happened */\n  transactionHash?: Maybe<Scalars['String']>;\n  transactionValidDurationInSec?: Maybe<Scalars['Int']>;\n  validStart?: Maybe<Timestamp>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallanyArgs = {\n  of: HederaCallsMeasureable;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallcallInputArgs = {\n  callInput?: InputMaybe<HashSelector>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallcallResultArgs = {\n  callResult?: InputMaybe<HashSelector>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallcountArgs = {\n  uniq?: InputMaybe<HederaCallsUniq>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallcountBigIntArgs = {\n  uniq?: InputMaybe<HederaCallsUniq>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallgasArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  callInput?: InputMaybe<HashSelector>;\n  callResult?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallinitialBalanceArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallmaxFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallmaximumArgs = {\n  get?: InputMaybe<HederaCallsMeasureable>;\n  of: HederaCallsMeasureable;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallminimumArgs = {\n  get?: InputMaybe<HederaCallsMeasureable>;\n  of: HederaCallsMeasureable;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallresultArgs = {\n  result?: InputMaybe<HashSelector>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallsuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCalltransactionFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCalltransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Calls in Hedera blockchain */\nexport type HederaCallvalidStartArgs = {\n  nanoseconds?: InputMaybe<Scalars['BigInt']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport type HederaCallFilter = {\n  callInput?: InputMaybe<HashSelector>;\n  callResult?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  smartContractEntity?: InputMaybe<StringSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\nexport enum HederaCallsMeasureable {\n  /** Date */\n  date = 'date',\n  /** Max Fee */\n  max_fee = 'max_fee',\n  /** Time */\n  time = 'time',\n  /** Charged Fee */\n  transaction_fee = 'transaction_fee',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Valid duration */\n  valid_duration = 'valid_duration',\n  /** Valid start */\n  valid_start = 'valid_start'\n}\n\nexport enum HederaCallsUniq {\n  /** Unique consensus time */\n  consensus_times = 'consensus_times',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique initial balance */\n  initial_balance = 'initial_balance',\n  /** Unique node account */\n  node_account = 'node_account',\n  /** Unique payer account */\n  payer_account = 'payer_account',\n  /** Unique node account */\n  smart_contract_entity = 'smart_contract_entity',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Coinpath */\nexport type HederaCoinpath = {\n  __typename?: 'HederaCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<Address>;\n  /** Sender address */\n  sender?: Maybe<Address>;\n  /** Attributes of transaction included in Coinpath result */\n  transactions?: Maybe<Array<CoinpathEntry>>;\n};\n\n\n/** Coinpath */\nexport type HederaCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Coinpath */\nexport type HederaCoinpathanyArgs = {\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type HederaCoinpathmaximumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type HederaCoinpathminimumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n/** Currency selector in Hedera blockchain. */\nexport type HederaCurrencySelector = {\n  /** Currency in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Currency is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Currency not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Currency not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Inputs in Hedera blockchain */\nexport type HederaInput = {\n  __typename?: 'HederaInput';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  consensusTimestamp?: Maybe<Timestamp>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Entity */\n  entity?: Maybe<Entity>;\n  /** Currency of transfer */\n  feeCurrency?: Maybe<Currency>;\n  initialBalance?: Maybe<Scalars['Float']>;\n  maxFee?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  memo?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /**\n   * Used to reference a specific\n   *       account of the node the transaction is being sent to\n   */\n  nodeAccount?: Maybe<Account>;\n  /**\n   * Used to\n   *       reference a specific account in transactions\n   */\n  payerAccount?: Maybe<Account>;\n  /** Transaction result */\n  result?: Maybe<TransactionResult>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Calendar time */\n  time?: Maybe<DateTime>;\n  transactionFee?: Maybe<Scalars['Float']>;\n  /** Transaction hash where transfer happened */\n  transactionHash?: Maybe<Scalars['String']>;\n  transactionValidDurationInSec?: Maybe<Scalars['Int']>;\n  /** Transfer Account */\n  transferEntity?: Maybe<Account>;\n  validStart?: Maybe<Timestamp>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputanyArgs = {\n  of: HederaInputMeasureable;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputcountArgs = {\n  uniq?: InputMaybe<HederaInputsUniq>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputcountBigIntArgs = {\n  uniq?: InputMaybe<HederaInputsUniq>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputcurrencyArgs = {\n  currency?: InputMaybe<HederaCurrencySelector>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputentityArgs = {\n  entityType?: InputMaybe<EntityTypeSelector>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputinitialBalanceArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputmaxFeeArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputmaximumArgs = {\n  get?: InputMaybe<HederaInputMeasureable>;\n  of: HederaInputMeasureable;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputminimumArgs = {\n  get?: InputMaybe<HederaInputMeasureable>;\n  of: HederaInputMeasureable;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputresultArgs = {\n  result?: InputMaybe<HashSelector>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputsuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputtransactionFeeArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputtransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Inputs in Hedera blockchain */\nexport type HederaInputvalidStartArgs = {\n  nanoseconds?: InputMaybe<Scalars['BigInt']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport type HederaInputFilter = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\nexport enum HederaInputMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Date */\n  date = 'date',\n  /** Max Fee */\n  max_fee = 'max_fee',\n  /** Time */\n  time = 'time',\n  /** Charged Fee */\n  transaction_fee = 'transaction_fee',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Valid duration */\n  valid_duration = 'valid_duration',\n  /** Valid start */\n  valid_start = 'valid_start'\n}\n\nexport enum HederaInputsUniq {\n  /** Unique consensus time */\n  consensus_times = 'consensus_times',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique entity id */\n  entity_id = 'entity_id',\n  /** Unique entity type */\n  entity_type = 'entity_type',\n  /** Unique initial balance */\n  initial_balance = 'initial_balance',\n  /** Unique node account */\n  node_account = 'node_account',\n  /** Unique payer account */\n  payer_account = 'payer_account',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Messages in Hedera blockchain */\nexport type HederaMessage = {\n  __typename?: 'HederaMessage';\n  any?: Maybe<Scalars['String']>;\n  consensusTimestamp?: Maybe<Timestamp>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Entity */\n  entity?: Maybe<Entity>;\n  /** Currency of transfer */\n  feeCurrency?: Maybe<Currency>;\n  initialBalance?: Maybe<Scalars['Float']>;\n  maxFee?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  memo?: Maybe<Scalars['String']>;\n  message?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /**\n   * Used to reference a specific\n   *       account of the node the transaction is being sent to\n   */\n  nodeAccount?: Maybe<Account>;\n  /**\n   * Used to\n   *       reference a specific account in transactions\n   */\n  payerAccount?: Maybe<Account>;\n  /** Transaction result */\n  result?: Maybe<TransactionResult>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Calendar date time */\n  time?: Maybe<DateTime>;\n  /** Transaction running hash */\n  topicRunningHash?: Maybe<Scalars['String']>;\n  /** Transaction running hash */\n  topicSequenceNumber?: Maybe<Scalars['String']>;\n  transactionFee?: Maybe<Scalars['Float']>;\n  /** Transaction hash where transfer happened */\n  transactionHash?: Maybe<Scalars['String']>;\n  transactionValidDurationInSec?: Maybe<Scalars['Int']>;\n  validStart?: Maybe<Timestamp>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessageanyArgs = {\n  of: HederaMessageMeasureable;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessagecountArgs = {\n  uniq?: InputMaybe<HederaMessagesUniq>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessagecountBigIntArgs = {\n  uniq?: InputMaybe<HederaMessagesUniq>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessageentityArgs = {\n  entityType?: InputMaybe<EntityTypeSelector>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessageinitialBalanceArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionRunningHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessagemaxFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionRunningHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessagemaximumArgs = {\n  get?: InputMaybe<HederaMessageMeasureable>;\n  of: HederaMessageMeasureable;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessageminimumArgs = {\n  get?: InputMaybe<HederaMessageMeasureable>;\n  of: HederaMessageMeasureable;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessageresultArgs = {\n  result?: InputMaybe<HashSelector>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessagesuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessagetopicRunningHashArgs = {\n  topicRunningHash?: InputMaybe<StringSelector>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessagetopicSequenceNumberArgs = {\n  topicSequenceNumber?: InputMaybe<HashSelector>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessagetransactionFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionRunningHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessagetransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Messages in Hedera blockchain */\nexport type HederaMessagevalidStartArgs = {\n  nanoseconds?: InputMaybe<Scalars['BigInt']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport type HederaMessageFilter = {\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionRunningHash?: InputMaybe<HashSelector>;\n};\n\nexport enum HederaMessageMeasureable {\n  /** Date */\n  date = 'date',\n  /** Max Fee */\n  max_fee = 'max_fee',\n  /** Time */\n  time = 'time',\n  /** Charged Fee */\n  transaction_fee = 'transaction_fee',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Valid duration */\n  valid_duration = 'valid_duration',\n  /** Valid start */\n  valid_start = 'valid_start'\n}\n\nexport enum HederaMessagesUniq {\n  /** Unique consensus time */\n  consensus_times = 'consensus_times',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique entity id */\n  entity_id = 'entity_id',\n  /** Unique entity type */\n  entity_type = 'entity_type',\n  /** Unique initial balance */\n  initial_balance = 'initial_balance',\n  /** Unique node account */\n  node_account = 'node_account',\n  /** Unique payer account */\n  payer_account = 'payer_account',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum HederaNetwork {\n  /** The Hedera mainnet */\n  hedera = 'hedera',\n  /** The Hedera testnets */\n  hedera_testnets = 'hedera_testnets'\n}\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutput = {\n  __typename?: 'HederaOutput';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  consensusTimestamp?: Maybe<Timestamp>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Entity */\n  entity?: Maybe<Entity>;\n  /** Currency of transfer */\n  feeCurrency?: Maybe<Currency>;\n  initialBalance?: Maybe<Scalars['Float']>;\n  maxFee?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  memo?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /**\n   * Used to reference a specific\n   *       account of the node the transaction is being sent to\n   */\n  nodeAccount?: Maybe<Account>;\n  /**\n   * Used to\n   *       reference a specific account in transactions\n   */\n  payerAccount?: Maybe<Account>;\n  /** Transaction result */\n  result?: Maybe<TransactionResult>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Calendar time */\n  time?: Maybe<DateTime>;\n  transactionFee?: Maybe<Scalars['Float']>;\n  /** Transaction hash where transfer happened */\n  transactionHash?: Maybe<Scalars['String']>;\n  transactionValidDurationInSec?: Maybe<Scalars['Int']>;\n  /** Transfer Account */\n  transferEntity?: Maybe<Account>;\n  validStart?: Maybe<Timestamp>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputanyArgs = {\n  of: HederaOutputMeasureable;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputcountArgs = {\n  uniq?: InputMaybe<HederaOutputUniq>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputcountBigIntArgs = {\n  uniq?: InputMaybe<HederaOutputUniq>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputcurrencyArgs = {\n  currency?: InputMaybe<HederaCurrencySelector>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputentityArgs = {\n  entityType?: InputMaybe<EntityTypeSelector>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputinitialBalanceArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputmaxFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputmaximumArgs = {\n  get?: InputMaybe<HederaOutputMeasureable>;\n  of: HederaOutputMeasureable;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputminimumArgs = {\n  get?: InputMaybe<HederaOutputMeasureable>;\n  of: HederaOutputMeasureable;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputresultArgs = {\n  result?: InputMaybe<HashSelector>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputsuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputtransactionFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputtransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Outputs in Hedera blockchain */\nexport type HederaOutputvalidStartArgs = {\n  nanoseconds?: InputMaybe<Scalars['BigInt']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport type HederaOutputFilter = {\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferEntity?: InputMaybe<StringSelector>;\n};\n\nexport enum HederaOutputMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Date */\n  date = 'date',\n  /** Max Fee */\n  max_fee = 'max_fee',\n  /** Time */\n  time = 'time',\n  /** Charged Fee */\n  transaction_fee = 'transaction_fee',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Valid duration */\n  valid_duration = 'valid_duration',\n  /** Valid start */\n  valid_start = 'valid_start'\n}\n\nexport enum HederaOutputUniq {\n  /** Unique consensus time */\n  consensus_times = 'consensus_times',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique entity id */\n  entity_id = 'entity_id',\n  /** Unique entity type */\n  entity_type = 'entity_type',\n  /** Unique initial balance */\n  initial_balance = 'initial_balance',\n  /** Unique node account */\n  node_account = 'node_account',\n  /** Unique payer account */\n  payer_account = 'payer_account',\n  /** Unique time */\n  times = 'times',\n  /** Unique Transfer entity */\n  transfer_entity = 'transfer_entity'\n}\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransaction = {\n  __typename?: 'HederaTransaction';\n  any?: Maybe<Scalars['String']>;\n  consensusTimestamp?: Maybe<Timestamp>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Entity */\n  entity?: Maybe<Entity>;\n  /** Currency of transfer */\n  feeCurrency?: Maybe<Currency>;\n  initialBalance?: Maybe<Scalars['Float']>;\n  maxFee?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  memo?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /**\n   * Used to reference a specific\n   *       account of the node the transaction is being sent to\n   */\n  nodeAccount?: Maybe<Account>;\n  /**\n   * Used to\n   *       reference a specific account in transactions\n   */\n  payerAccount?: Maybe<Account>;\n  /** Transaction result */\n  result?: Maybe<TransactionResult>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Calendar time */\n  time?: Maybe<DateTime>;\n  transactionBytes?: Maybe<Scalars['String']>;\n  transactionFee?: Maybe<Scalars['Float']>;\n  /** Transaction hash where transfer happened */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Transaction Type */\n  transactionType?: Maybe<Scalars['String']>;\n  transactionValidDurationInSec?: Maybe<Scalars['Int']>;\n  validStart?: Maybe<Timestamp>;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactionanyArgs = {\n  of: HederaTransactionMeasureable;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactioncountArgs = {\n  uniq?: InputMaybe<HederaTransactionsUniq>;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactioncountBigIntArgs = {\n  uniq?: InputMaybe<HederaTransactionsUniq>;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactionentityArgs = {\n  entityType?: InputMaybe<EntityTypeSelector>;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactioninitialBalanceArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactionmaxFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactionmaximumArgs = {\n  get?: InputMaybe<HederaTransactionMeasureable>;\n  of: HederaTransactionMeasureable;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactionminimumArgs = {\n  get?: InputMaybe<HederaTransactionMeasureable>;\n  of: HederaTransactionMeasureable;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactionresultArgs = {\n  result?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactionsuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactiontransactionFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactiontransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Hedera blockchain */\nexport type HederaTransactionvalidStartArgs = {\n  nanoseconds?: InputMaybe<Scalars['BigInt']>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\nexport type HederaTransactionFilter = {\n  date?: InputMaybe<DateSelector>;\n  entityType?: InputMaybe<EntityTypeSelector>;\n  nodeAccount?: InputMaybe<StringSelector>;\n  payerAccount?: InputMaybe<StringSelector>;\n  result?: InputMaybe<HashSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\nexport enum HederaTransactionMeasureable {\n  /** Date */\n  date = 'date',\n  /** Max Fee */\n  max_fee = 'max_fee',\n  /** Time */\n  time = 'time',\n  /** Charged Fee */\n  transaction_fee = 'transaction_fee',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Valid duration */\n  valid_duration = 'valid_duration',\n  /** Valid start */\n  valid_start = 'valid_start'\n}\n\nexport enum HederaTransactionsUniq {\n  /** Unique consensus time */\n  consensus_times = 'consensus_times',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique entity id */\n  entity_id = 'entity_id',\n  /** Unique entity type */\n  entity_type = 'entity_type',\n  /** Unique initial balance */\n  initial_balance = 'initial_balance',\n  /** Unique node account */\n  node_account = 'node_account',\n  /** Unique payer account */\n  payer_account = 'payer_account',\n  /** Unique time */\n  times = 'times',\n  /** Unique transaction type */\n  transaction_type = 'transaction_type'\n}\n\n/** Input Script Type of UTXO transaction input */\nexport type InputScript = {\n  __typename?: 'InputScript';\n  /** Script annotation */\n  annotation?: Maybe<Scalars['String']>;\n  /** Long script pattern */\n  pattern: Scalars['String'];\n  /** Short script pattern */\n  shortPattern: Scalars['String'];\n  /** Simple script pattern */\n  simplePattern: Scalars['String'];\n  /** Script type */\n  type?: Maybe<BitcoinInputScriptType>;\n};\n\n/** Solana Instruction */\nexport type Instruction = {\n  __typename?: 'Instruction';\n  action?: Maybe<Action>;\n  callPath?: Maybe<Scalars['String']>;\n  external?: Maybe<Scalars['Boolean']>;\n  program?: Maybe<Program>;\n};\n\n/** Solana Instruction */\nexport type InstructionWithExternals = {\n  __typename?: 'InstructionWithExternals';\n  action?: Maybe<Action>;\n  callPath?: Maybe<Scalars['String']>;\n  external?: Maybe<Scalars['Boolean']>;\n  externalAction?: Maybe<Action>;\n  externalProgram?: Maybe<Program>;\n  program?: Maybe<Program>;\n};\n\n/** Select by ID */\nexport type IntIdSelector = {\n  /** ID in range */\n  between?: InputMaybe<Array<Scalars['Int']>>;\n  /** ID greater than */\n  gt?: InputMaybe<Scalars['Int']>;\n  /** ID greater or equal than */\n  gteq?: InputMaybe<Scalars['Int']>;\n  /** ID in the list */\n  in?: InputMaybe<Array<Scalars['Int']>>;\n  /** ID is */\n  is?: InputMaybe<Scalars['Int']>;\n  /** ID less than */\n  lt?: InputMaybe<Scalars['Int']>;\n  /** ID less or equal than */\n  lteq?: InputMaybe<Scalars['Int']>;\n  /** ID not */\n  not?: InputMaybe<Scalars['Int']>;\n  /** ID not in the list */\n  notIn?: InputMaybe<Array<Scalars['Int']>>;\n};\n\n/** Select limited upper number */\nexport type IntegerLimitedSelector = {\n  /** in range */\n  between?: InputMaybe<Array<Scalars['Int']>>;\n  /** in the list */\n  in?: InputMaybe<Array<Scalars['Int']>>;\n  /** is */\n  is?: InputMaybe<Scalars['Int']>;\n  /** less than */\n  lt?: InputMaybe<Scalars['Int']>;\n  /** less or equal than */\n  lteq?: InputMaybe<Scalars['Int']>;\n};\n\n/** Select by number */\nexport type IntegerSelector = {\n  /** in range */\n  between?: InputMaybe<Array<Scalars['Int']>>;\n  /** greater than */\n  gt?: InputMaybe<Scalars['Int']>;\n  /** greater or equal than */\n  gteq?: InputMaybe<Scalars['Int']>;\n  /** in the list */\n  in?: InputMaybe<Array<Scalars['Int']>>;\n  /** is */\n  is?: InputMaybe<Scalars['Int']>;\n  /** less than */\n  lt?: InputMaybe<Scalars['Int']>;\n  /** less or equal than */\n  lteq?: InputMaybe<Scalars['Int']>;\n  /** not */\n  not?: InputMaybe<Scalars['Int']>;\n  /** not in the list */\n  notIn?: InputMaybe<Array<Scalars['Int']>>;\n};\n\n/** Libra */\nexport type Libra = {\n  __typename?: 'Libra';\n  /** Libra Network Blocks */\n  blocks?: Maybe<Array<LibraBlock>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<LibraCoinpath>>;\n  /** Libra Network Currency Minting */\n  mints?: Maybe<Array<LibraMints>>;\n  /** Libra Network Transactions */\n  transactions?: Maybe<Array<LibraTransactions>>;\n  /** Libra Network Currency Transfers */\n  transfers?: Maybe<Array<LibraTransfers>>;\n};\n\n\n/** Libra */\nexport type LibrablocksArgs = {\n  any?: InputMaybe<Array<LibraBlockFilter>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  metadata?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Libra */\nexport type LibracoinpathArgs = {\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<AddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CoinpathOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Libra */\nexport type LibramintsArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<LibraMintFilter>>;\n  block?: InputMaybe<BlockSelector>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  minter?: InputMaybe<AddressSelector>;\n  options?: InputMaybe<QueryOptions>;\n  time?: InputMaybe<DateTimeSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Libra */\nexport type LibratransactionsArgs = {\n  any?: InputMaybe<Array<LibraTransactionFilter>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Libra */\nexport type LibratransfersArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<LibraTransferFilter>>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n/** Block */\nexport type LibraBlock = {\n  __typename?: 'LibraBlock';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  gasUsed?: Maybe<Scalars['Float']>;\n  /** Block round in blockchain */\n  height: Scalars['Int'];\n  /** Key */\n  key?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Metadata */\n  metadata?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Proposer */\n  proposer?: Maybe<Address>;\n  /** Sequence number */\n  sequenceNumber?: Maybe<Scalars['Int']>;\n  /** Status Name */\n  statusName?: Maybe<Scalars['String']>;\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n  /** Version of transaction for this block */\n  version: Scalars['Int'];\n  /** Version hash of transaction for this block */\n  versionHash: Scalars['String'];\n  /** VM Status */\n  vmStatus?: Maybe<Scalars['Int']>;\n};\n\n\n/** Block */\nexport type LibraBlockanyArgs = {\n  of: LibraBlocksMeasureable;\n};\n\n\n/** Block */\nexport type LibraBlockcountArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  metadata?: InputMaybe<StringSelector>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<LibraBlockUniq>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block */\nexport type LibraBlockcountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  metadata?: InputMaybe<StringSelector>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<LibraBlockUniq>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block */\nexport type LibraBlockgasUsedArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  metadata?: InputMaybe<StringSelector>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block */\nexport type LibraBlockheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Block */\nexport type LibraBlockmaximumArgs = {\n  get?: InputMaybe<LibraBlocksMeasureable>;\n  of: LibraBlocksMeasureable;\n};\n\n\n/** Block */\nexport type LibraBlockmetadataArgs = {\n  metadata?: InputMaybe<StringSelector>;\n};\n\n\n/** Block */\nexport type LibraBlockminimumArgs = {\n  get?: InputMaybe<LibraBlocksMeasureable>;\n  of: LibraBlocksMeasureable;\n};\n\n\n/** Block */\nexport type LibraBlockproposerArgs = {\n  proposer?: InputMaybe<AddressSelector>;\n};\n\n\n/** Block */\nexport type LibraBlocktimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Block */\nexport type LibraBlockversionArgs = {\n  version?: InputMaybe<IntegerSelector>;\n};\n\nexport type LibraBlockFilter = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  metadata?: InputMaybe<StringSelector>;\n  proposer?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\nexport enum LibraBlockUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Proposer */\n  proposer = 'proposer'\n}\n\nexport enum LibraBlocksMeasureable {\n  /** Block round */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Gas Used */\n  gas_used = 'gas_used',\n  /** Proposer */\n  proposer = 'proposer',\n  /** Time */\n  time = 'time',\n  /** Version */\n  version = 'version'\n}\n\n/** Coinpath */\nexport type LibraCoinpath = {\n  __typename?: 'LibraCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<Address>;\n  /** Sender address */\n  sender?: Maybe<Address>;\n  /** Transaction of transfer happened */\n  transaction?: Maybe<LibraTransactionValue>;\n};\n\n\n/** Coinpath */\nexport type LibraCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Coinpath */\nexport type LibraCoinpathanyArgs = {\n  of: LibraCoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type LibraCoinpathmaximumArgs = {\n  get?: InputMaybe<LibraCoinpathMeasureable>;\n  of: LibraCoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type LibraCoinpathminimumArgs = {\n  get?: InputMaybe<LibraCoinpathMeasureable>;\n  of: LibraCoinpathMeasureable;\n};\n\nexport enum LibraCoinpathMeasureable {\n  /** Block */\n  block = 'block',\n  /** Depth */\n  depth = 'depth',\n  /** Receiver */\n  receiver = 'receiver',\n  /** Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Version */\n  version = 'version'\n}\n\n/**\n * Currency selector in Libra blockchain.\n * Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.\n * Use name of currency for selection\n */\nexport type LibraCurrencySelector = {\n  /** Currency in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Currency is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Currency not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Currency not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\nexport type LibraMintFilter = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  block?: InputMaybe<BlockSelector>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  minter?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n/** Mints in Libra blockchain */\nexport type LibraMints = {\n  __typename?: 'LibraMints';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Minter */\n  minter?: Maybe<Address>;\n  /** Sequence number */\n  sequenceNumber?: Maybe<Scalars['Int']>;\n  /** Status Name */\n  statusName?: Maybe<Scalars['String']>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Mint timestamp */\n  timestamp?: Maybe<DateTime>;\n  /** Version of blockchain for this transaction */\n  version: Scalars['Int'];\n  /** Version hash of blockchain for this transaction */\n  versionHash: Scalars['String'];\n  /** VM Status */\n  vmStatus?: Maybe<Scalars['Int']>;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintsamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  block?: InputMaybe<BlockSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  minter?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintsanyArgs = {\n  of: LibraMintsMeasureable;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintscountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  block?: InputMaybe<BlockSelector>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  minter?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<LibraMintsUniq>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintscountBigIntArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  block?: InputMaybe<BlockSelector>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  minter?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<LibraMintsUniq>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintscurrencyArgs = {\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintsmaximumArgs = {\n  get?: InputMaybe<LibraMintsMeasureable>;\n  of: LibraMintsMeasureable;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintsminimumArgs = {\n  get?: InputMaybe<LibraMintsMeasureable>;\n  of: LibraMintsMeasureable;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintsminterArgs = {\n  sender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintstimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Mints in Libra blockchain */\nexport type LibraMintsversionArgs = {\n  version?: InputMaybe<IntegerSelector>;\n};\n\nexport enum LibraMintsMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Currency symbol */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** Minter */\n  minter = 'minter',\n  /** Time */\n  time = 'time',\n  /** Version */\n  version = 'version',\n  /** Mint version hash */\n  version_hash = 'version_hash'\n}\n\nexport enum LibraMintsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique currencies */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique minters */\n  minters = 'minters',\n  /** Unique versions */\n  versions = 'versions'\n}\n\nexport type LibraTransactionFilter = {\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n/** Blockchain transaction with value */\nexport type LibraTransactionValue = {\n  __typename?: 'LibraTransactionValue';\n  /** Transaction value */\n  value: Scalars['Float'];\n  /** Transaction version */\n  version: Scalars['Int'];\n};\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactions = {\n  __typename?: 'LibraTransactions';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Expiration Time */\n  expirationTime?: Maybe<DateTime>;\n  gas?: Maybe<Scalars['Int']>;\n  /** Currency of gas */\n  gasCurrency?: Maybe<Currency>;\n  /** Gas unit price */\n  gasPrice: Scalars['Float'];\n  gasValue?: Maybe<Scalars['Float']>;\n  /** Max gas amount */\n  maxGasAmount?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Public key */\n  publicKey?: Maybe<Scalars['String']>;\n  /** Script Hash */\n  scriptHash?: Maybe<Scalars['String']>;\n  /** Script Type */\n  scriptType?: Maybe<ScriptTypeSelectorSelector>;\n  /** Transaction sender */\n  sender?: Maybe<Address>;\n  /** Sequence number */\n  sequenceNumber?: Maybe<Scalars['Int']>;\n  /** Signature */\n  signature?: Maybe<Scalars['String']>;\n  /** Signature scheme */\n  signatureScheme?: Maybe<Scalars['String']>;\n  /** Status Name */\n  statusName?: Maybe<Scalars['String']>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Transaction timestamp */\n  timestamp?: Maybe<DateTime>;\n  /** Version of blockchain for this transaction */\n  version: Scalars['Int'];\n  /** Version hash of blockchain for this transaction */\n  versionHash: Scalars['String'];\n  /** VM Status */\n  vmStatus?: Maybe<Scalars['Int']>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionsanyArgs = {\n  of: LibraTransactionsMeasureable;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionscountArgs = {\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<LibraTransactionsUniq>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionscountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<LibraTransactionsUniq>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionsgasArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionsgasCurrencyArgs = {\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionsgasPriceArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionsgasValueArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionsmaximumArgs = {\n  get?: InputMaybe<LibraTransactionsMeasureable>;\n  of: LibraTransactionsMeasureable;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionsminimumArgs = {\n  get?: InputMaybe<LibraTransactionsMeasureable>;\n  of: LibraTransactionsMeasureable;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionsscriptHashArgs = {\n  scriptHash?: InputMaybe<StringSelector>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionssenderArgs = {\n  txSender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionstimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transactions in Libra blockchain */\nexport type LibraTransactionsversionArgs = {\n  version?: InputMaybe<IntegerSelector>;\n};\n\nexport enum LibraTransactionsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Gas used */\n  gas = 'gas',\n  /** Gas price */\n  gas_price = 'gas_price',\n  /** Script Hash */\n  script_hash = 'script_hash',\n  /** Time */\n  time = 'time',\n  /** Transaction Sender */\n  tx_sender = 'tx_sender',\n  /** Version */\n  version = 'version'\n}\n\nexport enum LibraTransactionsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transaction script hashes */\n  scripts = 'scripts',\n  /** Unique transaction senders */\n  senders = 'senders',\n  /** Unique versions */\n  versions = 'versions'\n}\n\nexport type LibraTransferFilter = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfers = {\n  __typename?: 'LibraTransfers';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Expiration Time */\n  expirationTime?: Maybe<DateTime>;\n  gas?: Maybe<Scalars['Int']>;\n  /** Currency of gas */\n  gasCurrency?: Maybe<Currency>;\n  /** Gas price */\n  gasPrice: Scalars['Float'];\n  gasValue?: Maybe<Scalars['Float']>;\n  /** Max gas amount */\n  maxGasAmount?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Public key */\n  publicKey?: Maybe<Scalars['String']>;\n  /** Transfer receiver */\n  receiver?: Maybe<Address>;\n  /** Script Hash */\n  scriptHash?: Maybe<Scalars['String']>;\n  /** Script Type */\n  scriptType?: Maybe<ScriptTypeSelectorSelector>;\n  /** Transfer sender */\n  sender?: Maybe<Address>;\n  /** Sequence number */\n  sequenceNumber?: Maybe<Scalars['Int']>;\n  /** Signature */\n  signature?: Maybe<Scalars['String']>;\n  /** Signature scheme */\n  signatureScheme?: Maybe<Scalars['String']>;\n  /** Status Name */\n  statusName?: Maybe<Scalars['String']>;\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Transfer timestamp */\n  timestamp?: Maybe<DateTime>;\n  /** Transaction sender */\n  txSender?: Maybe<Address>;\n  /** Version of blockchain for this transaction */\n  version: Scalars['Int'];\n  /** Version hash of blockchain for this transaction */\n  versionHash: Scalars['String'];\n  /** VM Status */\n  vmStatus?: Maybe<Scalars['Int']>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersanyArgs = {\n  of: LibraTransfersMeasureable;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransferscountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransferscountBigIntArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransferscurrencyArgs = {\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersgasArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersgasCurrencyArgs = {\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersgasValueArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  currency?: InputMaybe<Array<LibraCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  gasCurrency?: InputMaybe<Array<LibraCurrencySelector>>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  scriptHash?: InputMaybe<StringSelector>;\n  scriptType?: InputMaybe<ScriptTypeSelectorSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txSender?: InputMaybe<AddressSelector>;\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersmaximumArgs = {\n  get?: InputMaybe<LibraTransfersMeasureable>;\n  of: LibraTransfersMeasureable;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersminimumArgs = {\n  get?: InputMaybe<LibraTransfersMeasureable>;\n  of: LibraTransfersMeasureable;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersreceiverArgs = {\n  receiver?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersscriptHashArgs = {\n  scriptHash?: InputMaybe<StringSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransferssenderArgs = {\n  sender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransferssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransferstimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransferstxSenderArgs = {\n  txSender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transfers in Libra blockchain */\nexport type LibraTransfersversionArgs = {\n  version?: InputMaybe<IntegerSelector>;\n};\n\nexport enum LibraTransfersMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Currency symbol */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** Gas used */\n  gas = 'gas',\n  /** Gas price */\n  gas_price = 'gas_price',\n  /** Gas value */\n  gas_value = 'gas_value',\n  /** Block */\n  height = 'height',\n  /** Receiver */\n  receiver = 'receiver',\n  /** Script Hash */\n  script_hash = 'script_hash',\n  /** Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transfer Sender */\n  tx_sender = 'tx_sender',\n  /** Version */\n  version = 'version',\n  /** Version hash */\n  version_hash = 'version_hash'\n}\n\n/** Limit by definition */\nexport type LimitByOption = {\n  /** Take limit for each combination of the field */\n  each: Scalars['String'];\n  /** Limit number of results */\n  limit?: InputMaybe<Scalars['Int']>;\n  /** Offset of results, starting from 0 */\n  offset?: InputMaybe<Scalars['Int']>;\n};\n\n/** Solana Log */\nexport type Log = {\n  __typename?: 'Log';\n  consumed: Scalars['BigInt'];\n  instruction: Scalars['String'];\n  logs: Scalars['String'];\n  result: Scalars['String'];\n  totalGas: Scalars['BigInt'];\n};\n\n/** Smart contract method */\nexport type Method = {\n  __typename?: 'Method';\n  /** Name */\n  name?: Maybe<Scalars['String']>;\n  /** Signature */\n  signature?: Maybe<Scalars['String']>;\n  /** Signature Hash */\n  signatureHash: Scalars['String'];\n};\n\n/** Smart contract method. In selector you can use the name, signature or hex hash */\nexport type MethodSelector = {\n  /** Method signature in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Method signature is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Method signature not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Method signature not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Information about miniblock */\nexport type MiniblockElrond = {\n  __typename?: 'MiniblockElrond';\n  /** Miniblock hash */\n  hash?: Maybe<Scalars['String']>;\n  /** Hash of the receiver block */\n  receiverBlockHash?: Maybe<Scalars['String']>;\n  /** Number of the receiver shard */\n  receiverShard?: Maybe<Scalars['String']>;\n  /** Miniblock type */\n  type?: Maybe<Scalars['String']>;\n};\n\n\n/** Information about miniblock */\nexport type MiniblockElrondhashArgs = {\n  miniblockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about miniblock */\nexport type MiniblockElrondreceiverBlockHashArgs = {\n  miniblockReceiverBlockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about miniblock */\nexport type MiniblockElrondreceiverShardArgs = {\n  miniblockReceiverShard?: InputMaybe<IntIdSelector>;\n};\n\n\n/** Information about miniblock */\nexport type MiniblockElrondtypeArgs = {\n  type?: InputMaybe<StringSelector>;\n};\n\n/** Name with an identifier */\nexport type NameWithId = {\n  __typename?: 'NameWithId';\n  /** ID */\n  id?: Maybe<Scalars['Int']>;\n  /** Name */\n  name?: Maybe<Scalars['String']>;\n};\n\nexport enum Network {\n  /** Algorand Mainnet (ALGO) */\n  algorand = 'algorand',\n  /** Algorand Betanet */\n  algorand_betanet = 'algorand_betanet',\n  /** Algorand Testnet */\n  algorand_testnet = 'algorand_testnet',\n  /** Binance DEX */\n  binance = 'binance',\n  /** Bitcoin Cash ( BCH ) */\n  bitcash = 'bitcash',\n  /** Bitcoin ( BTC ) */\n  bitcoin = 'bitcoin',\n  /** Bitcoin SV ( BSV ) */\n  bitcoinsv = 'bitcoinsv',\n  /** Binance Smart Chain Mainnet */\n  bsc = 'bsc',\n  /** Binance Smart Chain Testnet */\n  bsc_testnet = 'bsc_testnet',\n  /** Cardano ( ADA ) */\n  cardano = 'cardano',\n  /** Celo Alfajores Testnet */\n  celo_alfajores = 'celo_alfajores',\n  /** Celo Baklava Testnet */\n  celo_baklava = 'celo_baklava',\n  /** Celo RC1 */\n  celo_rc1 = 'celo_rc1',\n  /** Conflux Oceanus */\n  conflux_oceanus = 'conflux_oceanus',\n  /** Conflux Tethys */\n  conflux_tethys = 'conflux_tethys',\n  /** Dash ( DASH ) */\n  dash = 'dash',\n  /** Diem Testnet */\n  diem_testnet = 'diem_testnet',\n  /** Dogecoin ( DOGE ) */\n  dogecoin = 'dogecoin',\n  /** Elrond Mainnet */\n  elrond = 'elrond',\n  /** EOS Mainnet */\n  eos = 'eos',\n  /** Beacon Chain Ethereum 2.0 */\n  eth2 = 'eth2',\n  /** Ethereum Classic */\n  ethclassic = 'ethclassic',\n  /** Ethereum Classic ( no reorg from block 10904146) */\n  ethclassic_reorg = 'ethclassic_reorg',\n  /** Ethereum Mainnet */\n  ethereum = 'ethereum',\n  /** Filecoin Mainnet */\n  filecoin = 'filecoin',\n  /** Goerli Ethereum Testnet */\n  goerli = 'goerli',\n  /** Hedera Hashgraph */\n  hedera = 'hedera',\n  /** Klaytn Mainnet */\n  klaytn = 'klaytn',\n  /** Libra Testnet */\n  libra_testnet = 'libra_testnet',\n  /** Litecoin ( LTC ) */\n  litecoin = 'litecoin',\n  /** Matic (Polygon) Mainnet */\n  matic = 'matic',\n  /** Medalla Ethereum 2.0 Beacon Testnet */\n  medalla = 'medalla',\n  /** Solana Mainnet */\n  solana = 'solana',\n  /** TRON Mainnet */\n  tron = 'tron',\n  /** Velas Mainnet */\n  velas = 'velas',\n  /** Velas Testnet */\n  velas_testnet = 'velas_testnet',\n  /** Zcash ( ZEC ) */\n  zcash = 'zcash'\n}\n\n/** Offchain Data */\nexport type Offchain = {\n  __typename?: 'Offchain';\n  /** Historical COVID data */\n  covid?: Maybe<CovidHistory>;\n};\n\n/** Select order by ID */\nexport type OrderIdSelector = {\n  /** Order ID in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Order ID is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Order ID not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Order ID not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Select by order side */\nexport type OrderSideSelector = {\n  /** Order Side in the list */\n  in?: InputMaybe<Array<BinanceOrderSide>>;\n  /** Order Side is */\n  is?: InputMaybe<BinanceOrderSide>;\n  /** Order Side not */\n  not?: InputMaybe<BinanceOrderSide>;\n  /** Order Side not in the list */\n  notIn?: InputMaybe<Array<BinanceOrderSide>>;\n};\n\n/** Select by order status */\nexport type OrderStatusSelector = {\n  /** Order Status in the list */\n  in?: InputMaybe<Array<BinanceOrderStatus>>;\n  /** Order Status is */\n  is?: InputMaybe<BinanceOrderStatus>;\n  /** Order Status not */\n  not?: InputMaybe<BinanceOrderStatus>;\n  /** Order Status not in the list */\n  notIn?: InputMaybe<Array<BinanceOrderStatus>>;\n};\n\n/** Select by order time in force */\nexport type OrderTimeInForceSelector = {\n  /** Order TimeInForce in the list */\n  in?: InputMaybe<Array<BinanceOrderTimeInForce>>;\n  /** Order TimeInForce is */\n  is?: InputMaybe<BinanceOrderTimeInForce>;\n  /** Order TimeInForce not */\n  not?: InputMaybe<BinanceOrderTimeInForce>;\n  /** Order TimeInForce not in the list */\n  notIn?: InputMaybe<Array<BinanceOrderTimeInForce>>;\n};\n\n/** Select by order type */\nexport type OrderTypeSelector = {\n  /** Order Type in the list */\n  in?: InputMaybe<Array<BinanceOrderType>>;\n  /** Order Type is */\n  is?: InputMaybe<BinanceOrderType>;\n  /** Order Type not */\n  not?: InputMaybe<BinanceOrderType>;\n  /** Order Type not in the list */\n  notIn?: InputMaybe<Array<BinanceOrderType>>;\n};\n\n/** Select by output index ( o based ) */\nexport type OutputIndexSelector = {\n  /** Output index in range */\n  between?: InputMaybe<Array<Scalars['Int']>>;\n  /** Output index greater than */\n  gt?: InputMaybe<Scalars['Int']>;\n  /** Output index greater or equal than */\n  gteq?: InputMaybe<Scalars['Int']>;\n  /** Output index in the list */\n  in?: InputMaybe<Array<Scalars['Int']>>;\n  /** Output index is */\n  is?: InputMaybe<Scalars['Int']>;\n  /** Output index less than */\n  lt?: InputMaybe<Scalars['Int']>;\n  /** Output index less or equal than */\n  lteq?: InputMaybe<Scalars['Int']>;\n  /** Output index not */\n  not?: InputMaybe<Scalars['Int']>;\n  /** Output index not in the list */\n  notIn?: InputMaybe<Array<Scalars['Int']>>;\n};\n\n/** Output Script Type of UTXO transaction output */\nexport type OutputScript = {\n  __typename?: 'OutputScript';\n  /** Script annotation */\n  annotation?: Maybe<Scalars['String']>;\n  /** Long script pattern */\n  pattern: Scalars['String'];\n  /** Short script pattern */\n  short: Scalars['String'];\n  /** Simple script pattern */\n  simplePattern: Scalars['String'];\n  /** Script type */\n  type?: Maybe<BitcoinOutputScriptType>;\n};\n\nexport enum PriceAggregateFunction {\n  /** Any value */\n  any = 'any',\n  /** Last value */\n  anyLast = 'anyLast',\n  /** Average */\n  average = 'average',\n  /** Maximum */\n  maximum = 'maximum',\n  /** Median */\n  median = 'median',\n  /** Minimum */\n  minimum = 'minimum',\n  /** Aggregated over interval */\n  sum = 'sum'\n}\n\n/** Solana Program */\nexport type Program = {\n  __typename?: 'Program';\n  id: Scalars['String'];\n  name: Scalars['String'];\n  parsed: Scalars['Boolean'];\n  parsedName: Scalars['String'];\n};\n\nexport enum Protocol {\n  /** Algorand */\n  algorand = 'algorand',\n  /** Binance DEX */\n  binance = 'binance',\n  /** Bitcoin */\n  bitcoin = 'bitcoin',\n  /** Cardano */\n  cardano = 'cardano',\n  /** Elrond */\n  elrond = 'elrond',\n  /** EOS */\n  eos = 'eos',\n  /** Ethereum */\n  ethereum = 'ethereum',\n  /** Filecoin */\n  filecoin = 'filecoin',\n  /** Hedera Hashgraph */\n  hedera = 'hedera',\n  /** Libra */\n  libra = 'libra',\n  /** Solana */\n  solana = 'solana',\n  /** Tron */\n  tron = 'tron'\n}\n\n/** Blockchain Unified GraphQL API */\nexport type Query = {\n  __typename?: 'Query';\n  /** Algorand Chains Dataset */\n  algorand?: Maybe<Algorand>;\n  /** Binance DEX Chain Dataset */\n  binance?: Maybe<Binance>;\n  /** Bitcoin and other UTXO Chains Dataset */\n  bitcoin?: Maybe<Bitcoin>;\n  /** Cardano Chain Dataset */\n  cardano?: Maybe<Cardano>;\n  /** Conflux Chains Dataset */\n  conflux?: Maybe<Conflux>;\n  /** Diem ( former Libra ) Testnet Dataset */\n  diem?: Maybe<Libra>;\n  /** Elrond Dataset */\n  elrond?: Maybe<Elrond>;\n  /** EOS Mainnet Dataset */\n  eos?: Maybe<Eos>;\n  /** Ethereum Mainnet / Classic Chain Datasets */\n  ethereum?: Maybe<Ethereum>;\n  /** Ethereum v2.0 Beacon Chain Datasets */\n  ethereum2?: Maybe<Ethereum2>;\n  /** Filecoin Dataset */\n  filecoin?: Maybe<Filecoin>;\n  /** Harmony Dataset */\n  harmony?: Maybe<Harmony>;\n  /** Hedera Dataset */\n  hedera?: Maybe<Hedera>;\n  /** Offchain data */\n  offchain?: Maybe<Offchain>;\n  /** Ripple Dataset */\n  ripple?: Maybe<Ripple>;\n  /** Search by query string */\n  search?: Maybe<Array<Result>>;\n  /** Solana Dataset */\n  solana?: Maybe<Solana>;\n  /** Stellar Dataset */\n  stellar?: Maybe<Stellar>;\n  /** Tron Mainnet Dataset */\n  tron?: Maybe<Tron>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QueryalgorandArgs = {\n  network?: InputMaybe<AlgorandNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QuerybitcoinArgs = {\n  network?: InputMaybe<BitcoinNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QuerycardanoArgs = {\n  network?: InputMaybe<CardanoNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QueryconfluxArgs = {\n  network?: InputMaybe<ConfluxNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QuerydiemArgs = {\n  network?: InputMaybe<DiemNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QueryelrondArgs = {\n  network?: InputMaybe<ElrondNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QueryeosArgs = {\n  network?: InputMaybe<EosNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QueryethereumArgs = {\n  network?: InputMaybe<EthereumNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type Queryethereum2Args = {\n  network?: InputMaybe<Ethereum2Network>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QueryfilecoinArgs = {\n  network?: InputMaybe<FilecoinNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QueryharmonyArgs = {\n  network?: InputMaybe<HarmonyNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QueryhederaArgs = {\n  network?: InputMaybe<HederaNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QueryrippleArgs = {\n  network?: InputMaybe<RippleNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QuerysearchArgs = {\n  limit?: InputMaybe<Scalars['Int']>;\n  network?: InputMaybe<Network>;\n  offset?: InputMaybe<Scalars['Int']>;\n  string: Scalars['String'];\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QuerysolanaArgs = {\n  network?: InputMaybe<SolanaNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QuerystellarArgs = {\n  network?: InputMaybe<StellarNetwork>;\n};\n\n\n/** Blockchain Unified GraphQL API */\nexport type QuerytronArgs = {\n  network?: InputMaybe<TronNetwork>;\n};\n\n/** Limits, Ordering, Constraints */\nexport type QueryOptions = {\n  /** Ordering field(s) for ascending */\n  asc?: InputMaybe<Array<Scalars['String']>>;\n  /** Ordering field(s) for descending */\n  desc?: InputMaybe<Array<Scalars['String']>>;\n  /** Limit number of results */\n  limit?: InputMaybe<Scalars['Int']>;\n  /** Limit number of results by specific field */\n  limitBy?: InputMaybe<LimitByOption>;\n  /** Offset of results, starting from 0 */\n  offset?: InputMaybe<Scalars['Int']>;\n};\n\n/** Solana Receiver */\nexport type Receiver = {\n  __typename?: 'Receiver';\n  address: Scalars['String'];\n  mintAccount: Scalars['String'];\n  type: Scalars['String'];\n};\n\n/** Search result item */\nexport type Result = {\n  __typename?: 'Result';\n  /** Blockchain where result is found */\n  network: BlockchainNetwork;\n  /** Subject in blockchain */\n  subject: Subject;\n};\n\n/** Select by reward type */\nexport type RewardTypeSelector = {\n  /** Type in the list */\n  in?: InputMaybe<Array<SolanaRewardType>>;\n  /** Type is */\n  is?: InputMaybe<SolanaRewardType>;\n  /** Type not */\n  not?: InputMaybe<SolanaRewardType>;\n  /** Type not in the list */\n  notIn?: InputMaybe<Array<SolanaRewardType>>;\n};\n\n/** Ripple Chain */\nexport type Ripple = {\n  __typename?: 'Ripple';\n  /** The Escrow object type represents a held payment of XRP waiting to be executed or canceled */\n  accountRoots?: Maybe<Array<RippleAccountRoots>>;\n  /** Ripple Balances */\n  balances?: Maybe<Array<RippleBalances>>;\n  /** Ripple Blocks */\n  blocks?: Maybe<Array<RippleBlocks>>;\n  /** A check that can be redeemed for money by its destination. */\n  checks?: Maybe<Array<RippleChecks>>;\n  /** The Escrow object type represents a held payment of XRP waiting to be executed or canceled */\n  escrows?: Maybe<Array<RippleEscrows>>;\n  /** An order to make a currency trade. */\n  offers?: Maybe<Array<RippleOffers>>;\n  /** Ripple Payments */\n  payments?: Maybe<Array<RipplePayments>>;\n  /** The RippleState object type connects two accounts in a single currency */\n  rippleStates?: Maybe<Array<RippleRippleStates>>;\n  /** Ripple Transactions */\n  transactions?: Maybe<Array<RippleTransactions>>;\n  /** Ripple Transfers */\n  transfers?: Maybe<Array<RippleTransfers>>;\n};\n\n\n/** Ripple Chain */\nexport type RippleaccountRootsArgs = {\n  account?: InputMaybe<HashSelector>;\n  any?: InputMaybe<Array<RippleAccountRootsFilter>>;\n  balance?: InputMaybe<IntegerSelector>;\n  blockHeight?: InputMaybe<BlockSelector>;\n  date?: InputMaybe<DateSelector>;\n  domain?: InputMaybe<StringSelector>;\n  flags?: InputMaybe<IntegerSelector>;\n  operation?: InputMaybe<HashSelector>;\n  options?: InputMaybe<QueryOptions>;\n  ownerCount?: InputMaybe<IntegerSelector>;\n  prevBalance?: InputMaybe<IntegerSelector>;\n  previousTxnId?: InputMaybe<HashSelector>;\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n  sequence?: InputMaybe<IntegerSelector>;\n  transactionType?: InputMaybe<TypeSelector>;\n  transferRate?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Ripple Chain */\nexport type RipplebalancesArgs = {\n  account?: InputMaybe<HashSelector>;\n  any?: InputMaybe<Array<RippleBalancesFilter>>;\n  date?: InputMaybe<DateSelector>;\n  flags?: InputMaybe<HashSelector>;\n  issuer?: InputMaybe<HashSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  prevBalance?: InputMaybe<HashSelector>;\n  prevLedgerSeq?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionSender?: InputMaybe<HashSelector>;\n};\n\n\n/** Ripple Chain */\nexport type RippleblocksArgs = {\n  accountHash?: InputMaybe<HashSelector>;\n  any?: InputMaybe<Array<RippleBlocksFilter>>;\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  ledgerHash?: InputMaybe<HashSelector>;\n  options?: InputMaybe<QueryOptions>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Ripple Chain */\nexport type RipplechecksArgs = {\n  any?: InputMaybe<Array<RippleChecksFilter>>;\n  blockHeight?: InputMaybe<BlockSelector>;\n  date?: InputMaybe<DateSelector>;\n  destination?: InputMaybe<HashSelector>;\n  destinationTag?: InputMaybe<IntegerSelector>;\n  expiration?: InputMaybe<IntegerSelector>;\n  flags?: InputMaybe<IntegerSelector>;\n  invoiceId?: InputMaybe<IntegerSelector>;\n  operation?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  previousTxnId?: InputMaybe<IntegerSelector>;\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n  sendMax?: InputMaybe<IntegerSelector>;\n  sender?: InputMaybe<HashSelector>;\n  sequence?: InputMaybe<IntegerSelector>;\n  sourceTag?: InputMaybe<IntegerSelector>;\n  transactionType?: InputMaybe<HashSelector>;\n};\n\n\n/** Ripple Chain */\nexport type RippleescrowsArgs = {\n  amount?: InputMaybe<IntegerSelector>;\n  any?: InputMaybe<Array<RippleEscrowsFilter>>;\n  blockHeight?: InputMaybe<BlockSelector>;\n  cancelAfter?: InputMaybe<IntegerSelector>;\n  condition?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  destination?: InputMaybe<HashSelector>;\n  destinationTag?: InputMaybe<IntegerSelector>;\n  finishedAfter?: InputMaybe<IntegerSelector>;\n  flags?: InputMaybe<IntegerSelector>;\n  operation?: InputMaybe<HashSelector>;\n  options?: InputMaybe<QueryOptions>;\n  previousTxnId?: InputMaybe<IntegerSelector>;\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n  sender?: InputMaybe<HashSelector>;\n  sourceTag?: InputMaybe<IntegerSelector>;\n  transactionType?: InputMaybe<TypeSelector>;\n};\n\n\n/** Ripple Chain */\nexport type RippleoffersArgs = {\n  account?: InputMaybe<HashSelector>;\n  any?: InputMaybe<Array<RippleOffersFilter>>;\n  bookDirectory?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  sequence?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionSender?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<HashSelector>;\n};\n\n\n/** Ripple Chain */\nexport type RipplepaymentsArgs = {\n  amountIssuer?: InputMaybe<HashSelector>;\n  any?: InputMaybe<Array<RipplePaymentsFilter>>;\n  date?: InputMaybe<DateSelector>;\n  deliverIssuer?: InputMaybe<HashSelector>;\n  deliverMinIssuer?: InputMaybe<HashSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  sendMaxIssuer?: InputMaybe<HashSelector>;\n  tag?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferFrom?: InputMaybe<HashSelector>;\n  transferTo?: InputMaybe<HashSelector>;\n};\n\n\n/** Ripple Chain */\nexport type RipplerippleStatesArgs = {\n  any?: InputMaybe<Array<RippleStatesFilter>>;\n  balance?: InputMaybe<IntegerSelector>;\n  blockHeight?: InputMaybe<BlockSelector>;\n  date?: InputMaybe<DateSelector>;\n  flags?: InputMaybe<IntegerSelector>;\n  highAccount?: InputMaybe<HashSelector>;\n  lowAccount?: InputMaybe<HashSelector>;\n  operation?: InputMaybe<StringSelector>;\n  options?: InputMaybe<QueryOptions>;\n  preBalance?: InputMaybe<IntegerSelector>;\n  previousTxnId?: InputMaybe<IntegerSelector>;\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n  sender?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<HashSelector>;\n};\n\n\n/** Ripple Chain */\nexport type RippletransactionsArgs = {\n  any?: InputMaybe<Array<RippleTransactionsFilter>>;\n  date?: InputMaybe<DateSelector>;\n  lastLedgerSequence?: InputMaybe<HashSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  result?: InputMaybe<HashSelector>;\n  sender?: InputMaybe<HashSelector>;\n  sequence?: InputMaybe<HashSelector>;\n  status?: InputMaybe<Scalars['Boolean']>;\n  transactionFee?: InputMaybe<TransactionTypeSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<TransactionTypeSelector>;\n};\n\n\n/** Ripple Chain */\nexport type RippletransfersArgs = {\n  any?: InputMaybe<Array<RippleTransfersFilter>>;\n  blockHeight?: InputMaybe<BlockSelector>;\n  date?: InputMaybe<DateSelector>;\n  options?: InputMaybe<QueryOptions>;\n  sender?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<StringSelector>;\n  transferFrom?: InputMaybe<HashSelector>;\n  transferTo?: InputMaybe<HashSelector>;\n};\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRoots = {\n  __typename?: 'RippleAccountRoots';\n  /** The identifying (classic) address of this account. */\n  account?: Maybe<Scalars['String']>;\n  any?: Maybe<Scalars['String']>;\n  /** The account`s current XRP balance in drops, represented as a string. */\n  balance?: Maybe<Scalars['BigInt']>;\n  /** Number of block in the blockchains */\n  blockHeight?: Maybe<Scalars['BigInt']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** domain associated with this account. In JSON, this is the hexadecimal for the ASCII representation of the domain */\n  domain?: Maybe<Scalars['String']>;\n  /** \tA bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0. */\n  flags?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Operation */\n  operation?: Maybe<Scalars['String']>;\n  /** The number of objects this account owns in the ledger, which contributes to its owner reserve. */\n  ownerCount?: Maybe<Scalars['Int']>;\n  /** Previous Balance */\n  prevBalance?: Maybe<Scalars['BigInt']>;\n  /** The identifying hash of the transaction that most recently modified this object. */\n  previousTxnId?: Maybe<Scalars['String']>;\n  /** The identifying hash of the transaction that most recently modified this object. */\n  previousTxnLedgerSeq?: Maybe<Scalars['BigInt']>;\n  /** The sequence number of the next valid transaction for this account. (Each account starts with Sequence = 1 and increases each time a transaction is made.) */\n  sequence?: Maybe<Scalars['BigInt']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Type of transaction */\n  transactionType?: Maybe<Scalars['String']>;\n  /** A transfer fee  to charge other users for sending currency issued by this account to each other. */\n  transferRate?: Maybe<Scalars['BigInt']>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsaccountArgs = {\n  account?: InputMaybe<HashSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsanyArgs = {\n  of: RippleccountRootsMeasureable;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsbalanceArgs = {\n  balance?: InputMaybe<IntegerSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsblockHeightArgs = {\n  blockHeight?: InputMaybe<BlockSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootscountArgs = {\n  uniq?: InputMaybe<RippleAccountRootsUniq>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootscountBigIntArgs = {\n  uniq?: InputMaybe<RippleAccountRootsUniq>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsdomainArgs = {\n  domain?: InputMaybe<StringSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsflagsArgs = {\n  flags?: InputMaybe<IntegerSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsmaximumArgs = {\n  get?: InputMaybe<RippleccountRootsMeasureable>;\n  of: RippleccountRootsMeasureable;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsminimumArgs = {\n  get?: InputMaybe<RippleccountRootsMeasureable>;\n  of: RippleccountRootsMeasureable;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsoperationArgs = {\n  operation?: InputMaybe<HashSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsownerCountArgs = {\n  ownerCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootsprevBalanceArgs = {\n  prevBalance?: InputMaybe<IntegerSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootspreviousTxnIdArgs = {\n  previousTxnId?: InputMaybe<HashSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootspreviousTxnLedgerSeqArgs = {\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootssequenceArgs = {\n  sequence?: InputMaybe<IntegerSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootstransactionTypeArgs = {\n  transactionType?: InputMaybe<TypeSelector>;\n};\n\n\n/** The AccountRoot object type describes a single account, its settings, and XRP balance. */\nexport type RippleAccountRootstransferRateArgs = {\n  transferRate?: InputMaybe<IntegerSelector>;\n};\n\nexport type RippleAccountRootsFilter = {\n  account?: InputMaybe<HashSelector>;\n  balance?: InputMaybe<IntegerSelector>;\n  blockHeight?: InputMaybe<BlockSelector>;\n  date?: InputMaybe<DateSelector>;\n  domain?: InputMaybe<StringSelector>;\n  flags?: InputMaybe<IntegerSelector>;\n  operation?: InputMaybe<HashSelector>;\n  ownerCount?: InputMaybe<IntegerSelector>;\n  prevBalance?: InputMaybe<IntegerSelector>;\n  previousTxnId?: InputMaybe<HashSelector>;\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n  sequence?: InputMaybe<IntegerSelector>;\n  transactionType?: InputMaybe<TypeSelector>;\n  transferRate?: InputMaybe<IntegerSelector>;\n};\n\nexport enum RippleAccountRootsUniq {\n  /** Unique Number of block in the blockchains */\n  block_height = 'block_height',\n  /** Unique currencies */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique sender */\n  sender = 'sender',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Balances in Ripple blockchain */\nexport type RippleBalances = {\n  __typename?: 'RippleBalances';\n  /** Account */\n  account?: Maybe<Scalars['String']>;\n  any?: Maybe<Scalars['String']>;\n  balance?: Maybe<Scalars['Float']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency */\n  currency?: Maybe<Currency>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Previous Ledge Seq */\n  flags?: Maybe<Scalars['BigInt']>;\n  /** Issuer */\n  issuer?: Maybe<Scalars['String']>;\n  /** Block number */\n  ledger?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Previous Balance */\n  prevBalance?: Maybe<Scalars['Float']>;\n  /** Previous Ledger Seq */\n  prevLedgerSeq?: Maybe<Scalars['BigInt']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Transaction hash */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Transaction Sender */\n  transactionSender?: Maybe<Scalars['String']>;\n  /** Transaction type */\n  transactionType?: Maybe<Scalars['String']>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancesaccountArgs = {\n  account?: InputMaybe<HashSelector>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancesanyArgs = {\n  of: RippleBalancesMeasureable;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancesbalanceArgs = {\n  account?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  flags?: InputMaybe<HashSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  issuer?: InputMaybe<HashSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  prevBalance?: InputMaybe<HashSelector>;\n  prevLedgerSeq?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionSender?: InputMaybe<HashSelector>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancescountArgs = {\n  uniq?: InputMaybe<RippleBalancesUniq>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancescountBigIntArgs = {\n  uniq?: InputMaybe<RippleBalancesUniq>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancesflagsArgs = {\n  flags?: InputMaybe<HashSelector>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancesissuerArgs = {\n  issuer?: InputMaybe<HashSelector>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancesledgerArgs = {\n  ledger?: InputMaybe<BlockSelector>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancesmaximumArgs = {\n  get?: InputMaybe<RippleBalancesMeasureable>;\n  of: RippleBalancesMeasureable;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancesminimumArgs = {\n  get?: InputMaybe<RippleBalancesMeasureable>;\n  of: RippleBalancesMeasureable;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancesprevBalanceArgs = {\n  prevBalance?: InputMaybe<HashSelector>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancesprevLedgerSeqArgs = {\n  prevLedgerSeq?: InputMaybe<HashSelector>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancestransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancestransactionSenderArgs = {\n  transactionSender?: InputMaybe<HashSelector>;\n};\n\n\n/** Balances in Ripple blockchain */\nexport type RippleBalancestransactionTypeArgs = {\n  transactionType?: InputMaybe<TransactionTypeSelector>;\n};\n\nexport type RippleBalancesFilter = {\n  account?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  flags?: InputMaybe<HashSelector>;\n  issuer?: InputMaybe<HashSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  prevBalance?: InputMaybe<HashSelector>;\n  prevLedgerSeq?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionSender?: InputMaybe<HashSelector>;\n};\n\nexport enum RippleBalancesMeasureable {\n  /** Account */\n  account = 'account',\n  /** Balance */\n  balance = 'balance',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Transaction Sender */\n  transaction_sender = 'transaction_sender'\n}\n\nexport enum RippleBalancesUniq {\n  /** Unique account count */\n  account = 'account',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique issuer count */\n  issuer = 'issuer',\n  /** Unique ledger count */\n  ledger = 'ledger',\n  /** Unique time */\n  times = 'times',\n  /** Unique transaction hash count */\n  transactionHash = 'transactionHash',\n  /** Unique transaction sender count */\n  transactionSender = 'transactionSender'\n}\n\n/** Blocks in Ripple blockchain */\nexport type RippleBlocks = {\n  __typename?: 'RippleBlocks';\n  /** Hash of this ledger`s state tree information. */\n  accountHash?: Maybe<Scalars['String']>;\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Block number */\n  ledger?: Maybe<Scalars['BigInt']>;\n  /** This serves as a unique identifier for this ledger and all its contents. */\n  ledgerHash?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** The total number of drops of XRP owned by accounts in the ledger. */\n  totalCoins?: Maybe<Scalars['BigInt']>;\n  /** Transaction hash */\n  transactionHash?: Maybe<Scalars['String']>;\n};\n\n\n/** Blocks in Ripple blockchain */\nexport type RippleBlocksaccountHashArgs = {\n  accountHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Ripple blockchain */\nexport type RippleBlocksanyArgs = {\n  of: RippleBlocksMeasureable;\n};\n\n\n/** Blocks in Ripple blockchain */\nexport type RippleBlockscountArgs = {\n  uniq?: InputMaybe<RippleBlocksUniq>;\n};\n\n\n/** Blocks in Ripple blockchain */\nexport type RippleBlockscountBigIntArgs = {\n  uniq?: InputMaybe<RippleBlocksUniq>;\n};\n\n\n/** Blocks in Ripple blockchain */\nexport type RippleBlocksledgerArgs = {\n  ledger?: InputMaybe<BlockSelector>;\n};\n\n\n/** Blocks in Ripple blockchain */\nexport type RippleBlocksledgerHashArgs = {\n  ledgerHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Blocks in Ripple blockchain */\nexport type RippleBlocksmaximumArgs = {\n  get?: InputMaybe<RippleBlocksMeasureable>;\n  of: RippleBlocksMeasureable;\n};\n\n\n/** Blocks in Ripple blockchain */\nexport type RippleBlocksminimumArgs = {\n  get?: InputMaybe<RippleBlocksMeasureable>;\n  of: RippleBlocksMeasureable;\n};\n\n\n/** Blocks in Ripple blockchain */\nexport type RippleBlockstransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\nexport type RippleBlocksFilter = {\n  accountHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  ledgerHash?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\nexport enum RippleBlocksMeasureable {\n  /** Hash of this ledger`s state tree information */\n  account_hash = 'account_hash',\n  /** Date */\n  date = 'date',\n  /** Block number */\n  ledger = 'ledger',\n  /** This serves as a unique identifier for this ledger and all its contents */\n  ledger_hash = 'ledger_hash',\n  /** Time */\n  time = 'time',\n  /** The total number of drops of XRP owned by accounts in the ledger */\n  total_coins = 'total_coins'\n}\n\nexport enum RippleBlocksUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique blocks */\n  ledger = 'ledger',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Checks in Ripple blockchain */\nexport type RippleChecks = {\n  __typename?: 'RippleChecks';\n  any?: Maybe<Scalars['String']>;\n  /** Number of block in the blockchains */\n  blockHeight?: Maybe<Scalars['BigInt']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** The destination address where the XRP is paid if the held payment is successful. */\n  destination?: Maybe<Scalars['String']>;\n  /** An arbitrary tag to further specify the destination for this held payment, such as a hosted recipient at the destination address. */\n  destinationTag?: Maybe<Scalars['BigInt']>;\n  /** Indicates the time after which this Check is considered expired. */\n  expiration?: Maybe<Scalars['BigInt']>;\n  /** A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0. */\n  flags?: Maybe<Scalars['BigInt']>;\n  /** The time after which this held payment can be finished */\n  invoiceId?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Operation */\n  operation?: Maybe<Scalars['String']>;\n  /** The identifying hash of the transaction that most recently modified this object. */\n  previousTxnId?: Maybe<Scalars['String']>;\n  /** The identifying hash of the transaction that most recently modified this object. */\n  previousTxnLedgerSeq?: Maybe<Scalars['BigInt']>;\n  /** The maximum amount of currency this Check can debit the sender.  */\n  sendMax?: Maybe<Scalars['BigInt']>;\n  /** The sender of the Check. Cashing the Check debits this address`s balance. */\n  sender?: Maybe<Scalars['String']>;\n  /** The sequence number of the CheckCreate transaction that created this check. */\n  sequence?: Maybe<Scalars['BigInt']>;\n  /** An arbitrary tag to further specify the source for this held payment, such as a hosted recipient at the owner`s address. */\n  sourceTag?: Maybe<Scalars['BigInt']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Type of transaction */\n  transactionType?: Maybe<Scalars['String']>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleChecksanyArgs = {\n  of: RippleChecksMeasureable;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleChecksblockHeightArgs = {\n  blockHeight?: InputMaybe<BlockSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleCheckscountArgs = {\n  uniq?: InputMaybe<RippleChecksUniq>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleCheckscountBigIntArgs = {\n  uniq?: InputMaybe<RippleChecksUniq>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleChecksdestinationArgs = {\n  destination?: InputMaybe<HashSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleChecksdestinationTagArgs = {\n  destinationTag?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleChecksexpirationArgs = {\n  expiration?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleChecksflagsArgs = {\n  flags?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleChecksinvoiceIdArgs = {\n  invoiceId?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleChecksmaximumArgs = {\n  get?: InputMaybe<RippleChecksMeasureable>;\n  of: RippleChecksMeasureable;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleChecksminimumArgs = {\n  get?: InputMaybe<RippleChecksMeasureable>;\n  of: RippleChecksMeasureable;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleChecksoperationArgs = {\n  operation?: InputMaybe<StringSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleCheckspreviousTxnIdArgs = {\n  previousTxnId?: InputMaybe<HashSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleCheckspreviousTxnLedgerSeqArgs = {\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleCheckssendMaxArgs = {\n  sendMax?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleCheckssenderArgs = {\n  sender?: InputMaybe<HashSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleCheckssequenceArgs = {\n  sequence?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleCheckssourceTagArgs = {\n  sourceTag?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Checks in Ripple blockchain */\nexport type RippleCheckstransactionTypeArgs = {\n  transactionType?: InputMaybe<TypeSelector>;\n};\n\nexport type RippleChecksFilter = {\n  blockHeight?: InputMaybe<BlockSelector>;\n  date?: InputMaybe<DateSelector>;\n  destination?: InputMaybe<HashSelector>;\n  destinationTag?: InputMaybe<IntegerSelector>;\n  expiration?: InputMaybe<IntegerSelector>;\n  flags?: InputMaybe<IntegerSelector>;\n  invoiceId?: InputMaybe<IntegerSelector>;\n  operation?: InputMaybe<StringSelector>;\n  previousTxnId?: InputMaybe<IntegerSelector>;\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n  sendMax?: InputMaybe<IntegerSelector>;\n  sender?: InputMaybe<HashSelector>;\n  sequence?: InputMaybe<IntegerSelector>;\n  sourceTag?: InputMaybe<IntegerSelector>;\n  transactionType?: InputMaybe<HashSelector>;\n};\n\nexport enum RippleChecksMeasureable {\n  /** Number of block in the blockhains */\n  block_height = 'block_height',\n  /** Currency Address */\n  currency_address = 'currency_address',\n  /** Currency Symbol */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** The sender of the Check. Cashing the Check debits this address`s balance. */\n  sender = 'sender',\n  /** Time */\n  time = 'time'\n}\n\nexport enum RippleChecksUniq {\n  /** Unique Number of block in the blockchains */\n  block_height = 'block_height',\n  /** Unique currencies */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique destination */\n  destination = 'destination',\n  /** Unique sender */\n  sender = 'sender',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrows = {\n  __typename?: 'RippleEscrows';\n  /** The amount of XRP, in drops, to be delivered by the held payment. */\n  amount?: Maybe<Scalars['BigInt']>;\n  any?: Maybe<Scalars['String']>;\n  /** Number of block in the blockchains */\n  blockHeight?: Maybe<Scalars['BigInt']>;\n  /** The held payment can be canceled if and only if this field is present and the time it specifies has passed */\n  cancelAfter?: Maybe<Scalars['BigInt']>;\n  /** Crypto condition as hexadecimal. If present, the EscrowFinish transaction must contain a fulfillment that satisfies this condition. */\n  condition?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** The destination address where the XRP is paid if the held payment is successful. */\n  destination?: Maybe<Scalars['String']>;\n  /** An arbitrary tag to further specify the destination for this held payment, such as a hosted recipient at the destination address. */\n  destinationTag?: Maybe<Scalars['BigInt']>;\n  /** The time after which this held payment can be finished */\n  finishedAfter?: Maybe<Scalars['BigInt']>;\n  /** \tA bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0. */\n  flags?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Operation */\n  operation?: Maybe<Scalars['String']>;\n  /** The identifying hash of the transaction that most recently modified this object. */\n  previousTxnId?: Maybe<Scalars['String']>;\n  /** The identifying hash of the transaction that most recently modified this object. */\n  previousTxnLedgerSeq?: Maybe<Scalars['BigInt']>;\n  /** The address of the owner (sender) of this held payment */\n  sender?: Maybe<Scalars['String']>;\n  /** An arbitrary tag to further specify the source for this held payment, such as a hosted recipient at the owner`s address. */\n  sourceTag?: Maybe<Scalars['BigInt']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Type of transaction */\n  transactionType?: Maybe<Scalars['String']>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsamountArgs = {\n  amount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsanyArgs = {\n  of: RippleEscrowsMeasureable;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsblockHeightArgs = {\n  blockHeight?: InputMaybe<BlockSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowscancelAfterArgs = {\n  cancelAfter?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsconditionArgs = {\n  condition?: InputMaybe<HashSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowscountArgs = {\n  uniq?: InputMaybe<RippleEscrowsUniq>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowscountBigIntArgs = {\n  uniq?: InputMaybe<RippleEscrowsUniq>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsdestinationArgs = {\n  destination?: InputMaybe<HashSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsdestinationTagArgs = {\n  destinationTag?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsfinishedAfterArgs = {\n  finishedAfter?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsflagsArgs = {\n  flags?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsmaximumArgs = {\n  get?: InputMaybe<RippleEscrowsMeasureable>;\n  of: RippleEscrowsMeasureable;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsminimumArgs = {\n  get?: InputMaybe<RippleEscrowsMeasureable>;\n  of: RippleEscrowsMeasureable;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowsoperationArgs = {\n  operation?: InputMaybe<HashSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowspreviousTxnIdArgs = {\n  previousTxnId?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowspreviousTxnLedgerSeqArgs = {\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowssenderArgs = {\n  sender?: InputMaybe<HashSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowssourceTagArgs = {\n  sourceTag?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Escrows in Ripple blockchain */\nexport type RippleEscrowstransactionTypeArgs = {\n  transactionType?: InputMaybe<TypeSelector>;\n};\n\nexport type RippleEscrowsFilter = {\n  amount?: InputMaybe<IntegerSelector>;\n  blockHeight?: InputMaybe<BlockSelector>;\n  cancelAfter?: InputMaybe<IntegerSelector>;\n  condition?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  destination?: InputMaybe<HashSelector>;\n  destinationTag?: InputMaybe<IntegerSelector>;\n  finishedAfter?: InputMaybe<IntegerSelector>;\n  flags?: InputMaybe<IntegerSelector>;\n  operation?: InputMaybe<HashSelector>;\n  previousTxnId?: InputMaybe<IntegerSelector>;\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n  sender?: InputMaybe<HashSelector>;\n  sourceTag?: InputMaybe<IntegerSelector>;\n  transactionType?: InputMaybe<TypeSelector>;\n};\n\nexport enum RippleEscrowsMeasureable {\n  /** Number of block in the blockhains */\n  block_height = 'block_height',\n  /** Currency Address */\n  currency_address = 'currency_address',\n  /** Currency Symbol */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** The address of the owner (sender) of this held payment */\n  sender = 'sender',\n  /** Time */\n  time = 'time'\n}\n\nexport enum RippleEscrowsUniq {\n  /** Unique Number of block in the blockchains */\n  block_height = 'block_height',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique destination */\n  destination = 'destination',\n  /** Unique sender */\n  sender = 'sender',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum RippleNetwork {\n  /** Ripple XRP Ledger */\n  ripple = 'ripple'\n}\n\n/** Offers in Ripple blockchain */\nexport type RippleOffers = {\n  __typename?: 'RippleOffers';\n  any?: Maybe<Scalars['String']>;\n  /** Book Directory */\n  bookDirectory?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Expiration */\n  expiration?: Maybe<Scalars['BigInt']>;\n  /** Flags */\n  flags?: Maybe<Scalars['BigInt']>;\n  /** Block number */\n  ledger?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Operation */\n  operation?: Maybe<Scalars['String']>;\n  /** Sequence */\n  sequence?: Maybe<Scalars['Float']>;\n  takerGets?: Maybe<Scalars['BigInt']>;\n  /** Taker Gets Currency */\n  takerGetsCurrency?: Maybe<Currency>;\n  takerPays?: Maybe<Scalars['BigInt']>;\n  /** Taker Pays Currency */\n  takerPaysCurrency?: Maybe<Currency>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Transaction hash */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Transaction Sender */\n  transactionSender?: Maybe<Scalars['String']>;\n  /** Transaction type */\n  transactionType?: Maybe<Scalars['String']>;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOffersanyArgs = {\n  of: RippleOffersMeasureable;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOffersbookDirectoryArgs = {\n  bookDirectory?: InputMaybe<HashSelector>;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOfferscountArgs = {\n  uniq?: InputMaybe<RippleOffersUniq>;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOfferscountBigIntArgs = {\n  uniq?: InputMaybe<RippleOffersUniq>;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOffersledgerArgs = {\n  ledger?: InputMaybe<BlockSelector>;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOffersmaximumArgs = {\n  get?: InputMaybe<RippleOffersMeasureable>;\n  of: RippleOffersMeasureable;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOffersminimumArgs = {\n  get?: InputMaybe<RippleOffersMeasureable>;\n  of: RippleOffersMeasureable;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOfferssequenceArgs = {\n  sequence?: InputMaybe<HashSelector>;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOfferstakerGetsArgs = {\n  account?: InputMaybe<HashSelector>;\n  bookDirectory?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  ledger?: InputMaybe<BlockSelector>;\n  sequence?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionSender?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<HashSelector>;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOfferstakerPaysArgs = {\n  account?: InputMaybe<HashSelector>;\n  bookDirectory?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  ledger?: InputMaybe<BlockSelector>;\n  sequence?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionSender?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<HashSelector>;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOfferstransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOfferstransactionSenderArgs = {\n  transactionSender?: InputMaybe<HashSelector>;\n};\n\n\n/** Offers in Ripple blockchain */\nexport type RippleOfferstransactionTypeArgs = {\n  transactionType?: InputMaybe<TransactionTypeSelector>;\n};\n\nexport type RippleOffersFilter = {\n  account?: InputMaybe<HashSelector>;\n  bookDirectory?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  sequence?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionSender?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<HashSelector>;\n};\n\nexport enum RippleOffersMeasureable {\n  /** Date */\n  date = 'date',\n  /** Taker Gets Currency Address */\n  taker_gets_currency_address = 'taker_gets_currency_address',\n  /** Taker Gets Currency Symbol */\n  taker_gets_currency_symbol = 'taker_gets_currency_symbol',\n  /** Taker Pays Currency Address */\n  taker_pays_currency_address = 'taker_pays_currency_address',\n  /** Taker Pays Currency Symbol */\n  taker_pays_currency_symbol = 'taker_pays_currency_symbol',\n  /** Time */\n  time = 'time',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Transaction Sender */\n  transaction_sender = 'transaction_sender',\n  /** Transaction Type */\n  transaction_type = 'transaction_type'\n}\n\nexport enum RippleOffersUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique time */\n  times = 'times',\n  /** Uniq transaction hash */\n  transaction_hash = 'transaction_hash',\n  /** Uniq transaction sender */\n  transaction_sender = 'transaction_sender'\n}\n\n/** Payments in Ripple blockchain */\nexport type RipplePayments = {\n  __typename?: 'RipplePayments';\n  /** Amount Currency */\n  amountCurrency?: Maybe<Currency>;\n  /** Amount Issuer */\n  amountIssuer?: Maybe<Scalars['String']>;\n  amountValue?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Delivered min currency */\n  deliverMinCurrency?: Maybe<Currency>;\n  /** Delivered Min Issuer */\n  deliverMinIssuer?: Maybe<Scalars['String']>;\n  deliverMinValue?: Maybe<Scalars['Float']>;\n  /** Currency of the money sender's transfer */\n  deliveredCurrency?: Maybe<Currency>;\n  /** Delivered Value */\n  deliveredIssuer?: Maybe<Scalars['String']>;\n  deliveredValue?: Maybe<Scalars['Float']>;\n  /** Flags */\n  flags?: Maybe<Scalars['BigInt']>;\n  /** Invoice */\n  invoice?: Maybe<Scalars['String']>;\n  /** Block number */\n  ledger?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Partial */\n  partial?: Maybe<Scalars['BigInt']>;\n  /** Currency of the money sender's transfer */\n  sendMaxCurrency?: Maybe<Currency>;\n  /** Send Max Issuer */\n  sendMaxIssuer?: Maybe<Scalars['String']>;\n  sendMaxValue?: Maybe<Scalars['Float']>;\n  /** Tag */\n  tag?: Maybe<Scalars['BigInt']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Transaction hash */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Transfer from */\n  transferFrom?: Maybe<Scalars['String']>;\n  /** Transfer to */\n  transferTo?: Maybe<Scalars['String']>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentsamountIssuerArgs = {\n  amountIssuer?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentsamountValueArgs = {\n  amountIssuer?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  deliverIssuer?: InputMaybe<HashSelector>;\n  deliverMinIssuer?: InputMaybe<HashSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  ledger?: InputMaybe<BlockSelector>;\n  sendMaxIssuer?: InputMaybe<HashSelector>;\n  tag?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferFrom?: InputMaybe<HashSelector>;\n  transferTo?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentsanyArgs = {\n  of: RipplePaymentsMeasureable;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentscountArgs = {\n  uniq?: InputMaybe<RipplePaymentsUniq>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentscountBigIntArgs = {\n  uniq?: InputMaybe<RipplePaymentsUniq>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentsdeliverMinIssuerArgs = {\n  deliverMinIssuer?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentsdeliverMinValueArgs = {\n  amountIssuer?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  deliverIssuer?: InputMaybe<HashSelector>;\n  deliverMinIssuer?: InputMaybe<HashSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  ledger?: InputMaybe<BlockSelector>;\n  sendMaxIssuer?: InputMaybe<HashSelector>;\n  tag?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferFrom?: InputMaybe<HashSelector>;\n  transferTo?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentsdeliveredIssuerArgs = {\n  deliveredIssuer?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentsdeliveredValueArgs = {\n  amountIssuer?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  deliverIssuer?: InputMaybe<HashSelector>;\n  deliverMinIssuer?: InputMaybe<HashSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  ledger?: InputMaybe<BlockSelector>;\n  sendMaxIssuer?: InputMaybe<HashSelector>;\n  tag?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferFrom?: InputMaybe<HashSelector>;\n  transferTo?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentsledgerArgs = {\n  ledger?: InputMaybe<BlockSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentsmaximumArgs = {\n  get?: InputMaybe<RipplePaymentsMeasureable>;\n  of: RipplePaymentsMeasureable;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentsminimumArgs = {\n  get?: InputMaybe<RipplePaymentsMeasureable>;\n  of: RipplePaymentsMeasureable;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentssendMaxIssuerArgs = {\n  sendMaxIssuer?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentssendMaxValueArgs = {\n  amountIssuer?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  deliverIssuer?: InputMaybe<HashSelector>;\n  deliverMinIssuer?: InputMaybe<HashSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  ledger?: InputMaybe<BlockSelector>;\n  sendMaxIssuer?: InputMaybe<HashSelector>;\n  tag?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferFrom?: InputMaybe<HashSelector>;\n  transferTo?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentstagArgs = {\n  tag?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentstransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentstransferFromArgs = {\n  transferFrom?: InputMaybe<HashSelector>;\n};\n\n\n/** Payments in Ripple blockchain */\nexport type RipplePaymentstransferToArgs = {\n  transferTo?: InputMaybe<HashSelector>;\n};\n\nexport type RipplePaymentsFilter = {\n  amountIssuer?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  deliverIssuer?: InputMaybe<HashSelector>;\n  deliverMinIssuer?: InputMaybe<HashSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  sendMaxIssuer?: InputMaybe<HashSelector>;\n  tag?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transferFrom?: InputMaybe<HashSelector>;\n  transferTo?: InputMaybe<HashSelector>;\n};\n\nexport enum RipplePaymentsMeasureable {\n  /** Amount Currency Address */\n  amount_currency_address = 'amount_currency_address',\n  /** Amount Currency Symbol */\n  amount_currency_symbol = 'amount_currency_symbol',\n  /** Amount Value */\n  amount_value = 'amount_value',\n  /** Date */\n  date = 'date',\n  /** Delivered Min Currency Address */\n  deliver_min_currency_address = 'deliver_min_currency_address',\n  /** Delivered Min Currency Symbol */\n  deliver_min_currency_symbol = 'deliver_min_currency_symbol',\n  /** Delivered Currency Address */\n  delivered_currency_address = 'delivered_currency_address',\n  /** Delivered Currency Symbol */\n  delivered_currency_symbol = 'delivered_currency_symbol',\n  /** Send max Currency Address */\n  send_max_currency_address = 'send_max_currency_address',\n  /** Send max Currency Symbol */\n  send_max_currency_symbol = 'send_max_currency_symbol',\n  /** Time */\n  time = 'time',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash',\n  /** Transfer From */\n  transfer_from = 'transfer_from',\n  /** Transfer To */\n  transfer_to = 'transfer_to'\n}\n\nexport enum RipplePaymentsUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique blocks */\n  ledger = 'ledger',\n  /** Unique time */\n  times = 'times',\n  /** Unique transfer from */\n  transfer_from = 'transfer_from',\n  /** Unique transfer to */\n  transfer_to = 'transfer_to'\n}\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStates = {\n  __typename?: 'RippleRippleStates';\n  any?: Maybe<Scalars['String']>;\n  balance?: Maybe<Scalars['Float']>;\n  /** Number of block in the blockchains */\n  blockHeight?: Maybe<Scalars['BigInt']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** \tA bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0. */\n  flags?: Maybe<Scalars['String']>;\n  /** High Account */\n  highAccount?: Maybe<Scalars['String']>;\n  /** Low Account */\n  lowAccount?: Maybe<Scalars['String']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Operation */\n  operation?: Maybe<Scalars['String']>;\n  /** Previous Balance */\n  preBalance?: Maybe<Scalars['BigInt']>;\n  /** The identifying hash of the transaction that most recently modified this object. */\n  previousTxnId?: Maybe<Scalars['String']>;\n  /** The identifying hash of the transaction that most recently modified this object. */\n  previousTxnLedgerSeq?: Maybe<Scalars['BigInt']>;\n  /** The address of the owner (sender) of this held payment */\n  sender?: Maybe<Scalars['String']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Type of transaction */\n  transactionType?: Maybe<Scalars['String']>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatesanyArgs = {\n  of: RippleRippleStatesMeasureable;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatesbalanceArgs = {\n  balance?: InputMaybe<IntegerSelector>;\n  blockHeight?: InputMaybe<BlockSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  flags?: InputMaybe<IntegerSelector>;\n  highAccount?: InputMaybe<HashSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  lowAccount?: InputMaybe<HashSelector>;\n  operation?: InputMaybe<StringSelector>;\n  preBalance?: InputMaybe<IntegerSelector>;\n  previousTxnId?: InputMaybe<IntegerSelector>;\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n  sender?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<HashSelector>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatesblockHeightArgs = {\n  blockHeight?: InputMaybe<BlockSelector>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatescountArgs = {\n  uniq?: InputMaybe<RippleRippleStatesUniq>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatescountBigIntArgs = {\n  uniq?: InputMaybe<RippleRippleStatesUniq>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatesflagsArgs = {\n  flags?: InputMaybe<IntegerSelector>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStateshighAccountArgs = {\n  highAccount?: InputMaybe<HashSelector>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStateslowAccountArgs = {\n  lowAccount?: InputMaybe<HashSelector>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatesmaximumArgs = {\n  get?: InputMaybe<RippleRippleStatesMeasureable>;\n  of: RippleRippleStatesMeasureable;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatesminimumArgs = {\n  get?: InputMaybe<RippleRippleStatesMeasureable>;\n  of: RippleRippleStatesMeasureable;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatesoperationArgs = {\n  operation?: InputMaybe<StringSelector>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatespreBalanceArgs = {\n  preBalance?: InputMaybe<HashSelector>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatespreviousTxnIdArgs = {\n  previousTxnId?: InputMaybe<IntegerSelector>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatespreviousTxnLedgerSeqArgs = {\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatessenderArgs = {\n  sender?: InputMaybe<HashSelector>;\n};\n\n\n/** The RippleState object type connects two accounts in a single currency */\nexport type RippleRippleStatestransactionTypeArgs = {\n  transactionType?: InputMaybe<TypeSelector>;\n};\n\nexport enum RippleRippleStatesMeasureable {\n  /** Number of block in the blockhains */\n  block_height = 'block_height',\n  /** Currency Address */\n  currency_address = 'currency_address',\n  /** Currency Symbol */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** High Account */\n  high_account = 'high_account',\n  /** Low Account */\n  low_account = 'low_account',\n  /** The address of the owner (sender) of this held payment */\n  sender = 'sender',\n  /** Time */\n  time = 'time'\n}\n\nexport enum RippleRippleStatesUniq {\n  /** Unique Number of block in the blockchains */\n  block_height = 'block_height',\n  /** Unique currencies */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique High Account */\n  high_account = 'high_account',\n  /** Unique Lower Account */\n  lower_account = 'lower_account',\n  /** Unique sender */\n  sender = 'sender',\n  /** Unique time */\n  times = 'times'\n}\n\nexport type RippleStatesFilter = {\n  balance?: InputMaybe<IntegerSelector>;\n  blockHeight?: InputMaybe<BlockSelector>;\n  date?: InputMaybe<DateSelector>;\n  flags?: InputMaybe<IntegerSelector>;\n  highAccount?: InputMaybe<HashSelector>;\n  lowAccount?: InputMaybe<HashSelector>;\n  operation?: InputMaybe<StringSelector>;\n  preBalance?: InputMaybe<IntegerSelector>;\n  previousTxnId?: InputMaybe<IntegerSelector>;\n  previousTxnLedgerSeq?: InputMaybe<IntegerSelector>;\n  sender?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<HashSelector>;\n};\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactions = {\n  __typename?: 'RippleTransactions';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** A transactions Flags field can contain flags that apply at different levels or contexts. */\n  flags?: Maybe<Scalars['BigInt']>;\n  /** Index in ledger */\n  indexInLedger?: Maybe<Scalars['BigInt']>;\n  /** Highest ledger index this transaction can appear in. */\n  lastLedgerSequence?: Maybe<Scalars['Float']>;\n  /** Block number */\n  ledger?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  /** Additional arbitrary information used to identify this transaction. */\n  memos?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Result */\n  result?: Maybe<Scalars['String']>;\n  /** Transaction Sender */\n  sender?: Maybe<Scalars['String']>;\n  /** The sequence number of the account sending the transaction. */\n  sequence?: Maybe<Scalars['Float']>;\n  /** Successful of not */\n  status?: Maybe<Scalars['Boolean']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Transaction fee */\n  transactionFee?: Maybe<Scalars['Float']>;\n  /** Transaction hash */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Transaction type */\n  transactionType?: Maybe<Scalars['String']>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionsanyArgs = {\n  of: RippleTransactionsMeasureable;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionscountArgs = {\n  uniq?: InputMaybe<RippleTransactionsUniq>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionscountBigIntArgs = {\n  uniq?: InputMaybe<RippleTransactionsUniq>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionslastLedgerSequenceArgs = {\n  lastLedgerSequence?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionsledgerArgs = {\n  ledger?: InputMaybe<BlockSelector>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionsmaximumArgs = {\n  get?: InputMaybe<RippleTransactionsMeasureable>;\n  of: RippleTransactionsMeasureable;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionsminimumArgs = {\n  get?: InputMaybe<RippleTransactionsMeasureable>;\n  of: RippleTransactionsMeasureable;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionsresultArgs = {\n  result?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionssenderArgs = {\n  sender?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionssequenceArgs = {\n  sequence?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionsstatusArgs = {\n  status?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionstransactionFeeArgs = {\n  transactionFee?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionstransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transactions in Ripple blockchain */\nexport type RippleTransactionstransactionTypeArgs = {\n  transactionType?: InputMaybe<TransactionTypeSelector>;\n};\n\nexport type RippleTransactionsFilter = {\n  date?: InputMaybe<DateSelector>;\n  lastLedgerSequence?: InputMaybe<HashSelector>;\n  ledger?: InputMaybe<BlockSelector>;\n  result?: InputMaybe<HashSelector>;\n  sender?: InputMaybe<HashSelector>;\n  sequence?: InputMaybe<HashSelector>;\n  status?: InputMaybe<Scalars['Boolean']>;\n  transactionFee?: InputMaybe<TransactionTypeSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<TransactionTypeSelector>;\n};\n\nexport enum RippleTransactionsMeasureable {\n  /** Date */\n  date = 'date',\n  /** Transaction sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transaction Fee */\n  transaction_fee = 'transaction_fee',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash'\n}\n\nexport enum RippleTransactionsUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique ledger count */\n  ledger = 'ledger',\n  /** Unique sender count */\n  sender = 'sender',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransfers = {\n  __typename?: 'RippleTransfers';\n  any?: Maybe<Scalars['String']>;\n  /** Number of block in the blockchains */\n  blockHeight?: Maybe<Scalars['BigInt']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of the money sender's transfer */\n  currencyFrom?: Maybe<Currency>;\n  /** Currency of the money receiver's transfer */\n  currencyTo?: Maybe<Currency>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** The sender of the Check. Cashing the Check debits this address`s balance. */\n  sender?: Maybe<Scalars['String']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Transaction Hash */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Transfer From */\n  transferFrom?: Maybe<Scalars['String']>;\n  /** Transfer To */\n  transferTo?: Maybe<Scalars['String']>;\n  valueFrom?: Maybe<Scalars['Float']>;\n  valueTo?: Maybe<Scalars['Float']>;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransfersanyArgs = {\n  of: RippleTransfersMeasureable;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransfersblockHeightArgs = {\n  blockHeight?: InputMaybe<BlockSelector>;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransferscountArgs = {\n  uniq?: InputMaybe<RippleTransfersUniq>;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransferscountBigIntArgs = {\n  uniq?: InputMaybe<RippleTransfersUniq>;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransfersmaximumArgs = {\n  get?: InputMaybe<RippleTransfersMeasureable>;\n  of: RippleTransfersMeasureable;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransfersminimumArgs = {\n  get?: InputMaybe<RippleTransfersMeasureable>;\n  of: RippleTransfersMeasureable;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransferssenderArgs = {\n  sender?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransferstransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransferstransferFromArgs = {\n  transferFrom?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransferstransferToArgs = {\n  transferTo?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransfersvalueFromArgs = {\n  blockHeight?: InputMaybe<BlockSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  sender?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<StringSelector>;\n  transferFrom?: InputMaybe<HashSelector>;\n  transferTo?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Ripple blockchain */\nexport type RippleTransfersvalueToArgs = {\n  blockHeight?: InputMaybe<BlockSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  sender?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<StringSelector>;\n  transferFrom?: InputMaybe<HashSelector>;\n  transferTo?: InputMaybe<HashSelector>;\n};\n\nexport type RippleTransfersFilter = {\n  blockHeight?: InputMaybe<BlockSelector>;\n  date?: InputMaybe<DateSelector>;\n  sender?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n  transactionType?: InputMaybe<StringSelector>;\n  transferFrom?: InputMaybe<HashSelector>;\n  transferTo?: InputMaybe<HashSelector>;\n};\n\nexport enum RippleTransfersMeasureable {\n  /** Number of block in the blockhains */\n  block_height = 'block_height',\n  /** Currency Address of the money sender`s transfer */\n  currency_from_address = 'currency_from_address',\n  /** Currency Symbol of the money sender`s transfer */\n  currency_from_symbol = 'currency_from_symbol',\n  /** Currency Address of the money receiver`s trasfer */\n  currency_to_address = 'currency_to_address',\n  /** Currency Symbol of the money receiver`s transfer */\n  currency_to_symbol = 'currency_to_symbol',\n  /** Date */\n  date = 'date',\n  /** The sender of the payment */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transfer From */\n  transfer_from = 'transfer_from',\n  /** Transfer To */\n  transfer_to = 'transfer_to',\n  /** Value From */\n  value_from = 'value_from',\n  /** Value To */\n  value_to = 'value_to'\n}\n\nexport enum RippleTransfersUniq {\n  /** Unique Number of block in the blockchains */\n  block_height = 'block_height',\n  /** Unique currencies */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique destination */\n  destination = 'destination',\n  /** Unique sender */\n  sender = 'sender',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum RippleccountRootsMeasureable {\n  /** The identifying (classic) address of this account. */\n  account = 'account',\n  /** Number of block in the blockhains */\n  block_height = 'block_height',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time'\n}\n\nexport enum ScriptTypeSelectorSelector {\n  /** Peer-to-peer */\n  peer_to_peer_transaction = 'peer_to_peer_transaction',\n  /** Unknown Transaction */\n  unknown_transaction = 'unknown_transaction'\n}\n\n/** Solana Sender */\nexport type Sender = {\n  __typename?: 'Sender';\n  address: Scalars['String'];\n  mintAccount: Scalars['String'];\n  type: Scalars['String'];\n};\n\n/** Smart contract method or event */\nexport type Signature = Event | Method;\n\nexport enum SignatureTypeSelector {\n  /** Smart contract event */\n  Event = 'Event',\n  /** Smart contract method */\n  Function = 'Function'\n}\n\n/** Blockchain smart contract */\nexport type SmartContract = {\n  __typename?: 'SmartContract';\n  /** String address representation */\n  address?: Maybe<Scalars['String']>;\n  /** Annotations ( tags ), if exists */\n  annotation?: Maybe<Scalars['String']>;\n  /** Smart Contract Type */\n  contractType: SmartContractType;\n  /** Smart Contract Protocol Type */\n  protocol?: Maybe<Scalars['String']>;\n};\n\nexport enum SmartContractArgumentsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique callers count */\n  callers = 'callers',\n  /** Calls or events */\n  calls = 'calls',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transaction senders */\n  senders = 'senders',\n  /** Unique signatures count */\n  signatures = 'signatures',\n  /** Unique smart contracts count */\n  smart_contracts = 'smart_contracts',\n  /** Unique transactions count */\n  txs = 'txs',\n  /** Unique values */\n  values = 'values'\n}\n\nexport enum SmartContractCallsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique callers count */\n  callers = 'callers',\n  /** Calls */\n  calls = 'calls',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique transaction senders */\n  senders = 'senders',\n  /** Unique smart contract methods count */\n  smart_contract_methods = 'smart_contract_methods',\n  /** Unique smart contracts count */\n  smart_contracts = 'smart_contracts',\n  /** Unique transactions count */\n  txs = 'txs'\n}\n\nexport enum SmartContractEventsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique smart contract methods count */\n  smart_contract_methods = 'smart_contract_methods',\n  /** Unique smart contracts count */\n  smart_contracts = 'smart_contracts',\n  /** Unique transaction senders */\n  tx_from = 'tx_from',\n  /** Unique callers count */\n  tx_to = 'tx_to',\n  /** Unique transactions count */\n  txs = 'txs'\n}\n\nexport type SmartContractReadonlyAttribute = {\n  __typename?: 'SmartContractReadonlyAttribute';\n  /** Value as address if applicable */\n  address?: Maybe<EthereumAddressInfo>;\n  /** Method name */\n  name: Scalars['String'];\n  /** Method return type */\n  type: Scalars['String'];\n  /** Method return value */\n  value: Scalars['String'];\n};\n\nexport enum SmartContractType {\n  /** Decentralized exchange */\n  DEX = 'DEX',\n  /** General Purpose Smart contract */\n  Generic = 'Generic',\n  /** Smart contract for token derivatives */\n  MarginPositionToken = 'MarginPositionToken',\n  /** Multi signature wallet */\n  Multisig = 'Multisig',\n  /** Not A Smart contract */\n  None = 'None',\n  /** Transaction Execution Approval Language */\n  TEAL = 'TEAL',\n  /** Token */\n  Token = 'Token',\n  /** Token Sale */\n  TokenSale = 'TokenSale'\n}\n\n/** Selector of smart contract type */\nexport type SmartContractTypeSelector = {\n  /** Smart Contract type in the list */\n  in?: InputMaybe<Array<SmartContractType>>;\n  /** Smart Contract type is */\n  is?: InputMaybe<SmartContractType>;\n  /** Smart Contract type not */\n  not?: InputMaybe<SmartContractType>;\n  /** Smart Contract type not in the list */\n  notIn?: InputMaybe<Array<SmartContractType>>;\n};\n\n/** Solana Chain */\nexport type Solana = {\n  __typename?: 'Solana';\n  /** BlockRewards of Smart Contract Calls and Events */\n  blockRewards?: Maybe<Array<SolanaBlockReward>>;\n  /** Solana Blocks */\n  blocks?: Maybe<Array<SolanaBlock>>;\n  /**\n   * Each instruction specifies a single program, a subset of the transaction`s accounts\n   *         that should be passed to the program.\n   */\n  instructionAccounts?: Maybe<Array<SolanaInstructionAccount>>;\n  /**\n   * Each instruction specifies a single program, a subset of the transaction`s accounts\n   *         that should be passed to the program.\n   */\n  instructions?: Maybe<Array<SolanaInstruction>>;\n  /** Solana Transaction */\n  transactions?: Maybe<Array<SolanaTransaction>>;\n  /** Currency transfers from/to addresses in crypto currencies */\n  transfers?: Maybe<Array<SolanaTransfer>>;\n};\n\n\n/** Solana Chain */\nexport type SolanablockRewardsArgs = {\n  account?: InputMaybe<StringSelector>;\n  any?: InputMaybe<Array<SolanaBlockRewardFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  parentSlot?: InputMaybe<IntegerSelector>;\n  postBalance?: InputMaybe<AmountSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  reward?: InputMaybe<AmountSelector>;\n  rewardType?: InputMaybe<RewardTypeSelector>;\n};\n\n\n/** Solana Chain */\nexport type SolanablocksArgs = {\n  any?: InputMaybe<Array<SolanaBlockFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  parentSlot?: InputMaybe<IntegerSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  rewards?: InputMaybe<AmountSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Solana Chain */\nexport type SolanainstructionAccountsArgs = {\n  account?: InputMaybe<StringSelector>;\n  accountIndex?: InputMaybe<IntegerSelector>;\n  accountOwner?: InputMaybe<StringSelector>;\n  accountType?: InputMaybe<StringSelector>;\n  any?: InputMaybe<Array<SolanaInstructionAccountFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  callPath?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<IntegerSelector>;\n  fee?: InputMaybe<IntegerSelector>;\n  feePayer?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  parsed?: InputMaybe<IntegerSelector>;\n  parsedActionName?: InputMaybe<StringSelector>;\n  parsedProgramName?: InputMaybe<StringSelector>;\n  parsedType?: InputMaybe<StringSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  programId?: InputMaybe<StringSelector>;\n  signature?: InputMaybe<StringSelector>;\n  success?: InputMaybe<BooleanSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Solana Chain */\nexport type SolanainstructionsArgs = {\n  any?: InputMaybe<Array<SolanaInstructionFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  callPath?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<IntegerSelector>;\n  externalParsed?: InputMaybe<IntegerSelector>;\n  externalParsedActionName?: InputMaybe<StringSelector>;\n  externalParsedProgramName?: InputMaybe<StringSelector>;\n  externalParsedType?: InputMaybe<StringSelector>;\n  externalProgramId?: InputMaybe<StringSelector>;\n  fee?: InputMaybe<IntegerSelector>;\n  feePayer?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  parsed?: InputMaybe<IntegerSelector>;\n  parsedActionName?: InputMaybe<StringSelector>;\n  parsedProgramName?: InputMaybe<StringSelector>;\n  parsedType?: InputMaybe<StringSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  programId?: InputMaybe<StringSelector>;\n  signature?: InputMaybe<StringSelector>;\n  success?: InputMaybe<BooleanSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Solana Chain */\nexport type SolanatransactionsArgs = {\n  accountsCount?: InputMaybe<IntegerSelector>;\n  any?: InputMaybe<Array<SolanaTransactionFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  fee?: InputMaybe<IntegerSelector>;\n  feePayer?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  innerInstructionsCount?: InputMaybe<IntegerSelector>;\n  instructionsCount?: InputMaybe<IntegerSelector>;\n  options?: InputMaybe<QueryOptions>;\n  parentSlot?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  recentBlockHash?: InputMaybe<HashSelector>;\n  signature?: InputMaybe<HashSelector>;\n  signer?: InputMaybe<HashSelector>;\n  success?: InputMaybe<BooleanSelector>;\n  transactionFee?: InputMaybe<AmountSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Solana Chain */\nexport type SolanatransfersArgs = {\n  any?: InputMaybe<Array<SolanaTransferFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  callPath?: InputMaybe<StringSelector>;\n  currency?: InputMaybe<Array<SolanaCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<StringSelector>;\n  externalParsed?: InputMaybe<IntegerSelector>;\n  externalParsedActionName?: InputMaybe<StringSelector>;\n  externalParsedProgramName?: InputMaybe<StringSelector>;\n  externalParsedType?: InputMaybe<StringSelector>;\n  externalProgramId?: InputMaybe<StringSelector>;\n  feePayer?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  parsed?: InputMaybe<IntegerSelector>;\n  parsedActionName?: InputMaybe<StringSelector>;\n  parsedProgramName?: InputMaybe<StringSelector>;\n  parsedType?: InputMaybe<StringSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  programId?: InputMaybe<StringSelector>;\n  receiverAddress?: InputMaybe<StringSelector>;\n  receiverType?: InputMaybe<StringSelector>;\n  recentBlockHash?: InputMaybe<HashSelector>;\n  senderAddress?: InputMaybe<StringSelector>;\n  senderType?: InputMaybe<StringSelector>;\n  signature?: InputMaybe<HashSelector>;\n  success?: InputMaybe<BooleanSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n  transferType?: InputMaybe<SolanaTransferTypeSelector>;\n};\n\n/** Solana Account */\nexport type SolanaAccount = {\n  __typename?: 'SolanaAccount';\n  index: Scalars['Int'];\n  name: Scalars['String'];\n  owner: Scalars['String'];\n  type: Scalars['String'];\n};\n\n/** Block in Solana  blockchain */\nexport type SolanaBlock = {\n  __typename?: 'SolanaBlock';\n  any?: Maybe<Scalars['String']>;\n  /** Hash of the the block */\n  blockHash?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Number of block in the blockchains */\n  height?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** The slot index of this block`s parent */\n  parentSlot?: Maybe<Scalars['BigInt']>;\n  /** The block hash of this block`s parent */\n  previousBlockHash?: Maybe<Scalars['String']>;\n  rewards?: Maybe<Scalars['Float']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Count of transactions in this block */\n  transactionCount?: Maybe<Scalars['Int']>;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlockanyArgs = {\n  of: SolanaBlockMeasureable;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlockblockHashArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlockcountArgs = {\n  uniq?: InputMaybe<SolanaBlockUniq>;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlockcountBigIntArgs = {\n  uniq?: InputMaybe<SolanaBlockUniq>;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlockheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlockmaximumArgs = {\n  get?: InputMaybe<SolanaBlockMeasureable>;\n  of: SolanaBlockMeasureable;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlockminimumArgs = {\n  get?: InputMaybe<SolanaBlockMeasureable>;\n  of: SolanaBlockMeasureable;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlockparentSlotArgs = {\n  parentSlot?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlockpreviousBlockHashArgs = {\n  previousBlockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlockrewardsArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  parentSlot?: InputMaybe<IntegerSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  rewards?: InputMaybe<AmountSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Block in Solana  blockchain */\nexport type SolanaBlocktransactionCountArgs = {\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\nexport type SolanaBlockFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  parentSlot?: InputMaybe<IntegerSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  rewards?: InputMaybe<AmountSelector>;\n  transactionCount?: InputMaybe<IntegerSelector>;\n};\n\n/** Solana Block Info */\nexport type SolanaBlockInfo = {\n  __typename?: 'SolanaBlockInfo';\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  parentSlot?: Maybe<Scalars['BigInt']>;\n  previousBlockHash?: Maybe<Scalars['String']>;\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n};\n\nexport enum SolanaBlockMeasureable {\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** The slot index of this block`s parent */\n  parent_slot = 'parent_slot',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Number of reward lamports credited or debited by the account */\n  rewards = 'rewards',\n  /** Time */\n  time = 'time',\n  /** Count of transactions in this block */\n  transaction_count = 'transaction_count'\n}\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockReward = {\n  __typename?: 'SolanaBlockReward';\n  /** Account */\n  account?: Maybe<Scalars['String']>;\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where  transaction is included */\n  block?: Maybe<SolanaBlockInfo>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  postBalance?: Maybe<Scalars['Float']>;\n  /** Type of reward */\n  rewardType?: Maybe<Scalars['String']>;\n};\n\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockRewardaccountArgs = {\n  account?: InputMaybe<BlockSelector>;\n};\n\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockRewardamountArgs = {\n  account?: InputMaybe<StringSelector>;\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  parentSlot?: InputMaybe<IntegerSelector>;\n  postBalance?: InputMaybe<AmountSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  reward?: InputMaybe<AmountSelector>;\n  rewardType?: InputMaybe<RewardTypeSelector>;\n};\n\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockRewardanyArgs = {\n  of: SolanaBlockRewardMeasureable;\n};\n\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockRewardblockArgs = {\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockRewardcountArgs = {\n  uniq?: InputMaybe<SolanaBlockRewardUniq>;\n};\n\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockRewardcountBigIntArgs = {\n  uniq?: InputMaybe<SolanaBlockRewardUniq>;\n};\n\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockRewardmaximumArgs = {\n  get?: InputMaybe<SolanaBlockRewardMeasureable>;\n  of: SolanaBlockRewardMeasureable;\n};\n\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockRewardminimumArgs = {\n  get?: InputMaybe<SolanaBlockRewardMeasureable>;\n  of: SolanaBlockRewardMeasureable;\n};\n\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockRewardpostBalanceArgs = {\n  account?: InputMaybe<StringSelector>;\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  parentSlot?: InputMaybe<IntegerSelector>;\n  postBalance?: InputMaybe<AmountSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  reward?: InputMaybe<AmountSelector>;\n  rewardType?: InputMaybe<RewardTypeSelector>;\n};\n\n\n/** BlockReward in Solana  blockchain */\nexport type SolanaBlockRewardrewardTypeArgs = {\n  rewardType?: InputMaybe<RewardTypeSelector>;\n};\n\nexport type SolanaBlockRewardFilter = {\n  account?: InputMaybe<StringSelector>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  parentSlot?: InputMaybe<IntegerSelector>;\n  postBalance?: InputMaybe<AmountSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  reward?: InputMaybe<AmountSelector>;\n  rewardType?: InputMaybe<RewardTypeSelector>;\n};\n\nexport enum SolanaBlockRewardMeasureable {\n  /** Account */\n  account = 'account',\n  /** Number of reward lamports credited or debited by the account */\n  amount = 'amount',\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** The slot index of this block`s parent */\n  parent_slot = 'parent_slot',\n  /** Account balances after the transaction was processed */\n  post_balance = 'post_balance',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Time */\n  time = 'time'\n}\n\nexport enum SolanaBlockRewardUniq {\n  /** Unique accounts */\n  account = 'account',\n  /** Unique hash of the the block */\n  block_hash = 'block_hash',\n  /** Unique currencies */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum SolanaBlockUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique Number of block in the blockchains */\n  height = 'height',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use filter bby symbol, bbut it only works if there is just one token with that symbol */\nexport type SolanaCurrencySelector = {\n  /** Currency in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Currency is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Currency not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Currency not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstruction = {\n  __typename?: 'SolanaInstruction';\n  /** Accounts count */\n  accountsCount?: Maybe<Scalars['Int']>;\n  /** Action */\n  action?: Maybe<Action>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where  transaction is included */\n  block?: Maybe<SolanaBlockInfo>;\n  /** Call Path */\n  callPath?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Instruction Data */\n  data?: Maybe<Data>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** External */\n  external?: Maybe<Scalars['Boolean']>;\n  /** External Action */\n  externalAction?: Maybe<Action>;\n  /** External Program */\n  externalProgram?: Maybe<Program>;\n  log?: Maybe<Log>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Program */\n  program?: Maybe<Program>;\n  /** Transaction where instruction is included */\n  transaction?: Maybe<SolanaTransactionInfo>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructionactionArgs = {\n  parsedActionName?: InputMaybe<StringSelector>;\n  parsedType?: InputMaybe<StringSelector>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructionanyArgs = {\n  of: SolanaInstructionMeasureable;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructionblockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructioncallPathArgs = {\n  callPath?: InputMaybe<StringSelector>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructioncountArgs = {\n  uniq?: InputMaybe<SolanaInstructionUniq>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructioncountBigIntArgs = {\n  uniq?: InputMaybe<SolanaInstructionUniq>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructiondataArgs = {\n  dataBase58?: InputMaybe<StringSelector>;\n  dataHex?: InputMaybe<StringSelector>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructionexternalArgs = {\n  external?: InputMaybe<BooleanSelector>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructionexternalActionArgs = {\n  externalParsedActionName?: InputMaybe<StringSelector>;\n  externalParsedType?: InputMaybe<StringSelector>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructionexternalProgramArgs = {\n  externalParsedProgramName?: InputMaybe<StringSelector>;\n  externalProgramId?: InputMaybe<StringSelector>;\n  externalProgramName?: InputMaybe<StringSelector>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructionmaximumArgs = {\n  get?: InputMaybe<SolanaInstructionMeasureable>;\n  of: SolanaInstructionMeasureable;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructionminimumArgs = {\n  get?: InputMaybe<SolanaInstructionMeasureable>;\n  of: SolanaInstructionMeasureable;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructionprogramArgs = {\n  parsedProgramName?: InputMaybe<StringSelector>;\n  programId?: InputMaybe<StringSelector>;\n  programName?: InputMaybe<StringSelector>;\n};\n\n\n/** Instruction in Solana  blockchain */\nexport type SolanaInstructiontransactionArgs = {\n  signature?: InputMaybe<HashSelector>;\n};\n\n/** InstructionAccount in Solana  blockchain */\nexport type SolanaInstructionAccount = {\n  __typename?: 'SolanaInstructionAccount';\n  /** Information about account */\n  account?: Maybe<SolanaAccount>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<SolanaBlockInfo>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Instruction */\n  instruction?: Maybe<Instruction>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Transaction */\n  transaction?: Maybe<SolanaTransactionInfo>;\n};\n\n\n/** InstructionAccount in Solana  blockchain */\nexport type SolanaInstructionAccountaccountArgs = {\n  accountIndex?: InputMaybe<IntegerSelector>;\n  accountName?: InputMaybe<StringSelector>;\n  accountOwner?: InputMaybe<StringSelector>;\n  accountType?: InputMaybe<StringSelector>;\n};\n\n\n/** InstructionAccount in Solana  blockchain */\nexport type SolanaInstructionAccountanyArgs = {\n  of: SolanaInstructionAccountMeasureable;\n};\n\n\n/** InstructionAccount in Solana  blockchain */\nexport type SolanaInstructionAccountblockArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** InstructionAccount in Solana  blockchain */\nexport type SolanaInstructionAccountcountArgs = {\n  uniq?: InputMaybe<SolanaInstructionAccountUniq>;\n};\n\n\n/** InstructionAccount in Solana  blockchain */\nexport type SolanaInstructionAccountcountBigIntArgs = {\n  uniq?: InputMaybe<SolanaInstructionAccountUniq>;\n};\n\n\n/** InstructionAccount in Solana  blockchain */\nexport type SolanaInstructionAccountmaximumArgs = {\n  get?: InputMaybe<SolanaInstructionAccountMeasureable>;\n  of: SolanaInstructionAccountMeasureable;\n};\n\n\n/** InstructionAccount in Solana  blockchain */\nexport type SolanaInstructionAccountminimumArgs = {\n  get?: InputMaybe<SolanaInstructionAccountMeasureable>;\n  of: SolanaInstructionAccountMeasureable;\n};\n\n\n/** InstructionAccount in Solana  blockchain */\nexport type SolanaInstructionAccounttransactionArgs = {\n  signature?: InputMaybe<HashSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n};\n\nexport type SolanaInstructionAccountFilter = {\n  account?: InputMaybe<StringSelector>;\n  accountIndex?: InputMaybe<IntegerSelector>;\n  accountOwner?: InputMaybe<StringSelector>;\n  accountType?: InputMaybe<StringSelector>;\n  blockHash?: InputMaybe<HashSelector>;\n  callPath?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<IntegerSelector>;\n  fee?: InputMaybe<IntegerSelector>;\n  feePayer?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  parsed?: InputMaybe<IntegerSelector>;\n  parsedActionName?: InputMaybe<StringSelector>;\n  parsedProgramName?: InputMaybe<StringSelector>;\n  parsedType?: InputMaybe<StringSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  programId?: InputMaybe<StringSelector>;\n  signature?: InputMaybe<StringSelector>;\n  success?: InputMaybe<BooleanSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n};\n\nexport enum SolanaInstructionAccountMeasureable {\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Transaction Hash */\n  signature = 'signature',\n  /** Time */\n  time = 'time'\n}\n\nexport enum SolanaInstructionAccountUniq {\n  /** Account name */\n  account_name = 'account_name',\n  /** Unique date count */\n  dates = 'dates',\n  /** Number of block in the blockchains */\n  height = 'height',\n  /** Transaction Hash */\n  signature = 'signature',\n  /** Unique time */\n  times = 'times'\n}\n\nexport type SolanaInstructionFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  callPath?: InputMaybe<StringSelector>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<IntegerSelector>;\n  externalParsed?: InputMaybe<IntegerSelector>;\n  externalParsedActionName?: InputMaybe<StringSelector>;\n  externalParsedProgramName?: InputMaybe<StringSelector>;\n  externalParsedType?: InputMaybe<StringSelector>;\n  externalProgramId?: InputMaybe<StringSelector>;\n  fee?: InputMaybe<IntegerSelector>;\n  feePayer?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  parsed?: InputMaybe<IntegerSelector>;\n  parsedActionName?: InputMaybe<StringSelector>;\n  parsedProgramName?: InputMaybe<StringSelector>;\n  parsedType?: InputMaybe<StringSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  programId?: InputMaybe<StringSelector>;\n  signature?: InputMaybe<StringSelector>;\n  success?: InputMaybe<BooleanSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n};\n\nexport enum SolanaInstructionMeasureable {\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Transaction Fee */\n  fee = 'fee',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Transaction Hash */\n  signature = 'signature',\n  /** Time */\n  time = 'time'\n}\n\nexport enum SolanaInstructionUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Number of block in the blockchains */\n  height = 'height',\n  /** Transaction Hash */\n  signature = 'signature',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum SolanaNetwork {\n  /** Solana Mainnat */\n  solana = 'solana'\n}\n\nexport enum SolanaRewardType {\n  /** fee type */\n  Fee = 'Fee',\n  /** rent type */\n  Rent = 'Rent',\n  /** staking type */\n  Staking = 'Staking',\n  /** voing type */\n  Voting = 'Voting'\n}\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransaction = {\n  __typename?: 'SolanaTransaction';\n  /** Count of inner instructions */\n  accountsCount?: Maybe<Scalars['Int']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where  transaction is included */\n  block?: Maybe<SolanaBlockInfo>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Error */\n  error?: Maybe<Scalars['String']>;\n  /** Fee Payer */\n  feePayer?: Maybe<Scalars['String']>;\n  /** Count of inner instructions */\n  innerInstructionsCount?: Maybe<Scalars['Int']>;\n  /** Count of instructions */\n  instructionsCount?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Recent blockhash prevents duplication and to give transactions lifetimes */\n  recentBlockHash?: Maybe<Scalars['String']>;\n  /** Transaction Hash */\n  signature?: Maybe<Scalars['String']>;\n  /** Accounts` public keys */\n  signer?: Maybe<Scalars['String']>;\n  /** Successed or failed */\n  success?: Maybe<Scalars['Boolean']>;\n  transactionFee?: Maybe<Scalars['Float']>;\n  /** Transaction Index */\n  transactionIndex?: Maybe<Scalars['Int']>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionaccountsCountArgs = {\n  accountsCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionanyArgs = {\n  of: SolanaTransactionMeasureable;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionblockArgs = {\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactioncountArgs = {\n  uniq?: InputMaybe<SolanaTransactionUniq>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactioncountBigIntArgs = {\n  uniq?: InputMaybe<SolanaTransactionUniq>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionerrorArgs = {\n  error?: InputMaybe<StringSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionfeePayerArgs = {\n  feePayer?: InputMaybe<HashSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactioninnerInstructionsCountArgs = {\n  innerInstructionsCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactioninstructionsCountArgs = {\n  instructionsCount?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionmaximumArgs = {\n  get?: InputMaybe<SolanaTransactionMeasureable>;\n  of: SolanaTransactionMeasureable;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionminimumArgs = {\n  get?: InputMaybe<SolanaTransactionMeasureable>;\n  of: SolanaTransactionMeasureable;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionrecentBlockHashArgs = {\n  recentBlockHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionsignatureArgs = {\n  signature?: InputMaybe<HashSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionsignerArgs = {\n  signer?: InputMaybe<HashSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactionsuccessArgs = {\n  success?: InputMaybe<BooleanSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactiontransactionFeeArgs = {\n  accountsCount?: InputMaybe<IntegerSelector>;\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  fee?: InputMaybe<IntegerSelector>;\n  feePayer?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  innerInstructionsCount?: InputMaybe<IntegerSelector>;\n  instructionsCount?: InputMaybe<IntegerSelector>;\n  parentSlot?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  recentBlockHash?: InputMaybe<HashSelector>;\n  signature?: InputMaybe<HashSelector>;\n  signer?: InputMaybe<HashSelector>;\n  success?: InputMaybe<BooleanSelector>;\n  transactionFee?: InputMaybe<AmountSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Transaction in Solana  blockchain */\nexport type SolanaTransactiontransactionIndexArgs = {\n  transactionIndex?: InputMaybe<IntegerSelector>;\n};\n\nexport type SolanaTransactionFilter = {\n  accountsCount?: InputMaybe<IntegerSelector>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  fee?: InputMaybe<IntegerSelector>;\n  feePayer?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  innerInstructionsCount?: InputMaybe<IntegerSelector>;\n  instructionsCount?: InputMaybe<IntegerSelector>;\n  parentSlot?: InputMaybe<BlockSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  recentBlockHash?: InputMaybe<HashSelector>;\n  signature?: InputMaybe<HashSelector>;\n  signer?: InputMaybe<HashSelector>;\n  success?: InputMaybe<BooleanSelector>;\n  transactionFee?: InputMaybe<AmountSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n};\n\n/** Solana Transaction Info */\nexport type SolanaTransactionInfo = {\n  __typename?: 'SolanaTransactionInfo';\n  feePayer?: Maybe<Scalars['String']>;\n  signature?: Maybe<Scalars['String']>;\n  success?: Maybe<Scalars['Boolean']>;\n  transactionIndex?: Maybe<Scalars['BigInt']>;\n};\n\n/** Solana Transaction Info Extended */\nexport type SolanaTransactionInfoExt = {\n  __typename?: 'SolanaTransactionInfoExt';\n  accountsCount?: Maybe<Scalars['Int']>;\n  error?: Maybe<Scalars['String']>;\n  fee?: Maybe<Scalars['Float']>;\n  feePayer?: Maybe<Scalars['String']>;\n  innerInstructionsCount?: Maybe<Scalars['Int']>;\n  instructionsCount?: Maybe<Scalars['Int']>;\n  recentBlockHash?: Maybe<Scalars['String']>;\n  signature?: Maybe<Scalars['String']>;\n  signer?: Maybe<Scalars['String']>;\n  success?: Maybe<Scalars['Boolean']>;\n  transactionIndex?: Maybe<Scalars['BigInt']>;\n};\n\nexport enum SolanaTransactionMeasureable {\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Transaction Fee */\n  fee = 'fee',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** The slot index of this block`s parent */\n  parent_slot = 'parent_slot',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Transaction Hash */\n  signature = 'signature',\n  /** Time */\n  time = 'time',\n  /** Transaction Fee */\n  transaction_fee = 'transaction_fee'\n}\n\nexport enum SolanaTransactionUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Number of block in the blockchains */\n  height = 'height',\n  /** Transaction Hash */\n  signature = 'signature',\n  /** Accounts` public key */\n  signer = 'signer',\n  /** Unique time */\n  times = 'times'\n}\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type SolanaTransfer = {\n  __typename?: 'SolanaTransfer';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<SolanaBlockInfo>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Instruction where transfer is included */\n  instruction?: Maybe<InstructionWithExternals>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver */\n  receiver?: Maybe<Receiver>;\n  /** Sender */\n  sender?: Maybe<Sender>;\n  /** Transaction where transfer is included */\n  transaction?: Maybe<SolanaTransactionInfoExt>;\n  /** Transfer Type */\n  transferType?: Maybe<Scalars['String']>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type SolanaTransferamountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  callPath?: InputMaybe<StringSelector>;\n  currency?: InputMaybe<Array<SolanaCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<StringSelector>;\n  externalParsed?: InputMaybe<IntegerSelector>;\n  externalParsedActionName?: InputMaybe<StringSelector>;\n  externalParsedProgramName?: InputMaybe<StringSelector>;\n  externalParsedType?: InputMaybe<StringSelector>;\n  externalProgramId?: InputMaybe<StringSelector>;\n  feePayer?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  parsed?: InputMaybe<IntegerSelector>;\n  parsedActionName?: InputMaybe<StringSelector>;\n  parsedProgramName?: InputMaybe<StringSelector>;\n  parsedType?: InputMaybe<StringSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  programId?: InputMaybe<StringSelector>;\n  receiverAddress?: InputMaybe<StringSelector>;\n  receiverType?: InputMaybe<StringSelector>;\n  recentBlockHash?: InputMaybe<HashSelector>;\n  senderAddress?: InputMaybe<StringSelector>;\n  senderType?: InputMaybe<StringSelector>;\n  signature?: InputMaybe<HashSelector>;\n  success?: InputMaybe<BooleanSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n  transferType?: InputMaybe<SolanaTransferTypeSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type SolanaTransferanyArgs = {\n  of: SolanaTransferMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type SolanaTransferblockArgs = {\n  hash?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type SolanaTransfercountArgs = {\n  uniq?: InputMaybe<SolanaTransferUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type SolanaTransfercountBigIntArgs = {\n  uniq?: InputMaybe<SolanaTransferUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type SolanaTransfermaximumArgs = {\n  get?: InputMaybe<SolanaTransferMeasureable>;\n  of: SolanaTransferMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type SolanaTransferminimumArgs = {\n  get?: InputMaybe<SolanaTransferMeasureable>;\n  of: SolanaTransferMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type SolanaTransfertransactionArgs = {\n  signature?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type SolanaTransfertransferTypeArgs = {\n  transferType?: InputMaybe<SolanaTransferTypeSelector>;\n};\n\nexport type SolanaTransferFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  callPath?: InputMaybe<StringSelector>;\n  currency?: InputMaybe<Array<SolanaCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<StringSelector>;\n  externalParsed?: InputMaybe<IntegerSelector>;\n  externalParsedActionName?: InputMaybe<StringSelector>;\n  externalParsedProgramName?: InputMaybe<StringSelector>;\n  externalParsedType?: InputMaybe<StringSelector>;\n  externalProgramId?: InputMaybe<StringSelector>;\n  feePayer?: InputMaybe<HashSelector>;\n  height?: InputMaybe<BlockSelector>;\n  parsed?: InputMaybe<IntegerSelector>;\n  parsedActionName?: InputMaybe<StringSelector>;\n  parsedProgramName?: InputMaybe<StringSelector>;\n  parsedType?: InputMaybe<StringSelector>;\n  previousBlockHash?: InputMaybe<HashSelector>;\n  programId?: InputMaybe<StringSelector>;\n  receiverAddress?: InputMaybe<StringSelector>;\n  receiverType?: InputMaybe<StringSelector>;\n  recentBlockHash?: InputMaybe<HashSelector>;\n  senderAddress?: InputMaybe<StringSelector>;\n  senderType?: InputMaybe<StringSelector>;\n  signature?: InputMaybe<HashSelector>;\n  success?: InputMaybe<BooleanSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  transactionIndex?: InputMaybe<IntegerSelector>;\n  transferType?: InputMaybe<SolanaTransferTypeSelector>;\n};\n\nexport enum SolanaTransferMeasureable {\n  /** Amount Transfer */\n  amount = 'amount',\n  /** Hash of the the block */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Transaction Fee */\n  fee_payer = 'fee_payer',\n  /** Number of block in the blockhains */\n  height = 'height',\n  /** The block hash of this block`s parent */\n  previous_block_hash = 'previous_block_hash',\n  /** Transaction Hash */\n  signature = 'signature',\n  /** Time */\n  time = 'time',\n  /** Transfer Type */\n  transfer_type = 'transfer_type'\n}\n\nexport enum SolanaTransferType {\n  /** Burn */\n  burn = 'burn',\n  /** Close Account */\n  close_account = 'close_account',\n  /** Create Account */\n  create_account = 'create_account',\n  /** Mint */\n  mint = 'mint',\n  /** Nonce Withdraw */\n  nonce_withdraw = 'nonce_withdraw',\n  /** Rent Exemption */\n  rent_exemption = 'rent_exemption',\n  /** Self */\n  self = 'self',\n  /** Stake */\n  stake = 'stake',\n  /** Stake Withdraw */\n  stake_withdraw = 'stake_withdraw',\n  /** Trade Unknown */\n  trade_unknown = 'trade_unknown',\n  /** Transfer */\n  transfer = 'transfer',\n  /** Vote */\n  vote = 'vote'\n}\n\n/** Select by transfer type */\nexport type SolanaTransferTypeSelector = {\n  /** Type in the list */\n  in?: InputMaybe<Array<SolanaTransferType>>;\n  /** Type is */\n  is?: InputMaybe<SolanaTransferType>;\n  /** Type not */\n  not?: InputMaybe<SolanaTransferType>;\n  /** Type not in the list */\n  notIn?: InputMaybe<Array<SolanaTransferType>>;\n};\n\nexport enum SolanaTransferUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Number of block in the blockchains */\n  height = 'height',\n  /** Transfer To */\n  receiver_address = 'receiver_address',\n  /** Transfer From */\n  sender_address = 'sender_address',\n  /** Transaction Hash */\n  signature = 'signature',\n  /** Unique time */\n  times = 'times'\n}\n\nexport enum StakingTransactionsTypeEnum {\n  CollectRewards = 'CollectRewards',\n  CreateValidator = 'CreateValidator',\n  Delegate = 'Delegate',\n  EditValidator = 'EditValidator',\n  Undelegate = 'Undelegate'\n}\n\n/** Indicates what type of operation the transaction is supposed to do. */\nexport type StakingTransactionsTypeSelector = {\n  /** Type in the list */\n  in?: InputMaybe<Array<StakingTransactionsTypeEnum>>;\n  /** Type is */\n  is?: InputMaybe<StakingTransactionsTypeEnum>;\n  /** Type not */\n  not?: InputMaybe<StakingTransactionsTypeEnum>;\n  /** Type not in the list */\n  notIn?: InputMaybe<Array<StakingTransactionsTypeEnum>>;\n};\n\n/** Stellar Chain */\nexport type Stellar = {\n  __typename?: 'Stellar';\n  /** Stellar Transfers */\n  transfers?: Maybe<Array<StellarTransfers>>;\n};\n\n\n/** Stellar Chain */\nexport type StellartransfersArgs = {\n  any?: InputMaybe<Array<StellarTransfersFilter>>;\n  date?: InputMaybe<DateSelector>;\n  direction?: InputMaybe<HashSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<HashSelector>;\n  sender?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\nexport enum StellarNetwork {\n  /** The Stellar Ledger */\n  stellar = 'stellar'\n}\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransfers = {\n  __typename?: 'StellarTransfers';\n  amountFrom?: Maybe<Scalars['Float']>;\n  amountTo?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency from of transfer */\n  currencyFrom?: Maybe<Currency>;\n  /** Currency to of transfer */\n  currencyTo?: Maybe<Currency>;\n  /** The date this transaction was created */\n  date?: Maybe<Date>;\n  /** Direction */\n  direction?: Maybe<Scalars['String']>;\n  /** The sequence number of the ledger that this transaction was included in */\n  ledger?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Operation */\n  operation?: Maybe<Scalars['String']>;\n  /** The number of operations contained within this transaction */\n  operationCount?: Maybe<Scalars['BigInt']>;\n  /** The account this transaction is been sent to */\n  receiver?: Maybe<Scalars['String']>;\n  /** Sender */\n  sender?: Maybe<Scalars['String']>;\n  /** The time this transaction was created */\n  time?: Maybe<DateTime>;\n  /** Hash of this transaction */\n  transactionHash?: Maybe<Scalars['String']>;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransfersamountFromArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  direction?: InputMaybe<HashSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  receiver?: InputMaybe<HashSelector>;\n  sender?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransfersamountToArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  direction?: InputMaybe<HashSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  receiver?: InputMaybe<HashSelector>;\n  sender?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransfersanyArgs = {\n  of: StellarTransfersMeasureable;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransferscountArgs = {\n  uniq?: InputMaybe<StellarTransfersUniq>;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransferscountBigIntArgs = {\n  uniq?: InputMaybe<StellarTransfersUniq>;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransfersdirectionArgs = {\n  direction?: InputMaybe<StringSelector>;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransfersmaximumArgs = {\n  get?: InputMaybe<StellarTransfersMeasureable>;\n  of: StellarTransfersMeasureable;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransfersminimumArgs = {\n  get?: InputMaybe<StellarTransfersMeasureable>;\n  of: StellarTransfersMeasureable;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransfersreceiverArgs = {\n  receiver?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransferssenderArgs = {\n  sender?: InputMaybe<HashSelector>;\n};\n\n\n/** Transfers in Stellar blockchain */\nexport type StellarTransferstransactionHashArgs = {\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\nexport type StellarTransfersFilter = {\n  date?: InputMaybe<DateSelector>;\n  direction?: InputMaybe<HashSelector>;\n  receiver?: InputMaybe<HashSelector>;\n  sender?: InputMaybe<HashSelector>;\n  transactionHash?: InputMaybe<HashSelector>;\n};\n\nexport enum StellarTransfersMeasureable {\n  /** Date */\n  date = 'date',\n  /** Transfer Receiver */\n  receiver = 'receiver',\n  /** Transfer Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Transaction Hash */\n  transaction_hash = 'transaction_hash'\n}\n\nexport enum StellarTransfersUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Transfer Receiver */\n  receiver = 'receiver',\n  /** Transfer sender */\n  sender = 'sender',\n  /** Unique time */\n  times = 'times',\n  /** Unique date count */\n  transaction_hash = 'transaction_hash'\n}\n\n/** Select by ID */\nexport type StringIdSelector = {\n  /** ID in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** ID is */\n  is?: InputMaybe<Scalars['String']>;\n  /** ID not */\n  not?: InputMaybe<Scalars['String']>;\n  /** ID not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Select by string */\nexport type StringSelector = {\n  /** String in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** String is */\n  is?: InputMaybe<Scalars['String']>;\n  /** String not */\n  not?: InputMaybe<Scalars['String']>;\n  /** String not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Search result subject */\nexport type Subject = Address | Currency | SmartContract | TransactionHash;\n\n/** Blockchain Unified GraphQL Subscription API */\nexport type Subscription = {\n  __typename?: 'Subscription';\n  /** Ethereum Mainnet / Classic Chain Datasets */\n  ethereum?: Maybe<Ethereum>;\n};\n\n\n/** Blockchain Unified GraphQL Subscription API */\nexport type SubscriptionethereumArgs = {\n  network?: InputMaybe<EthereumNetwork>;\n};\n\n/** Time Interval */\nexport type TimeInterval = {\n  __typename?: 'TimeInterval';\n  day: Scalars['String'];\n  hour: Scalars['String'];\n  minute: Scalars['String'];\n  month: Scalars['String'];\n  second: Scalars['String'];\n  year: Scalars['String'];\n};\n\n\n/** Time Interval */\nexport type TimeIntervaldayArgs = {\n  count?: InputMaybe<Scalars['Int']>;\n  format?: InputMaybe<Scalars['String']>;\n};\n\n\n/** Time Interval */\nexport type TimeIntervalhourArgs = {\n  count?: InputMaybe<Scalars['Int']>;\n  format?: InputMaybe<Scalars['String']>;\n};\n\n\n/** Time Interval */\nexport type TimeIntervalminuteArgs = {\n  count?: InputMaybe<Scalars['Int']>;\n  format?: InputMaybe<Scalars['String']>;\n};\n\n\n/** Time Interval */\nexport type TimeIntervalmonthArgs = {\n  count?: InputMaybe<Scalars['Int']>;\n  format?: InputMaybe<Scalars['String']>;\n};\n\n\n/** Time Interval */\nexport type TimeIntervalsecondArgs = {\n  count?: InputMaybe<Scalars['Int']>;\n  format?: InputMaybe<Scalars['String']>;\n};\n\n\n/** Time Interval */\nexport type TimeIntervalyearArgs = {\n  count?: InputMaybe<Scalars['Int']>;\n  format?: InputMaybe<Scalars['String']>;\n};\n\n/** Timestamp */\nexport type Timestamp = {\n  __typename?: 'Timestamp';\n  /** Nanoseconds */\n  nanoseconds: Scalars['BigInt'];\n  time: Scalars['ISO8601Date'];\n};\n\n/** Select trade by ID */\nexport type TradeIdSelector = {\n  /** Trade ID in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Trade ID is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Trade ID not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Trade ID not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\nexport enum TradeSide {\n  /** Buy side */\n  BUY = 'BUY',\n  /** Sell side */\n  SELL = 'SELL'\n}\n\n/** Information about transaction */\nexport type TransactionElrond = {\n  __typename?: 'TransactionElrond';\n  /** Shard number of sender */\n  data?: Maybe<Scalars['String']>;\n  /** Shard number of sender */\n  dataOperation?: Maybe<Scalars['String']>;\n  fee?: Maybe<Scalars['Float']>;\n  /** Transaction hash */\n  hash?: Maybe<Scalars['String']>;\n  /** Transaction index */\n  index?: Maybe<Scalars['Int']>;\n  /** Transaction nonce */\n  nonce?: Maybe<Scalars['Int']>;\n  /** Hash of the receiver */\n  receiver?: Maybe<Address>;\n  /** Shard number of receiver */\n  receiverShard?: Maybe<Scalars['BigInt']>;\n  /** Hash of the sender */\n  sender?: Maybe<Address>;\n  /** Shard number of sender */\n  senderShard?: Maybe<Scalars['BigInt']>;\n  /** Shard number of sender */\n  signature?: Maybe<Scalars['String']>;\n  /** Shard number of sender */\n  status?: Maybe<Scalars['String']>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElronddataArgs = {\n  data?: InputMaybe<StringSelector>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElronddataOperationArgs = {\n  dataOperation?: InputMaybe<StringSelector>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElrondfeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElrondhashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElrondindexArgs = {\n  index?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElrondnonceArgs = {\n  nonce?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElrondreceiverArgs = {\n  txReceiver?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElrondreceiverShardArgs = {\n  txReceiverShard?: InputMaybe<IntIdSelector>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElrondsenderArgs = {\n  txSender?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElrondsenderShardArgs = {\n  txSenderShard?: InputMaybe<IntIdSelector>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElrondsignatureArgs = {\n  signature?: InputMaybe<HashSelector>;\n};\n\n\n/** Information about transaction */\nexport type TransactionElrondstatusArgs = {\n  status?: InputMaybe<StringSelector>;\n};\n\n/** Blockchain transaction */\nexport type TransactionHash = {\n  __typename?: 'TransactionHash';\n  /** Hash hex representation */\n  hash: Scalars['String'];\n};\n\n/** Blockchain transaction */\nexport type TransactionHashIndex = {\n  __typename?: 'TransactionHashIndex';\n  /** Block of the Output Transaction for this input */\n  block?: Maybe<Scalars['Int']>;\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0-based */\n  index: Scalars['String'];\n};\n\n/** Blockchain transaction with value */\nexport type TransactionHashValue = {\n  __typename?: 'TransactionHashValue';\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction value */\n  value: Scalars['Float'];\n};\n\n/** Transaction result */\nexport type TransactionResult = {\n  __typename?: 'TransactionResult';\n  /** Result ID */\n  id: Scalars['Int'];\n  /** Result name */\n  name: Scalars['String'];\n};\n\n/** Identification of transaction source as client application */\nexport type TransactionSource = {\n  __typename?: 'TransactionSource';\n  /** ID numeric */\n  code: Scalars['Int'];\n  /** Name */\n  name: Scalars['String'];\n};\n\nexport enum TransactionTypeEnum {\n  /** Delete an account */\n  AccountDelete = 'AccountDelete',\n  /** Set options on an account */\n  AccountSet = 'AccountSet',\n  /** Cancel a check */\n  CheckCancel = 'CheckCancel',\n  /** Redeem a check */\n  CheckCash = 'CheckCash',\n  /** Create a check */\n  CheckCreate = 'CheckCreate',\n  /** Preauthorizes an account to send payments to this one */\n  DepositPreauth = 'DepositPreauth',\n  /** Reclaim escrowed XRP */\n  EscrowCancel = 'EscrowCancel',\n  /** Create an ascrowed XRP payment */\n  EscrowCreate = 'EscrowCreate',\n  /** Deliver escrowed XRP recipient */\n  EscrowFinish = 'EscrowFinish',\n  /** Withdraw a currency-exchange order */\n  OfferCancel = 'OfferCancel',\n  /** Sibmit an order to exchange currency */\n  OfferCreate = 'OfferCreate',\n  /** Send funds from one account to another */\n  Payment = 'Payment',\n  /** Claim money from a payment channel */\n  PaymentChannelClaim = 'PaymentChannelClaim',\n  /** Open a new payment channel */\n  PaymentChannelCreate = 'PaymentChannelCreate',\n  /** Add more XRP to a payment channel */\n  PaymentChannelFund = 'PaymentChannelFund',\n  /** Add, remove or modify an accounts regular key pair */\n  SetRegularKey = 'SetRegularKey',\n  /** Add, remove, or modify an accounts multi-signing list */\n  SignerListSet = 'SignerListSet',\n  /** Setaside one or more sequence numbers as Tickets */\n  TicketCreate = 'TicketCreate',\n  /** Add or modify a trust line */\n  TrustSet = 'TrustSet'\n}\n\n/** Indicates what type of operation the transaction is supposed to do. */\nexport type TransactionTypeSelector = {\n  /** Type in the list */\n  in?: InputMaybe<Array<TransactionTypeEnum>>;\n  /** Type is */\n  is?: InputMaybe<TransactionTypeEnum>;\n  /** Type not */\n  not?: InputMaybe<TransactionTypeEnum>;\n  /** Type not in the list */\n  notIn?: InputMaybe<Array<TransactionTypeEnum>>;\n};\n\nexport enum TransferReasonEnum {\n  /** Smart Contract Call */\n  call_result = 'call_result',\n  /** ESDT Transfer */\n  esdt_transfer = 'esdt_transfer',\n  /** NFT Transfer */\n  nft_transfer = 'nft_transfer',\n  /** Transaction */\n  transaction = 'transaction'\n}\n\n/** Select by transfer reason */\nexport type TransferReasonSelector = {\n  /** Reason in the list */\n  in?: InputMaybe<Array<TransferReasonEnum>>;\n  /** Reason is */\n  is?: InputMaybe<TransferReasonEnum>;\n  /** Reason not */\n  not?: InputMaybe<TransferReasonEnum>;\n  /** Reason not in the list */\n  notIn?: InputMaybe<Array<TransferReasonEnum>>;\n};\n\n/** Select by type of transfer */\nexport type TransferTypeSelector = {\n  /** Transfer Type in the list */\n  in?: InputMaybe<Array<FilecoinTransferType>>;\n  /** Transfer Type is */\n  is?: InputMaybe<FilecoinTransferType>;\n  /** Transfer Type not */\n  not?: InputMaybe<FilecoinTransferType>;\n  /** Transfer Type not in the list */\n  notIn?: InputMaybe<Array<FilecoinTransferType>>;\n};\n\nexport enum TransfersUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique currencies */\n  currencies = 'currencies',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique receivers count */\n  receivers = 'receivers',\n  /** Unique senders count */\n  senders = 'senders',\n  /** Transfers */\n  transfers = 'transfers',\n  /** Unique transactions count */\n  txs = 'txs'\n}\n\n/** Tron Chain */\nexport type Tron = {\n  __typename?: 'Tron';\n  /** Basic information about address ( or smart contract ) */\n  address: Array<TronAddressInfo>;\n  /** Blockchain Blocks */\n  blocks?: Maybe<Array<TronBlocks>>;\n  /** Money flow using Coinpath technology */\n  coinpath?: Maybe<Array<TronCoinpath>>;\n  /** Blockchain Embedded Contracts */\n  contracts?: Maybe<Array<TronSmartContracts>>;\n  /** Trades on Ethereum DEX Smart Contracts */\n  dexTrades?: Maybe<Array<TronDexTrades>>;\n  /** Smart Contract Calls */\n  smartContractCalls?: Maybe<Array<TronSmartContractCalls>>;\n  /** Smart Contract Events */\n  smartContractEvents?: Maybe<Array<TronSmartContractEvents>>;\n  /** Blockchain Embedded Contracts */\n  trades?: Maybe<Array<TronTrades>>;\n  /** Blockchain Transactions */\n  transactions?: Maybe<Array<TronTransactions>>;\n  /** Currency Transfers */\n  transfers?: Maybe<Array<TronTransfers>>;\n};\n\n\n/** Tron Chain */\nexport type TronaddressArgs = {\n  address: Array<AddressSelectorIn>;\n};\n\n\n/** Tron Chain */\nexport type TronblocksArgs = {\n  any?: InputMaybe<Array<TronBlockFilter>>;\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  parentBlockHash?: InputMaybe<Array<HashSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  version?: InputMaybe<IntegerSelector>;\n  witness?: InputMaybe<AddressSelector>;\n};\n\n\n/** Tron Chain */\nexport type TroncoinpathArgs = {\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  depth?: InputMaybe<IntegerLimitedSelector>;\n  initialAddress?: InputMaybe<AddressSelector>;\n  initialDate?: InputMaybe<DateSelector>;\n  initialTime?: InputMaybe<DateTimeSelector>;\n  options?: InputMaybe<CoinpathOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Tron Chain */\nexport type TroncontractsArgs = {\n  any?: InputMaybe<Array<TronContractFilter>>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txOwner?: InputMaybe<AddressSelector>;\n};\n\n\n/** Tron Chain */\nexport type TrondexTradesArgs = {\n  any?: InputMaybe<Array<TronDexTradeFilter>>;\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  options?: InputMaybe<QueryOptions>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Tron Chain */\nexport type TronsmartContractCallsArgs = {\n  any?: InputMaybe<Array<TronSmartContractCallFilter>>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Tron Chain */\nexport type TronsmartContractEventsArgs = {\n  any?: InputMaybe<Array<TronSmartContractEventFilter>>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Tron Chain */\nexport type TrontradesArgs = {\n  amountBuy?: InputMaybe<Array<AmountSelector>>;\n  amountSell?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<TronTradeFilter>>;\n  buyCurrency?: InputMaybe<TronCurrencySelector>;\n  buyer?: InputMaybe<AddressSelector>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  date?: InputMaybe<DateSelector>;\n  exchangeId?: InputMaybe<IntIdSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  sellCurrency?: InputMaybe<TronCurrencySelector>;\n  seller?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Tron Chain */\nexport type TrontransactionsArgs = {\n  any?: InputMaybe<Array<TronTransactionFilter>>;\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Tron Chain */\nexport type TrontransfersArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  any?: InputMaybe<Array<TronTransferFilter>>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  options?: InputMaybe<QueryOptions>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n/** Address detailed information for Tron network */\nexport type TronAddressInfo = {\n  __typename?: 'TronAddressInfo';\n  /** Address */\n  address?: Maybe<Scalars['String']>;\n  /** Annotations ( tags ), if exists */\n  annotation?: Maybe<Scalars['String']>;\n  /** Smart Contract if exists on the address */\n  smartContract?: Maybe<TronSmartContractInfo>;\n};\n\nexport type TronBlockFilter = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  parentBlockHash?: InputMaybe<Array<HashSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  version?: InputMaybe<IntegerSelector>;\n  witness?: InputMaybe<AddressSelector>;\n};\n\n/** Blocks in Tron blockchain */\nexport type TronBlocks = {\n  __typename?: 'TronBlocks';\n  any?: Maybe<Scalars['String']>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  /** Block hash */\n  hash: Scalars['String'];\n  /** Block number (height) in blockchain */\n  height: Scalars['Int'];\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Parent block hash */\n  parentBlockHash: Scalars['String'];\n  /** Block timestamp */\n  timestamp?: Maybe<DateTime>;\n  /** TX Trie Root Hash */\n  txTrieRoot: Scalars['String'];\n  /** Block version */\n  version?: Maybe<Scalars['Int']>;\n  /** Block witness */\n  witness?: Maybe<Address>;\n  /** Witness signature */\n  witnessSignature: Scalars['String'];\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlocksanyArgs = {\n  of: TronBlocksMeasureable;\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlockscountArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  parentBlockHash?: InputMaybe<Array<HashSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<TronBlocksUniq>;\n  version?: InputMaybe<IntegerSelector>;\n  witness?: InputMaybe<AddressSelector>;\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlockscountBigIntArgs = {\n  blockHash?: InputMaybe<HashSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  parentBlockHash?: InputMaybe<Array<HashSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  uniq?: InputMaybe<TronBlocksUniq>;\n  version?: InputMaybe<IntegerSelector>;\n  witness?: InputMaybe<AddressSelector>;\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlockshashArgs = {\n  blockHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlocksheightArgs = {\n  height?: InputMaybe<BlockSelector>;\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlocksmaximumArgs = {\n  get?: InputMaybe<TronBlocksMeasureable>;\n  of: TronBlocksMeasureable;\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlocksminimumArgs = {\n  get?: InputMaybe<TronBlocksMeasureable>;\n  of: TronBlocksMeasureable;\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlocksparentBlockHashArgs = {\n  parentBlockHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlockstimestampArgs = {\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlocksversionArgs = {\n  version?: InputMaybe<IntegerSelector>;\n};\n\n\n/** Blocks in Tron blockchain */\nexport type TronBlockswitnessArgs = {\n  witness?: InputMaybe<AddressSelector>;\n};\n\nexport enum TronBlocksMeasureable {\n  /** Block */\n  block = 'block',\n  /** Block hash */\n  block_hash = 'block_hash',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Block Version */\n  version = 'version',\n  /** Block Witness address */\n  witness = 'witness'\n}\n\nexport enum TronBlocksUniq {\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique witness count */\n  witnesses = 'witnesses'\n}\n\nexport enum TronCallsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Call depth */\n  call_depth = 'call_depth',\n  /** Date */\n  date = 'date',\n  /** Smart Contract Method Signature */\n  signature = 'signature',\n  /** Smart Contract Method Signature Hash */\n  signature_hash = 'signature_hash',\n  /** Smart Contract Method Name */\n  signature_name = 'signature_name',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** Action From */\n  tx_from = 'tx_from',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Action To */\n  tx_to = 'tx_to'\n}\n\n/** Coinpath */\nexport type TronCoinpath = {\n  __typename?: 'TronCoinpath';\n  /** Summary of transfered value */\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transaction is included */\n  block?: Maybe<Block>;\n  /** Count of transfers */\n  count?: Maybe<Scalars['Int']>;\n  /** Count of transfers */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** 1-based hop depth of the graph */\n  depth?: Maybe<Scalars['Int']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Receiver address */\n  receiver?: Maybe<TronAddressInfo>;\n  /** Sender address */\n  sender?: Maybe<TronAddressInfo>;\n  /** Transaction of transfer happened */\n  transaction?: Maybe<TransactionHashValue>;\n};\n\n\n/** Coinpath */\nexport type TronCoinpathamountArgs = {\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Coinpath */\nexport type TronCoinpathanyArgs = {\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type TronCoinpathmaximumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\n\n/** Coinpath */\nexport type TronCoinpathminimumArgs = {\n  get?: InputMaybe<CoinpathMeasureable>;\n  of: CoinpathMeasureable;\n};\n\nexport type TronContractFilter = {\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txOwner?: InputMaybe<AddressSelector>;\n};\n\nexport enum TronContractType {\n  /** Account Create */\n  AccountCreate = 'AccountCreate',\n  /** Account Permission Update */\n  AccountPermissionUpdate = 'AccountPermissionUpdate',\n  /** Account Update */\n  AccountUpdate = 'AccountUpdate',\n  /** Asset Issue */\n  AssetIssue = 'AssetIssue',\n  /** Clear ABI */\n  ClearABI = 'ClearABI',\n  /** Create Smart */\n  CreateSmart = 'CreateSmart',\n  /** Exchange Create */\n  ExchangeCreate = 'ExchangeCreate',\n  /** Exchange Inject */\n  ExchangeInject = 'ExchangeInject',\n  /** Exchange Transaction */\n  ExchangeTransaction = 'ExchangeTransaction',\n  /** Exchange Withdraw */\n  ExchangeWithdraw = 'ExchangeWithdraw',\n  /** Freeze Balance */\n  FreezeBalance = 'FreezeBalance',\n  /** Participate Asset Issue */\n  ParticipateAssetIssue = 'ParticipateAssetIssue',\n  /** Proposal Approve */\n  ProposalApprove = 'ProposalApprove',\n  /** Proposal Create */\n  ProposalCreate = 'ProposalCreate',\n  /** Proposal Delete */\n  ProposalDelete = 'ProposalDelete',\n  /** Set Account Id */\n  SetAccountId = 'SetAccountId',\n  /** Transfer */\n  Transfer = 'Transfer',\n  /** Transfer Asset */\n  TransferAsset = 'TransferAsset',\n  /** Trigger Smart */\n  TriggerSmart = 'TriggerSmart',\n  /** Unfreeze Asset */\n  UnfreezeAsset = 'UnfreezeAsset',\n  /** Unfreeze Balance */\n  UnfreezeBalance = 'UnfreezeBalance',\n  /** Update Asset */\n  UpdateAsset = 'UpdateAsset',\n  /** Update Brokerage */\n  UpdateBrokerage = 'UpdateBrokerage',\n  /** Update Energy Limit */\n  UpdateEnergyLimit = 'UpdateEnergyLimit',\n  /** Update Setting */\n  UpdateSetting = 'UpdateSetting',\n  /** Vote Witness */\n  VoteWitness = 'VoteWitness',\n  /** Withdraw Balance */\n  WithdrawBalance = 'WithdrawBalance',\n  /** Witness Create */\n  WitnessCreate = 'WitnessCreate',\n  /** Witness Update */\n  WitnessUpdate = 'WitnessUpdate'\n}\n\n/** Select contract type(s) */\nexport type TronContractTypeSelector = {\n  /** Contract type in the list */\n  in?: InputMaybe<Array<TronContractType>>;\n  /** Contract type is */\n  is?: InputMaybe<TronContractType>;\n  /** Contract type not */\n  not?: InputMaybe<TronContractType>;\n  /** Contract type not in the list */\n  notIn?: InputMaybe<Array<TronContractType>>;\n};\n\nexport enum TronContractsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Contract */\n  contract_type = 'contract_type',\n  /** Date */\n  date = 'date',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Transaction owner */\n  tx_owner = 'tx_owner'\n}\n\n/**\n * Currency selector in Tron blockchain.\n * Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10\n */\nexport type TronCurrencySelector = {\n  /** Currency in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Currency is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Currency not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Currency not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\n/** Tron DEX attributes */\nexport type TronDex = {\n  __typename?: 'TronDex';\n  /** Address for DEX exchange identification */\n  address: Address;\n  /** Full name ( name for known, Protocol for unknown ) */\n  fullName: Scalars['String'];\n  /** Full name ( name for known, Protocol / address for unknown ) */\n  fullNameWithId: Scalars['String'];\n  /** Name for known exchanges */\n  name?: Maybe<Scalars['String']>;\n};\n\nexport type TronDexTradeFilter = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n/** Trades on DEX smart contracts */\nexport type TronDexTrades = {\n  __typename?: 'TronDexTrades';\n  /** Trader (maker or taker) */\n  address?: Maybe<TronAddressInfo>;\n  any?: Maybe<Scalars['String']>;\n  baseAmount?: Maybe<Scalars['Float']>;\n  /** Base currency */\n  baseCurrency?: Maybe<Currency>;\n  /** Block in the blockchain */\n  block?: Maybe<BlockExtended>;\n  buyAmount?: Maybe<Scalars['Float']>;\n  /** Maker buys this currency */\n  buyCurrency?: Maybe<Currency>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  energyFee?: Maybe<Scalars['Float']>;\n  energyUsageTotal?: Maybe<Scalars['Float']>;\n  /** Identification of admin / manager / factory of smart contract, executing trades */\n  exchange?: Maybe<TronDex>;\n  fee?: Maybe<Scalars['Float']>;\n  internalTransactionsCount?: Maybe<Scalars['Int']>;\n  internalTransactionsCountBigInt?: Maybe<Scalars['BigInt']>;\n  logsCount?: Maybe<Scalars['Int']>;\n  logsCountBigInt?: Maybe<Scalars['BigInt']>;\n  /** Trade 'maker' side */\n  maker?: Maybe<TronAddressInfo>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  netFee?: Maybe<Scalars['Float']>;\n  netUsage?: Maybe<Scalars['Float']>;\n  price?: Maybe<Scalars['Float']>;\n  /** Protocol name of the smart contract */\n  protocol?: Maybe<Scalars['String']>;\n  quoteAmount?: Maybe<Scalars['Float']>;\n  /** Quote currency */\n  quoteCurrency?: Maybe<Currency>;\n  quotePrice?: Maybe<Scalars['Float']>;\n  sellAmount?: Maybe<Scalars['Float']>;\n  /** Maker sells this currency */\n  sellCurrency?: Maybe<Currency>;\n  /** Side of trade ( SELL / BUY ) */\n  side?: Maybe<TradeSide>;\n  /** Smart contract being called */\n  smartContract?: Maybe<TronSmartContract>;\n  /** Trade 'taker' side */\n  taker?: Maybe<TronAddressInfo>;\n  /** Time interval */\n  timeInterval?: Maybe<TimeInterval>;\n  tradeAmount?: Maybe<Scalars['Float']>;\n  /** Index of trade in transaction, used to separate trades in transaction */\n  tradeIndex?: Maybe<Scalars['String']>;\n  /** Transaction of DexTrade */\n  transaction?: Maybe<TronTransactionInfoExtended>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesaddressArgs = {\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesanyArgs = {\n  of: TronDexTradesMeasureable;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesbaseAmountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesbaseCurrencyArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesbuyAmountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesbuyCurrencyArgs = {\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradescountArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<TronDexTradesUniq>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradescountBigIntArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<TronDexTradesUniq>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesenergyFeeArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesenergyUsageTotalArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesexchangeArgs = {\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesfeeArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesinternalTransactionsCountArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesinternalTransactionsCountBigIntArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradeslogsCountArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradeslogsCountBigIntArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesmakerArgs = {\n  maker?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesmaximumArgs = {\n  get?: InputMaybe<TronDexTradesMeasureable>;\n  of: TronDexTradesMeasureable;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesminimumArgs = {\n  get?: InputMaybe<TronDexTradesMeasureable>;\n  of: TronDexTradesMeasureable;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesnetFeeArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesnetUsageArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradespriceArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  calculate?: InputMaybe<PriceAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesprotocolArgs = {\n  protocol?: InputMaybe<Array<StringSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesquoteAmountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesquoteCurrencyArgs = {\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradesquotePriceArgs = {\n  baseCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  buyAmount?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  calculate?: InputMaybe<PriceAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  exchangeAddress?: InputMaybe<Array<AddressSelector>>;\n  exchangeName?: InputMaybe<Array<StringSelector>>;\n  height?: InputMaybe<BlockSelector>;\n  maker?: InputMaybe<Array<AddressSelector>>;\n  makerOrTaker?: InputMaybe<Array<AddressSelector>>;\n  price?: InputMaybe<Array<AmountSelector>>;\n  priceAsymmetry?: InputMaybe<Array<FloatSelector>>;\n  protocol?: InputMaybe<Array<StringSelector>>;\n  quoteCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  sellAmount?: InputMaybe<Array<AmountSelector>>;\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n  taker?: InputMaybe<Array<AddressSelector>>;\n  time?: InputMaybe<DateTimeSelector>;\n  tradeAmountUsd?: InputMaybe<Array<FloatSelector>>;\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradessellAmountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradessellCurrencyArgs = {\n  sellCurrency?: InputMaybe<Array<TronCurrencySelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradessmartContractArgs = {\n  smartContractAddress?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradestakerArgs = {\n  taker?: InputMaybe<Array<AddressSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradestradeAmountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  in: BaseCurrencyEnum;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradestradeIndexArgs = {\n  tradeIndex?: InputMaybe<Array<StringSelector>>;\n};\n\n\n/** Trades on DEX smart contracts */\nexport type TronDexTradestransactionArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\nexport enum TronDexTradesMeasureable {\n  /** Block */\n  block = 'block',\n  /** Buy Amount */\n  buy_amount = 'buy_amount',\n  /** Buy Token address */\n  buy_currency_address = 'buy_currency_address',\n  /** Buy Currency symbol */\n  buy_currency_symbol = 'buy_currency_symbol',\n  /** Date */\n  date = 'date',\n  /** Maker */\n  maker = 'maker',\n  /** Price */\n  price = 'price',\n  /** Quote Price */\n  quote_price = 'quote_price',\n  /** Sell Amount */\n  sell_amount = 'sell_amount',\n  /** Sell Token address */\n  sell_currency_address = 'sell_currency_address',\n  /** Sell Currency symbol */\n  sell_currency_symbol = 'sell_currency_symbol',\n  /** Taker */\n  taker = 'taker',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\nexport enum TronDexTradesUniq {\n  /** Unique makers & takers count */\n  address = 'address',\n  /** Base currencies count */\n  base_currency = 'base_currency',\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Buy currencies count */\n  buy_currency = 'buy_currency',\n  /** Unique date count */\n  dates = 'dates',\n  /** Unique makers count */\n  makers = 'makers',\n  /** Unique protocols count */\n  protocols = 'protocols',\n  /** Quote currencies count */\n  quote_currency = 'quote_currency',\n  /** Sell currencies count */\n  sell_currency = 'sell_currency',\n  /** Unique smart contract count */\n  smart_contracts = 'smart_contracts',\n  /** Unique makers count */\n  takers = 'takers',\n  /** Unique transactions count */\n  txs = 'txs'\n}\n\nexport enum TronEventsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Smart Contract Method Signature */\n  signature = 'signature',\n  /** Smart Contract Method Signature Hash */\n  signature_hash = 'signature_hash',\n  /** Smart Contract Method Name */\n  signature_name = 'signature_name',\n  /** Smart Contract */\n  smart_contract = 'smart_contract',\n  /** Time */\n  time = 'time',\n  /** Action From */\n  tx_from = 'tx_from',\n  /** Transaction hash */\n  tx_hash = 'tx_hash',\n  /** Action To */\n  tx_to = 'tx_to'\n}\n\nexport enum TronNetwork {\n  /** TRON mainnet */\n  tron = 'tron'\n}\n\n/** Tron smart contract */\nexport type TronSmartContract = {\n  __typename?: 'TronSmartContract';\n  /** Smart Contract Address */\n  address: Address;\n  /** Smart Contract Type */\n  contractType?: Maybe<SmartContractType>;\n  /** Token implemented in this smart contract */\n  currency?: Maybe<Currency>;\n  /** Smart Contract Protocol Type */\n  protocolType?: Maybe<Scalars['String']>;\n};\n\nexport type TronSmartContractCallFilter = {\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n/** Smart Contract Calls */\nexport type TronSmartContractCalls = {\n  __typename?: 'TronSmartContractCalls';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */\n  callDepth?: Maybe<Scalars['String']>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  energyUsageTotal?: Maybe<Scalars['Float']>;\n  /** External call executed explicitly by caller. Internal calls executed by smart contracts. */\n  external?: Maybe<Scalars['Boolean']>;\n  fee?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  netUsage?: Maybe<Scalars['Float']>;\n  /** Smart contract being called */\n  smartContract?: Maybe<TronSmartContract>;\n  /** Contract method invoked */\n  smartContractMethod?: Maybe<Method>;\n  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Action from address */\n  txFrom?: Maybe<Address>;\n  /** Transaction hash where transfer happened */\n  txHash?: Maybe<Scalars['String']>;\n  /** Action to address */\n  txTo?: Maybe<Address>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallsamountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallsanyArgs = {\n  of: TronCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallscountArgs = {\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallscountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallsenergyUsageTotalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallsexternalArgs = {\n  external?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallsfeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallsmaximumArgs = {\n  get?: InputMaybe<TronCallsMeasureable>;\n  of: TronCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallsminimumArgs = {\n  get?: InputMaybe<TronCallsMeasureable>;\n  of: TronCallsMeasureable;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallsnetUsageArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  date?: InputMaybe<DateSelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractMethod?: InputMaybe<MethodSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallssmartContractArgs = {\n  smartContractAddress?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallssmartContractMethodArgs = {\n  smartContractMethod?: InputMaybe<MethodSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallssuccessArgs = {\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallstxFromArgs = {\n  txFrom?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallstxHashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Smart Contract Calls */\nexport type TronSmartContractCallstxToArgs = {\n  txTo?: InputMaybe<AddressSelector>;\n};\n\nexport type TronSmartContractEventFilter = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n/** Smart Contract Events */\nexport type TronSmartContractEvents = {\n  __typename?: 'TronSmartContractEvents';\n  any?: Maybe<Scalars['String']>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  /** Smart contract being Evented */\n  smartContract?: Maybe<TronSmartContract>;\n  /** Contract method invoked */\n  smartContractEvent?: Maybe<Event>;\n  /** Action from address */\n  txFrom?: Maybe<Address>;\n  /** Transaction hash where transfer happened */\n  txHash?: Maybe<Scalars['String']>;\n  /** Action to address */\n  txTo?: Maybe<Address>;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventsanyArgs = {\n  of: TronEventsMeasureable;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventscountArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventscountBigIntArgs = {\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  smartContractAddress?: InputMaybe<AddressSelector>;\n  smartContractEvent?: InputMaybe<EventSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventsmaximumArgs = {\n  get?: InputMaybe<TronEventsMeasureable>;\n  of: TronEventsMeasureable;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventsminimumArgs = {\n  get?: InputMaybe<TronEventsMeasureable>;\n  of: TronEventsMeasureable;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventssmartContractArgs = {\n  smartContractAddress?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventssmartContractEventArgs = {\n  smartContractEvent?: InputMaybe<EventSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventstxFromArgs = {\n  txFrom?: InputMaybe<AddressSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventstxHashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Smart Contract Events */\nexport type TronSmartContractEventstxToArgs = {\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n/** Blockchain smart contract */\nexport type TronSmartContractInfo = {\n  __typename?: 'TronSmartContractInfo';\n  /** Smart Contract Type */\n  contractType?: Maybe<SmartContractType>;\n  /** Token implemented in this smart contract */\n  currency?: Maybe<Currency>;\n  /** Smart Contract Protocol Type */\n  protocolType?: Maybe<Scalars['String']>;\n};\n\n/** Contracts */\nexport type TronSmartContracts = {\n  __typename?: 'TronSmartContracts';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block in the blockchain */\n  block?: Maybe<Block>;\n  /** Contract type */\n  contractType?: Maybe<TronContractType>;\n  /** Counts and other metrics */\n  count?: Maybe<Scalars['Int']>;\n  /** Counts and other metrics */\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  energyUsageTotal?: Maybe<Scalars['Float']>;\n  fee?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  netUsage?: Maybe<Scalars['Float']>;\n  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Transaction hash where transfer happened */\n  txHash?: Maybe<Scalars['String']>;\n  /** Transactio owner from address */\n  txOwner?: Maybe<Address>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractsamountArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txOwner?: InputMaybe<AddressSelector>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractsanyArgs = {\n  of: TronContractsMeasureable;\n};\n\n\n/** Contracts */\nexport type TronSmartContractsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractscontractTypeArgs = {\n  contractType?: InputMaybe<TronContractTypeSelector>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractscountArgs = {\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txOwner?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractscountBigIntArgs = {\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txOwner?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<SmartContractCallsUniq>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractscurrencyArgs = {\n  currency?: InputMaybe<TronCurrencySelector>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractsenergyUsageTotalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txOwner?: InputMaybe<AddressSelector>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractsfeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txOwner?: InputMaybe<AddressSelector>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractsmaximumArgs = {\n  get?: InputMaybe<TronContractsMeasureable>;\n  of: TronContractsMeasureable;\n};\n\n\n/** Contracts */\nexport type TronSmartContractsminimumArgs = {\n  get?: InputMaybe<TronContractsMeasureable>;\n  of: TronContractsMeasureable;\n};\n\n\n/** Contracts */\nexport type TronSmartContractsnetUsageArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txOwner?: InputMaybe<AddressSelector>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractssuccessArgs = {\n  success?: InputMaybe<Array<Scalars['Boolean']>>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractstxHashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Contracts */\nexport type TronSmartContractstxOwnerArgs = {\n  txOwner?: InputMaybe<AddressSelector>;\n};\n\nexport type TronTradeFilter = {\n  amountBuy?: InputMaybe<Array<AmountSelector>>;\n  amountSell?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<TronCurrencySelector>;\n  buyer?: InputMaybe<AddressSelector>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  date?: InputMaybe<DateSelector>;\n  exchangeId?: InputMaybe<IntIdSelector>;\n  height?: InputMaybe<BlockSelector>;\n  sellCurrency?: InputMaybe<TronCurrencySelector>;\n  seller?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTrades = {\n  __typename?: 'TronTrades';\n  amountBuy?: Maybe<Scalars['Float']>;\n  amountSell?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where Trade transaction is included */\n  block?: Maybe<Block>;\n  /** Buy Currency of Trade */\n  buyCurrency?: Maybe<Currency>;\n  /** Trade buyer */\n  buyer?: Maybe<Address>;\n  /** Contract type */\n  contractType?: Maybe<TronContractType>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  energyUsageTotal?: Maybe<Scalars['Float']>;\n  /** exchange_id */\n  exchangeId?: Maybe<Scalars['Int']>;\n  fee?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  netUsage?: Maybe<Scalars['Float']>;\n  /** Sell Currency of Trade */\n  sellCurrency?: Maybe<Currency>;\n  /** Trade seller */\n  seller?: Maybe<Address>;\n  /** Transfer succeeded */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Transaction hash where Trade happened */\n  txHash?: Maybe<Scalars['String']>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesamountBuyArgs = {\n  amountBuy?: InputMaybe<Array<AmountSelector>>;\n  amountSell?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<TronCurrencySelector>;\n  buyer?: InputMaybe<AddressSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  date?: InputMaybe<DateSelector>;\n  exchangeId?: InputMaybe<IntIdSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  sellCurrency?: InputMaybe<TronCurrencySelector>;\n  seller?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesamountSellArgs = {\n  amountBuy?: InputMaybe<Array<AmountSelector>>;\n  amountSell?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<TronCurrencySelector>;\n  buyer?: InputMaybe<AddressSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  date?: InputMaybe<DateSelector>;\n  exchangeId?: InputMaybe<IntIdSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  sellCurrency?: InputMaybe<TronCurrencySelector>;\n  seller?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesanyArgs = {\n  of: TronTradesMeasureable;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesbuyCurrencyArgs = {\n  buyCurrency?: InputMaybe<TronCurrencySelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesbuyerArgs = {\n  buyer?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradescontractTypeArgs = {\n  contractType?: InputMaybe<TronContractTypeSelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradescountArgs = {\n  amountBuy?: InputMaybe<Array<AmountSelector>>;\n  amountSell?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<TronCurrencySelector>;\n  buyer?: InputMaybe<AddressSelector>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  date?: InputMaybe<DateSelector>;\n  exchangeId?: InputMaybe<IntIdSelector>;\n  height?: InputMaybe<BlockSelector>;\n  sellCurrency?: InputMaybe<TronCurrencySelector>;\n  seller?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<TronTradesUniq>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradescountBigIntArgs = {\n  amountBuy?: InputMaybe<Array<AmountSelector>>;\n  amountSell?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<TronCurrencySelector>;\n  buyer?: InputMaybe<AddressSelector>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  date?: InputMaybe<DateSelector>;\n  exchangeId?: InputMaybe<IntIdSelector>;\n  height?: InputMaybe<BlockSelector>;\n  sellCurrency?: InputMaybe<TronCurrencySelector>;\n  seller?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  uniq?: InputMaybe<TronTradesUniq>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesenergyUsageTotalArgs = {\n  amountBuy?: InputMaybe<Array<AmountSelector>>;\n  amountSell?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<TronCurrencySelector>;\n  buyer?: InputMaybe<AddressSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  date?: InputMaybe<DateSelector>;\n  exchangeId?: InputMaybe<IntIdSelector>;\n  height?: InputMaybe<BlockSelector>;\n  sellCurrency?: InputMaybe<TronCurrencySelector>;\n  seller?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesexchangeIdArgs = {\n  exchangeId?: InputMaybe<IntIdSelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesfeeArgs = {\n  amountBuy?: InputMaybe<Array<AmountSelector>>;\n  amountSell?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<TronCurrencySelector>;\n  buyer?: InputMaybe<AddressSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  date?: InputMaybe<DateSelector>;\n  exchangeId?: InputMaybe<IntIdSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  sellCurrency?: InputMaybe<TronCurrencySelector>;\n  seller?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesmaximumArgs = {\n  get?: InputMaybe<TronTradesMeasureable>;\n  of: TronTradesMeasureable;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesminimumArgs = {\n  get?: InputMaybe<TronTradesMeasureable>;\n  of: TronTradesMeasureable;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradesnetUsageArgs = {\n  amountBuy?: InputMaybe<Array<AmountSelector>>;\n  amountSell?: InputMaybe<Array<AmountSelector>>;\n  buyCurrency?: InputMaybe<TronCurrencySelector>;\n  buyer?: InputMaybe<AddressSelector>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  date?: InputMaybe<DateSelector>;\n  exchangeId?: InputMaybe<IntIdSelector>;\n  height?: InputMaybe<BlockSelector>;\n  sellCurrency?: InputMaybe<TronCurrencySelector>;\n  seller?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradessellCurrencyArgs = {\n  sellCurrency?: InputMaybe<TronCurrencySelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradessellerArgs = {\n  seller?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradessuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Currency Trades from/to addresses in crypto currencies */\nexport type TronTradestxHashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\nexport enum TronTradesMeasureable {\n  /** Amount Sell */\n  amount_buy = 'amount_buy',\n  /** Amount Sell */\n  amount_sell = 'amount_sell',\n  /** Block */\n  block = 'block',\n  /** Buy Token address */\n  buy_currency_address = 'buy_currency_address',\n  /** Buy Currency name */\n  buy_currency_name = 'buy_currency_name',\n  /** Buy Currency symbol */\n  buy_currency_symbol = 'buy_currency_symbol',\n  /** Buy Token address */\n  buy_token_id = 'buy_token_id',\n  /** Buy Token type */\n  buy_token_type = 'buy_token_type',\n  /** Buyer */\n  buyer = 'buyer',\n  /** Contract Type */\n  contract_type = 'contract_type',\n  /** Date */\n  date = 'date',\n  /** Exchange ID */\n  exchange_id = 'exchange_id',\n  /** Buy Token address */\n  sell_currency_address = 'sell_currency_address',\n  /** Buy Currency name */\n  sell_currency_name = 'sell_currency_name',\n  /** Buy Currency symbol */\n  sell_currency_symbol = 'sell_currency_symbol',\n  /** Buy Token address */\n  sell_token_id = 'sell_token_id',\n  /** Buy Token type */\n  sell_token_type = 'sell_token_type',\n  /** Seller */\n  seller = 'seller',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\nexport enum TronTradesUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Buy currencies */\n  buy_currencies = 'buy_currencies',\n  /** Buyers count */\n  buyers = 'buyers',\n  /** Unique date count */\n  dates = 'dates',\n  /** Exchange IDs */\n  exchanges = 'exchanges',\n  /** Sell currencies */\n  sell_currencies = 'sell_currencies',\n  /** Sellers count */\n  sellers = 'sellers'\n}\n\nexport type TronTransactionFilter = {\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n/** Blockchain Transaction Extended info */\nexport type TronTransactionInfoExtended = {\n  __typename?: 'TronTransactionInfoExtended';\n  /** Contract Address */\n  contractAddress?: Maybe<Address>;\n  /** Expiration */\n  expiration: Scalars['Int'];\n  /** Fee Limit */\n  feeLimit: Scalars['Int'];\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0 based */\n  index?: Maybe<Scalars['Int']>;\n  /** Ref block Hash hex representation */\n  refBlockHash: Scalars['String'];\n  /** Result message */\n  result?: Maybe<Scalars['String']>;\n  /** Signatures */\n  signatures: Scalars['String'];\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n};\n\n/** Transactions in Tron blockchain */\nexport type TronTransactions = {\n  __typename?: 'TronTransactions';\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  /** Contract Address */\n  contractAddress?: Maybe<Address>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  energyFee?: Maybe<Scalars['Float']>;\n  energyUsageTotal?: Maybe<Scalars['Float']>;\n  /** Expiration */\n  expiration: Scalars['Int'];\n  fee?: Maybe<Scalars['Float']>;\n  /** Fee Limit */\n  feeLimit: Scalars['Int'];\n  /** Hash hex representation */\n  hash: Scalars['String'];\n  /** Transaction index in block, 0 based */\n  index?: Maybe<Scalars['Int']>;\n  internalTransactionsCount?: Maybe<Scalars['Int']>;\n  internalTransactionsCountBigInt?: Maybe<Scalars['BigInt']>;\n  logsCount?: Maybe<Scalars['Int']>;\n  logsCountBigInt?: Maybe<Scalars['BigInt']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  netFee?: Maybe<Scalars['Float']>;\n  netUsage?: Maybe<Scalars['Float']>;\n  /** Ref block Hash hex representation */\n  refBlockHash: Scalars['String'];\n  /** Result message */\n  result?: Maybe<Scalars['String']>;\n  /** Signatures */\n  signatures: Scalars['String'];\n  /** Success */\n  success?: Maybe<Scalars['Boolean']>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsanyArgs = {\n  of: TronTransactionsMeasureable;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionscontractAddressArgs = {\n  contractAddress?: InputMaybe<AddressSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionscountArgs = {\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  uniq?: InputMaybe<TronTransactionsUniq>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionscountBigIntArgs = {\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n  uniq?: InputMaybe<TronTransactionsUniq>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsenergyFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsenergyUsageTotalArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsfeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionshashArgs = {\n  txHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsindexArgs = {\n  txIndex?: InputMaybe<Array<TxIndexSelector>>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsinternalTransactionsCountArgs = {\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsinternalTransactionsCountBigIntArgs = {\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionslogsCountArgs = {\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionslogsCountBigIntArgs = {\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsmaximumArgs = {\n  get?: InputMaybe<TronTransactionsMeasureable>;\n  of: TronTransactionsMeasureable;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsminimumArgs = {\n  get?: InputMaybe<TronTransactionsMeasureable>;\n  of: TronTransactionsMeasureable;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsnetFeeArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsnetUsageArgs = {\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractAddress?: InputMaybe<AddressSelector>;\n  date?: InputMaybe<DateSelector>;\n  height?: InputMaybe<BlockSelector>;\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txIndex?: InputMaybe<TxIndexSelector>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionsrefBlockHashArgs = {\n  refBlockHash?: InputMaybe<Array<HashSelector>>;\n};\n\n\n/** Transactions in Tron blockchain */\nexport type TronTransactionssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport enum TronTransactionsMeasureable {\n  /** Block */\n  block = 'block',\n  /** Date */\n  date = 'date',\n  /** Energy Fee */\n  energy_fee = 'energy_fee',\n  /** Fee */\n  fee = 'fee',\n  /** Fee Limit */\n  fee_limit = 'fee_limit',\n  /** Internal transactions count */\n  internal_transactions_count = 'internal_transactions_count',\n  /** Net usage */\n  net_usage = 'net_usage',\n  /** Time */\n  time = 'time',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\nexport enum TronTransactionsUniq {\n  /** Unique blocks */\n  blocks = 'blocks',\n  /** Unique date count */\n  dates = 'dates'\n}\n\nexport type TronTransferFilter = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfers = {\n  __typename?: 'TronTransfers';\n  amount?: Maybe<Scalars['Float']>;\n  any?: Maybe<Scalars['String']>;\n  /** Block where transfer transaction is included */\n  block?: Maybe<Block>;\n  /** Contract type */\n  contractType?: Maybe<TronContractType>;\n  count?: Maybe<Scalars['Int']>;\n  countBigInt?: Maybe<Scalars['BigInt']>;\n  /** Currency of transfer */\n  currency?: Maybe<Currency>;\n  /** Calendar date */\n  date?: Maybe<Date>;\n  energyUsageTotal?: Maybe<Scalars['Float']>;\n  /** Entity identifier ( for ERC-721 NFT tokens ) */\n  entityId?: Maybe<Scalars['String']>;\n  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */\n  external?: Maybe<Scalars['Boolean']>;\n  fee?: Maybe<Scalars['Float']>;\n  maximum?: Maybe<Scalars['String']>;\n  minimum?: Maybe<Scalars['String']>;\n  netUsage?: Maybe<Scalars['Float']>;\n  /** Transfer receiver */\n  receiver?: Maybe<Address>;\n  /** Transfer sender */\n  sender?: Maybe<Address>;\n  /** Transfer succeeded */\n  success?: Maybe<Scalars['Boolean']>;\n  /** Action from address */\n  txFrom?: Maybe<Address>;\n  /** Transaction hash where transfer happened */\n  txHash?: Maybe<Scalars['String']>;\n  /** Action to address */\n  txTo?: Maybe<Address>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersamountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersanyArgs = {\n  of: TronTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersblockArgs = {\n  height?: InputMaybe<BlockSelector>;\n  time?: InputMaybe<DateTimeSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransferscontractTypeArgs = {\n  contractType?: InputMaybe<TronContractTypeSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransferscountArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransferscountBigIntArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n  uniq?: InputMaybe<TransfersUniq>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransferscurrencyArgs = {\n  currency?: InputMaybe<TronCurrencySelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersenergyUsageTotalArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersentityIdArgs = {\n  entityId?: InputMaybe<EntitySelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersexternalArgs = {\n  external?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersfeeArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  in?: InputMaybe<BaseCurrencyEnum>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersmaximumArgs = {\n  get?: InputMaybe<TronTransfersMeasureable>;\n  of: TronTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersminimumArgs = {\n  get?: InputMaybe<TronTransfersMeasureable>;\n  of: TronTransfersMeasureable;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersnetUsageArgs = {\n  amount?: InputMaybe<Array<AmountSelector>>;\n  calculate?: InputMaybe<AmountAggregateFunction>;\n  contractType?: InputMaybe<TronContractTypeSelector>;\n  currency?: InputMaybe<TronCurrencySelector>;\n  date?: InputMaybe<DateSelector>;\n  entityId?: InputMaybe<EntitySelector>;\n  external?: InputMaybe<Scalars['Boolean']>;\n  height?: InputMaybe<BlockSelector>;\n  receiver?: InputMaybe<AddressSelector>;\n  sender?: InputMaybe<AddressSelector>;\n  success?: InputMaybe<Scalars['Boolean']>;\n  time?: InputMaybe<DateTimeSelector>;\n  txFrom?: InputMaybe<AddressSelector>;\n  txHash?: InputMaybe<HashSelector>;\n  txTo?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransfersreceiverArgs = {\n  receiver?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransferssenderArgs = {\n  sender?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransferssuccessArgs = {\n  success?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransferstxFromArgs = {\n  txFrom?: InputMaybe<AddressSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransferstxHashArgs = {\n  txHash?: InputMaybe<HashSelector>;\n};\n\n\n/** Currency transfers from/to addresses in crypto currencies */\nexport type TronTransferstxToArgs = {\n  txTo?: InputMaybe<AddressSelector>;\n};\n\nexport enum TronTransfersMeasureable {\n  /** Amount */\n  amount = 'amount',\n  /** Block */\n  block = 'block',\n  /** Token address */\n  currency_address = 'currency_address',\n  /** Currency symbol */\n  currency_symbol = 'currency_symbol',\n  /** Date */\n  date = 'date',\n  /** Receiver */\n  receiver = 'receiver',\n  /** Sender */\n  sender = 'sender',\n  /** Time */\n  time = 'time',\n  /** Token ID */\n  token_id = 'token_id',\n  /** Token type */\n  token_type = 'token_type',\n  /** Transaction hash */\n  tx_hash = 'tx_hash'\n}\n\n/** Selector of index of transaction in block */\nexport type TxIndexSelector = {\n  /** Tx index in the list */\n  in?: InputMaybe<Array<Scalars['Int']>>;\n  /** Tx index is */\n  is?: InputMaybe<Scalars['Int']>;\n  /** Tx index not */\n  not?: InputMaybe<Scalars['Int']>;\n  /** Tx index not in the list */\n  notIn?: InputMaybe<Array<Scalars['Int']>>;\n};\n\n/** Select transactions by subtype */\nexport type TxSubtypeSelector = {\n  /** Transaction SubType in the list */\n  in?: InputMaybe<Array<AlgorandTxSubType>>;\n  /** Transaction SubType is */\n  is?: InputMaybe<AlgorandTxSubType>;\n  /** Transaction SubType not */\n  not?: InputMaybe<AlgorandTxSubType>;\n  /** Transaction SubType not in the list */\n  notIn?: InputMaybe<Array<AlgorandTxSubType>>;\n};\n\n/** Select transactions by type */\nexport type TxTypeSelector = {\n  /** Transaction Type in the list */\n  in?: InputMaybe<Array<AlgorandTxType>>;\n  /** Transaction Type is */\n  is?: InputMaybe<AlgorandTxType>;\n  /** Transaction Type not */\n  not?: InputMaybe<AlgorandTxType>;\n  /** Transaction Type not in the list */\n  notIn?: InputMaybe<Array<AlgorandTxType>>;\n};\n\n/** Select by type */\nexport type TypeSelector = {\n  /** Type in the list */\n  in?: InputMaybe<Array<Scalars['String']>>;\n  /** Type is */\n  is?: InputMaybe<Scalars['String']>;\n  /** Type not */\n  not?: InputMaybe<Scalars['String']>;\n  /** Type not in the list */\n  notIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\nexport type getOffChanQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type getOffChanQuery = { __typename?: 'Query', offchain?: { __typename?: 'Offchain', covid?: { __typename?: 'CovidHistory', facts?: Array<{ __typename?: 'CovidFact', confirmed?: number | null | undefined, recovered?: number | null | undefined, deaths?: number | null | undefined }> | null | undefined } | null | undefined } | null | undefined };\n\nexport type GetFactsQueryVariables = Exact<{\n  from?: InputMaybe<Scalars['ISO8601DateTime']>;\n  till?: InputMaybe<Scalars['ISO8601DateTime']>;\n}>;\n\n\nexport type GetFactsQuery = { __typename?: 'Query', offchain?: { __typename?: 'Offchain', covid?: { __typename?: 'CovidHistory', facts?: Array<{ __typename?: 'CovidFact', confirmed?: number | null | undefined, recovered?: number | null | undefined, deaths?: number | null | undefined }> | null | undefined } | null | undefined } | null | undefined };\n\nexport type GetFactsPerDatesQueryVariables = Exact<{\n  from?: InputMaybe<Scalars['ISO8601DateTime']>;\n  till?: InputMaybe<Scalars['ISO8601DateTime']>;\n}>;\n\n\nexport type GetFactsPerDatesQuery = { __typename?: 'Query', offchain?: { __typename?: 'Offchain', covid?: { __typename?: 'CovidHistory', facts?: Array<{ __typename?: 'CovidFact', confirmed?: number | null | undefined, recovered?: number | null | undefined, deaths?: number | null | undefined, date?: { __typename?: 'Date', date: string } | null | undefined }> | null | undefined } | null | undefined } | null | undefined };\n\n\nexport const getOffChanDocument = gql`\n    query getOffChan {\n  offchain {\n    covid {\n      facts {\n        confirmed\n        recovered\n        deaths\n      }\n    }\n  }\n}\n    `;\n\n/**\n * __usegetOffChanQuery__\n *\n * To run a query within a React component, call `usegetOffChanQuery` and pass it any options that fit your needs.\n * When your component renders, `usegetOffChanQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = usegetOffChanQuery({\n *   variables: {\n *   },\n * });\n */\nexport function usegetOffChanQuery(baseOptions?: Apollo.QueryHookOptions<getOffChanQuery, getOffChanQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<getOffChanQuery, getOffChanQueryVariables>(getOffChanDocument, options);\n      }\nexport function usegetOffChanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<getOffChanQuery, getOffChanQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<getOffChanQuery, getOffChanQueryVariables>(getOffChanDocument, options);\n        }\nexport type getOffChanQueryHookResult = ReturnType<typeof usegetOffChanQuery>;\nexport type getOffChanLazyQueryHookResult = ReturnType<typeof usegetOffChanLazyQuery>;\nexport type getOffChanQueryResult = Apollo.QueryResult<getOffChanQuery, getOffChanQueryVariables>;\nexport const GetFactsDocument = gql`\n    query GetFacts($from: ISO8601DateTime, $till: ISO8601DateTime) {\n  offchain {\n    covid {\n      facts(date: {since: $from, till: $till}) {\n        confirmed\n        recovered\n        deaths\n      }\n    }\n  }\n}\n    `;\n\n/**\n * __useGetFactsQuery__\n *\n * To run a query within a React component, call `useGetFactsQuery` and pass it any options that fit your needs.\n * When your component renders, `useGetFactsQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useGetFactsQuery({\n *   variables: {\n *      from: // value for 'from'\n *      till: // value for 'till'\n *   },\n * });\n */\nexport function useGetFactsQuery(baseOptions?: Apollo.QueryHookOptions<GetFactsQuery, GetFactsQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<GetFactsQuery, GetFactsQueryVariables>(GetFactsDocument, options);\n      }\nexport function useGetFactsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFactsQuery, GetFactsQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<GetFactsQuery, GetFactsQueryVariables>(GetFactsDocument, options);\n        }\nexport type GetFactsQueryHookResult = ReturnType<typeof useGetFactsQuery>;\nexport type GetFactsLazyQueryHookResult = ReturnType<typeof useGetFactsLazyQuery>;\nexport type GetFactsQueryResult = Apollo.QueryResult<GetFactsQuery, GetFactsQueryVariables>;\nexport const GetFactsPerDatesDocument = gql`\n    query GetFactsPerDates($from: ISO8601DateTime, $till: ISO8601DateTime) {\n  offchain {\n    covid {\n      facts(date: {since: $from, till: $till}, options: {asc: \"date.date\"}) {\n        date {\n          date\n        }\n        confirmed\n        recovered\n        deaths\n      }\n    }\n  }\n}\n    `;\n\n/**\n * __useGetFactsPerDatesQuery__\n *\n * To run a query within a React component, call `useGetFactsPerDatesQuery` and pass it any options that fit your needs.\n * When your component renders, `useGetFactsPerDatesQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useGetFactsPerDatesQuery({\n *   variables: {\n *      from: // value for 'from'\n *      till: // value for 'till'\n *   },\n * });\n */\nexport function useGetFactsPerDatesQuery(baseOptions?: Apollo.QueryHookOptions<GetFactsPerDatesQuery, GetFactsPerDatesQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<GetFactsPerDatesQuery, GetFactsPerDatesQueryVariables>(GetFactsPerDatesDocument, options);\n      }\nexport function useGetFactsPerDatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFactsPerDatesQuery, GetFactsPerDatesQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<GetFactsPerDatesQuery, GetFactsPerDatesQueryVariables>(GetFactsPerDatesDocument, options);\n        }\nexport type GetFactsPerDatesQueryHookResult = ReturnType<typeof useGetFactsPerDatesQuery>;\nexport type GetFactsPerDatesLazyQueryHookResult = ReturnType<typeof useGetFactsPerDatesLazyQuery>;\nexport type GetFactsPerDatesQueryResult = Apollo.QueryResult<GetFactsPerDatesQuery, GetFactsPerDatesQueryVariables>;","import {\r\n    endOfMonth,\r\n    endOfWeek,\r\n    endOfYear,\r\n    format,\r\n    startOfMonth,\r\n    startOfWeek,\r\n    startOfYear,\r\n    subMonths,\r\n} from 'date-fns';\r\n\r\nexport type RangeOption = {\r\n    label: string;\r\n    value: number;\r\n    range: [string, string];\r\n};\r\n\r\nexport function getRangeOptions(): RangeOption[] {\r\n    const dateFormat = 'yyyy-MM-dd';\r\n    return [\r\n        {\r\n            label: 'Last 7 days',\r\n            value: 1,\r\n            range: [\r\n                format(startOfWeek(new Date()), dateFormat),\r\n                format(endOfWeek(new Date()), dateFormat),\r\n            ],\r\n        },\r\n        {\r\n            label: 'This month',\r\n            value: 2,\r\n            range: [\r\n                format(startOfMonth(new Date()), dateFormat),\r\n                format(endOfMonth(new Date()), dateFormat),\r\n            ],\r\n        },\r\n        {\r\n            label: 'Last month',\r\n            value: 3,\r\n            range: [\r\n                format(startOfMonth(subMonths(new Date(), 1)), dateFormat),\r\n                format(endOfMonth(subMonths(new Date(), 1)), dateFormat),\r\n            ],\r\n        },\r\n        {\r\n            label: 'This year',\r\n            value: 4,\r\n            range: [\r\n                format(startOfYear(new Date()), dateFormat),\r\n                format(endOfYear(new Date()), dateFormat),\r\n            ],\r\n        },\r\n    ];\r\n}\r\n","import { Row, Col } from 'antd';\r\nimport { StatCard } from 'components/StatCard';\r\nimport { useTranslation } from 'react-i18next';\r\nimport { Line } from '@ant-design/charts';\r\nimport { useEffect, useMemo } from 'react';\r\nimport { useGetFactsLazyQuery, useGetFactsPerDatesLazyQuery } from 'graphql/generated';\r\nimport { useGlobalState } from 'constants/globalState';\r\nimport { find, flatMap } from 'lodash';\r\nimport { getRangeOptions, RangeOption } from 'utils/dates';\r\n\r\nfunction World() {\r\n    const { t } = useTranslation();\r\n    const [getFacts, { loading: factsLoading, data: factsData }] = useGetFactsLazyQuery();\r\n    const [getFactsPerDates, { loading: factsPerDatesLoading, data: factsPerDatesData }] =\r\n        useGetFactsPerDatesLazyQuery();\r\n    const [rangeType] = useGlobalState('dateRangeType');\r\n\r\n    const calculateChartData = useMemo(\r\n        () =>\r\n            flatMap(factsPerDatesData?.offchain?.covid?.facts, (fact) => [\r\n                { year: fact.date?.date, value: fact.confirmed, category: t('Confirmed') },\r\n                { year: fact.date?.date, value: fact.deaths, category: t('Deaths') },\r\n                { year: fact.date?.date, value: fact.recovered, category: t('Recovered') },\r\n            ]),\r\n        [factsPerDatesData]\r\n    );\r\n\r\n    useEffect(() => {\r\n        const { range } = find(getRangeOptions(), { value: rangeType }) as RangeOption;\r\n\r\n        if (range) {\r\n            getFacts({ variables: { from: range[0], till: range[1] } });\r\n            getFactsPerDates({ variables: { from: range[0], till: range[1] } });\r\n        }\r\n    }, [rangeType]);\r\n\r\n    return (\r\n        <Row gutter={[8, 8]}>\r\n            <Col xs={24} lg={8}>\r\n                <StatCard\r\n                    title={t('Confirmed')}\r\n                    kind=\"warning\"\r\n                    value={factsData?.offchain?.covid?.facts?.[0].confirmed || 0}\r\n                    loading={factsLoading}\r\n                />\r\n            </Col>\r\n            <Col xs={24} lg={8}>\r\n                <StatCard\r\n                    title={t('Recovered')}\r\n                    kind=\"success\"\r\n                    value={factsData?.offchain?.covid?.facts?.[0].recovered || 0}\r\n                    loading={factsLoading}\r\n                />\r\n            </Col>\r\n            <Col xs={24} lg={8}>\r\n                <StatCard\r\n                    title={t('Deaths')}\r\n                    kind=\"error\"\r\n                    value={factsData?.offchain?.covid?.facts?.[0].deaths || 0}\r\n                    loading={factsLoading}\r\n                />\r\n            </Col>\r\n            <Col xs={24} lg={24}>\r\n                <StatCard title={t('Count of new cases')} loading={factsPerDatesLoading}>\r\n                    <Line\r\n                        data={calculateChartData}\r\n                        height={400}\r\n                        xField=\"year\"\r\n                        yField=\"value\"\r\n                        seriesField=\"category\"\r\n                        xAxis={{\r\n                            type: 'time',\r\n                        }}\r\n                        color={['#1979C9', '#D62A0D', '#FAA219']}\r\n                    />\r\n                </StatCard>\r\n            </Col>\r\n        </Row>\r\n    );\r\n}\r\n\r\nexport default World;\r\n","import { DesktopOutlined, PieChartOutlined, UserOutlined } from '@ant-design/icons';\r\nimport Continents from 'pages/Continents';\r\nimport Countries from 'pages/Countries';\r\nimport World from 'pages/World';\r\n\r\nconst prefix = '/covid-19-stats';\r\n\r\nexport const routes = {\r\n    WORLD: {\r\n        path: `${prefix}/`,\r\n        component: <World />,\r\n        settings: {\r\n            icon: <PieChartOutlined />,\r\n        },\r\n        name: 'World',\r\n    },\r\n    COUNTRIES: {\r\n        path: `${prefix}/countries`,\r\n        component: <Countries />,\r\n        settings: {\r\n            icon: <DesktopOutlined />,\r\n        },\r\n        name: 'Countries',\r\n    },\r\n    CONTINENTS: {\r\n        path: `${prefix}/continents`,\r\n        component: <Continents />,\r\n        settings: {\r\n            icon: <UserOutlined />,\r\n        },\r\n        name: 'Continents',\r\n    },\r\n} as const;\r\n","import { Layout, Menu, Row, Typography, Select } from 'antd';\nimport { routes } from 'constants/routes';\nimport { map } from 'lodash';\nimport React from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Link, useLocation } from 'react-router-dom';\nimport { useGlobalState } from 'constants/globalState';\nimport { getRangeOptions } from 'utils/dates';\n\nconst { Content, Sider, Header } = Layout;\nconst { Title, Text } = Typography;\n\ntype Props = {\n    children?: React.ReactNode;\n};\n\nfunction Base({ children }: Props) {\n    const location = useLocation();\n    const { t } = useTranslation();\n    const [range, setRange] = useGlobalState('dateRangeType');\n\n    console.log(getRangeOptions(), 'getRangeOptions');\n\n    return (\n        <Layout className=\"h-screen\">\n            <Sider collapsible>\n                <Menu theme=\"dark\" selectedKeys={[location.pathname]} mode=\"inline\">\n                    {map(routes, ({ name, settings: { icon }, path }) => (\n                        <Menu.Item key={path} icon={icon}>\n                            <Link to={path}>{t(name)}</Link>\n                        </Menu.Item>\n                    ))}\n                </Menu>\n            </Sider>\n            <Layout>\n                <Header className=\"site-layout-background px-4\">\n                    <Row justify=\"space-between\" className=\"items-center\">\n                        <Title level={3} className=\"text-white m-0 lg:block md:block hidden\">\n                            {t('COVID-2019 Statistics')}\n                        </Title>\n                        <div>\n                            <Text className=\"text-white mr-2\">{t('Date range')}</Text>\n                            <Select\n                                value={range}\n                                onChange={(value) => setRange(value)}\n                                className=\"w-36\"\n                                options={map(getRangeOptions(), ({ value, label }) => ({\n                                    value,\n                                    label: t(label),\n                                }))}\n                            />\n                        </div>\n                    </Row>\n                </Header>\n                <Content className=\"p-4\" style={{ overflowY: 'auto' }}>\n                    {children}\n                </Content>\n            </Layout>\n        </Layout>\n    );\n}\n\nexport default Base;\n","import { Button, Result } from 'antd';\r\n\r\nfunction NoMatch() {\r\n    return (\r\n        <Result\r\n            status=\"404\"\r\n            title=\"404\"\r\n            subTitle=\"Sorry, the page you visited does not exist.\"\r\n            extra={<Button type=\"primary\">Back Home</Button>}\r\n        />\r\n    );\r\n}\r\n\r\nexport default NoMatch;\r\n","import translationENGB from 'locales/enGB/translation.json';\r\nimport i18n from 'i18next';\r\nimport { initReactI18next } from 'react-i18next';\r\n\r\nconst resources = {\r\n    enGB: {\r\n        translation: translationENGB,\r\n    },\r\n};\r\n\r\ni18n.use(initReactI18next).init({\r\n    resources,\r\n    interpolation: {\r\n        escapeValue: false,\r\n    },\r\n    lng: 'enGB',\r\n    keySeparator: false,\r\n    fallbackLng: 'enGB',\r\n});\r\n\r\nexport default i18n;\r\n","import { ApolloClient, HttpLink, InMemoryCache } from '@apollo/client';\r\n\r\nexport function createApolloClient(authToken: string) {\r\n    return new ApolloClient({\r\n        link: new HttpLink({\r\n            uri: process.env.REACT_APP_API_URL,\r\n            headers: {\r\n                'X-API-KEY': authToken,\r\n            },\r\n        }),\r\n        cache: new InMemoryCache(),\r\n    });\r\n}\r\n","import { ApolloProvider } from '@apollo/client';\nimport { createApolloClient } from 'utils/api';\nimport './style/root.less';\nimport Base from 'layout/Base';\nimport { BrowserRouter, Route, Routes } from 'react-router-dom';\nimport NoMatch from 'pages/NoMatch';\nimport 'locales/config/i18n';\nimport { map } from 'lodash';\nimport { routes } from 'constants/routes';\n\nconst client = createApolloClient(process.env.REACT_APP_API_KEY as string);\n\nfunction App() {\n    return (\n        <ApolloProvider client={client}>\n            <BrowserRouter>\n                <Base>\n                    <Routes>\n                        {map(routes, ({ path, component }) => (\n                            <Route key={path} path={path} element={component} />\n                        ))}\n\n                        <Route path=\"*\" element={<NoMatch />} />\n                    </Routes>\n                </Base>\n            </BrowserRouter>\n        </ApolloProvider>\n    );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n    if (onPerfEntry && onPerfEntry instanceof Function) {\n        import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n            getCLS(onPerfEntry);\n            getFID(onPerfEntry);\n            getFCP(onPerfEntry);\n            getLCP(onPerfEntry);\n            getTTFB(onPerfEntry);\n        });\n    }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Root from 'layout/Root';\nimport reportWebVitals from 'reportWebVitals';\n\nReactDOM.render(\n    <React.StrictMode>\n        <Root />\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}